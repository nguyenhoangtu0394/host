(self["webpackChunksas_booking"] = self["webpackChunksas_booking"] || []).push([["vendors-node_modules_pnpm_react-navigation_native_7_0_14_react-native_0_78_2__babel_core_7_26-91cf7e"], {
54670: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _object_without_properties = __webpack_require__(45922);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.BaseNavigationContainer = void 0;
var _routers = __webpack_require__(38686);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _useLatestCallback = _interopRequireDefault(__webpack_require__(34467));
var _checkDuplicateRouteNames = __webpack_require__(30464);
var _checkSerializable = __webpack_require__(79470);
var _createNavigationContainerRef = __webpack_require__(83700);
var _DeprecatedNavigationInChildContext = __webpack_require__(88862);
var _EnsureSingleNavigator = __webpack_require__(37594);
var _findFocusedRoute = __webpack_require__(85814);
var _NavigationBuilderContext = __webpack_require__(58911);
var _NavigationContainerRefContext = __webpack_require__(10999);
var _NavigationIndependentTreeContext = __webpack_require__(68307);
var _NavigationStateContext = __webpack_require__(26101);
var _ThemeProvider = __webpack_require__(56163);
var _UnhandledActionContext = __webpack_require__(38000);
var _useChildListeners = __webpack_require__(83802);
var _useEventEmitter = __webpack_require__(86908);
var _useKeyedChildListeners = __webpack_require__(37279);
var _useNavigationIndependentTree = __webpack_require__(72798);
var _useOptionsGetters = __webpack_require__(17222);
var _useSyncState = __webpack_require__(79674);
var _jsxRuntime = __webpack_require__(7100);
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var serializableWarnings = (/* unused pure expression or super */ null && ([]));
var duplicateNameWarnings = (/* unused pure expression or super */ null && ([]));
/**
 * Remove `key` and `routeNames` from the state objects recursively to get partial state.
 *
 * @param state Initial state object.
 */ var getPartialState = (state)=>{
    if (state === undefined) {
        return;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var key = state.key, routeNames = state.routeNames, partialState = _object_without_properties._(state, [
        "key",
        "routeNames"
    ]);
    return _object_spread_props._(_object_spread._({}, partialState), {
        stale: true,
        routes: state.routes.map((route)=>{
            if (route.state === undefined) {
                return route;
            }
            return _object_spread_props._(_object_spread._({}, route), {
                state: getPartialState(route.state)
            });
        })
    });
};
/**
 * Container component which holds the navigation state.
 * This should be rendered at the root wrapping the whole app.
 *
 * @param props.initialState Initial state object for the navigation tree.
 * @param props.onReady Callback which is called after the navigation tree mounts.
 * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
 * @param props.onUnhandledAction Callback which is called when an action is not handled.
 * @param props.theme Theme object for the UI elements.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which refers to the navigation object containing helper methods.
 */ var BaseNavigationContainer = exports.BaseNavigationContainer = /*#__PURE__*/ React.forwardRef(function BaseNavigationContainer(ref, ref1) {
    var initialState = ref.initialState, onStateChange = ref.onStateChange, onReady = ref.onReady, onUnhandledAction = ref.onUnhandledAction, _ref_navigationInChildEnabled = ref.navigationInChildEnabled, navigationInChildEnabled = _ref_navigationInChildEnabled === void 0 ? false : _ref_navigationInChildEnabled, theme = ref.theme, children = ref.children;
    var parent = React.useContext(_NavigationStateContext.NavigationStateContext);
    var independent = (0, _useNavigationIndependentTree.useNavigationIndependentTree)();
    if (!parent.isDefault && !independent) {
        throw new Error("Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, wrap the container in 'NavigationIndependentTree' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.");
    }
    var _ref = (0, _useSyncState.useSyncState)(()=>getPartialState(initialState == null ? undefined : initialState)), state = _ref.state, getState = _ref.getState, setState = _ref.setState, scheduleUpdate = _ref.scheduleUpdate, flushUpdates = _ref.flushUpdates;
    var isFirstMountRef = React.useRef(true);
    var navigatorKeyRef = React.useRef();
    var getKey = React.useCallback(()=>navigatorKeyRef.current, []);
    var setKey = React.useCallback((key)=>{
        navigatorKeyRef.current = key;
    }, []);
    var _ref1 = (0, _useChildListeners.useChildListeners)(), listeners = _ref1.listeners, addListener = _ref1.addListener;
    var _ref2 = (0, _useKeyedChildListeners.useKeyedChildListeners)(), keyedListeners = _ref2.keyedListeners, addKeyedListener = _ref2.addKeyedListener;
    var dispatch = (0, _useLatestCallback.default)((action)=>{
        if (listeners.focus[0] == null) {
            console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
        } else {
            listeners.focus[0]((navigation)=>navigation.dispatch(action));
        }
    });
    var canGoBack = (0, _useLatestCallback.default)(()=>{
        if (listeners.focus[0] == null) {
            return false;
        }
        var _listeners_focus_ = listeners.focus[0]((navigation)=>navigation.canGoBack()), result = _listeners_focus_.result, handled = _listeners_focus_.handled;
        if (handled) {
            return result;
        } else {
            return false;
        }
    });
    var resetRoot = (0, _useLatestCallback.default)((state)=>{
        var _keyedListeners_getState_root, _keyedListeners_getState;
        var target = (state === null || state === void 0 ? void 0 : state.key) ?? ((_keyedListeners_getState_root = (_keyedListeners_getState = keyedListeners.getState).root) === null || _keyedListeners_getState_root === void 0 ? void 0 : _keyedListeners_getState_root.call(_keyedListeners_getState).key);
        if (target == null) {
            console.error(_createNavigationContainerRef.NOT_INITIALIZED_ERROR);
        } else {
            listeners.focus[0]((navigation)=>navigation.dispatch(_object_spread_props._(_object_spread._({}, _routers.CommonActions.reset(state)), {
                    target
                })));
        }
    });
    var getRootState = (0, _useLatestCallback.default)(()=>{
        var _keyedListeners_getState_root, _keyedListeners_getState;
        return (_keyedListeners_getState_root = (_keyedListeners_getState = keyedListeners.getState).root) === null || _keyedListeners_getState_root === void 0 ? void 0 : _keyedListeners_getState_root.call(_keyedListeners_getState);
    });
    var getCurrentRoute = (0, _useLatestCallback.default)(()=>{
        var state = getRootState();
        if (state == null) {
            return undefined;
        }
        var route = (0, _findFocusedRoute.findFocusedRoute)(state);
        return route;
    });
    var isReady = (0, _useLatestCallback.default)(()=>listeners.focus[0] != null);
    var emitter = (0, _useEventEmitter.useEventEmitter)();
    var _ref3 = (0, _useOptionsGetters.useOptionsGetters)({}), addOptionsGetter = _ref3.addOptionsGetter, getCurrentOptions = _ref3.getCurrentOptions;
    var navigation = React.useMemo(()=>_object_spread_props._(_object_spread._({}, Object.keys(_routers.CommonActions).reduce((acc, name)=>{
            var _routers_CommonActions;
            acc[name] = (...args)=>// @ts-expect-error: this is ok
                dispatch((_routers_CommonActions = _routers.CommonActions)[name].apply(_routers_CommonActions, _to_consumable_array._(args)));
            return acc;
        }, {}), emitter.create('root')), {
            dispatch,
            resetRoot,
            isFocused: ()=>true,
            canGoBack,
            getParent: ()=>undefined,
            getState,
            getRootState,
            getCurrentRoute,
            getCurrentOptions,
            isReady,
            setOptions: ()=>{
                throw new Error('Cannot call setOptions outside a screen');
            }
        }), [
        canGoBack,
        dispatch,
        emitter,
        getCurrentOptions,
        getCurrentRoute,
        getRootState,
        getState,
        isReady,
        resetRoot
    ]);
    React.useImperativeHandle(ref1, ()=>navigation, [
        navigation
    ]);
    var onDispatchAction = (0, _useLatestCallback.default)((action, noop)=>{
        emitter.emit({
            type: '__unsafe_action__',
            data: {
                action,
                noop,
                stack: stackRef.current
            }
        });
    });
    var lastEmittedOptionsRef = React.useRef();
    var onOptionsChange = (0, _useLatestCallback.default)((options)=>{
        if (lastEmittedOptionsRef.current === options) {
            return;
        }
        lastEmittedOptionsRef.current = options;
        emitter.emit({
            type: 'options',
            data: {
                options
            }
        });
    });
    var stackRef = React.useRef();
    var builderContext = React.useMemo(()=>({
            addListener,
            addKeyedListener,
            onDispatchAction,
            onOptionsChange,
            scheduleUpdate,
            flushUpdates,
            stackRef
        }), [
        addListener,
        addKeyedListener,
        onDispatchAction,
        onOptionsChange,
        scheduleUpdate,
        flushUpdates
    ]);
    var isInitialRef = React.useRef(true);
    var getIsInitial = React.useCallback(()=>isInitialRef.current, []);
    var context = React.useMemo(()=>({
            state,
            getState,
            setState,
            getKey,
            setKey,
            getIsInitial,
            addOptionsGetter
        }), [
        state,
        getState,
        setState,
        getKey,
        setKey,
        getIsInitial,
        addOptionsGetter
    ]);
    var onReadyRef = React.useRef(onReady);
    var onStateChangeRef = React.useRef(onStateChange);
    React.useEffect(()=>{
        isInitialRef.current = false;
        onStateChangeRef.current = onStateChange;
        onReadyRef.current = onReady;
    });
    var onReadyCalledRef = React.useRef(false);
    React.useEffect(()=>{
        if (!onReadyCalledRef.current && isReady()) {
            var _onReadyRef_current;
            onReadyCalledRef.current = true;
            (_onReadyRef_current = onReadyRef.current) === null || _onReadyRef_current === void 0 ? void 0 : _onReadyRef_current.call(onReadyRef);
        }
    }, [
        state,
        isReady
    ]);
    React.useEffect(()=>{
        var hydratedState = getRootState();
        if (false) { var message1, duplicateRouteNamesResult, i, path, params, reason, curr, location, serializableResult, pointer, message, prev }
        emitter.emit({
            type: 'state',
            data: {
                state
            }
        });
        if (!isFirstMountRef.current && onStateChangeRef.current) {
            onStateChangeRef.current(hydratedState);
        }
        isFirstMountRef.current = false;
    }, [
        getRootState,
        emitter,
        state
    ]);
    var defaultOnUnhandledAction = (0, _useLatestCallback.default)((action)=>{
        if (true) {
            return;
        }
        var payload = action.payload;
        var message = `The action '${action.type}'${payload ? ` with payload ${JSON.stringify(action.payload)}` : ''} was not handled by any navigator.`;
        switch(action.type){
            case 'NAVIGATE':
            case 'PUSH':
            case 'REPLACE':
            case 'JUMP_TO':
                if (payload === null || payload === void 0 ? void 0 : payload.name) {
                    message += `\n\nDo you have a screen named '${payload.name}'?\n\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.\n\nIf you're using conditional rendering, navigation will happen automatically and you shouldn't navigate manually.`;
                } else {
                    message += `\n\nYou need to pass the name of the screen to navigate to.\n\nSee https://reactnavigation.org/docs/navigation-actions for usage.`;
                }
                break;
            case 'GO_BACK':
            case 'POP':
            case 'POP_TO_TOP':
                message += `\n\nIs there any screen to go back to?`;
                break;
            case 'OPEN_DRAWER':
            case 'CLOSE_DRAWER':
            case 'TOGGLE_DRAWER':
                message += `\n\nIs your screen inside a Drawer navigator?`;
                break;
        }
        message += `\n\nThis is a development-only warning and won't be shown in production.`;
        console.error(message);
    });
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationIndependentTreeContext.NavigationIndependentTreeContext.Provider, {
        value: false,
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationContainerRefContext.NavigationContainerRefContext.Provider, {
            value: navigation,
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationBuilderContext.NavigationBuilderContext.Provider, {
                value: builderContext,
                children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationStateContext.NavigationStateContext.Provider, {
                    value: context,
                    children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_UnhandledActionContext.UnhandledActionContext.Provider, {
                        value: onUnhandledAction ?? defaultOnUnhandledAction,
                        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_DeprecatedNavigationInChildContext.DeprecatedNavigationInChildContext.Provider, {
                            value: navigationInChildEnabled,
                            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_EnsureSingleNavigator.EnsureSingleNavigator, {
                                children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_ThemeProvider.ThemeProvider, {
                                    value: theme,
                                    children: children
                                })
                            })
                        })
                    })
                })
            })
        })
    });
}); //# sourceMappingURL=BaseNavigationContainer.js.map


}),
86861: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CurrentRenderContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Context which holds the values for the current navigation tree.
 * Intended for use in SSR. This is not safe to use on the client.
 */ var CurrentRenderContext = exports.CurrentRenderContext = /*#__PURE__*/ React.createContext(undefined); //# sourceMappingURL=CurrentRenderContext.js.map


}),
88862: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DeprecatedNavigationInChildContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Context which enables deprecated bubbling to child navigators.
 */ var DeprecatedNavigationInChildContext = exports.DeprecatedNavigationInChildContext = /*#__PURE__*/ React.createContext(false); //# sourceMappingURL=DeprecatedNavigationInChildContext.js.map


}),
37594: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.EnsureSingleNavigator = EnsureSingleNavigator;
exports.SingleNavigatorContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _jsxRuntime = __webpack_require__(7100);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var MULTIPLE_NAVIGATOR_ERROR = `Another navigator is already registered for this container. You likely have multiple navigators under a single "NavigationContainer" or "Screen". Make sure each navigator is under a separate "Screen" container. See https://reactnavigation.org/docs/nesting-navigators for a guide on nesting.`;
var SingleNavigatorContext = exports.SingleNavigatorContext = /*#__PURE__*/ React.createContext(undefined);
/**
 * Component which ensures that there's only one navigator nested under it.
 */ function EnsureSingleNavigator(ref) {
    var children = ref.children;
    var navigatorKeyRef = React.useRef();
    var value = React.useMemo(()=>({
            register (key) {
                var currentKey = navigatorKeyRef.current;
                if (currentKey !== undefined && key !== currentKey) {
                    throw new Error(MULTIPLE_NAVIGATOR_ERROR);
                }
                navigatorKeyRef.current = key;
            },
            unregister (key) {
                var currentKey = navigatorKeyRef.current;
                if (key !== currentKey) {
                    return;
                }
                navigatorKeyRef.current = undefined;
            }
        }), []);
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(SingleNavigatorContext.Provider, {
        value: value,
        children: children
    });
} //# sourceMappingURL=EnsureSingleNavigator.js.map


}),
98963: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Group = Group;
/**
 * Empty component used for grouping screen configs.
 */ function Group(_) {
    /* istanbul ignore next */ return null;
} //# sourceMappingURL=Group.js.map


}),
58911: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationBuilderContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Context which holds the required helpers needed to build nested navigators.
 */ var NavigationBuilderContext = exports.NavigationBuilderContext = /*#__PURE__*/ React.createContext({
    onDispatchAction: ()=>undefined,
    onOptionsChange: ()=>undefined,
    scheduleUpdate: ()=>{
        throw new Error("Couldn't find a context for scheduling updates.");
    },
    flushUpdates: ()=>{
        throw new Error("Couldn't find a context for flushing updates.");
    }
}); //# sourceMappingURL=NavigationBuilderContext.js.map


}),
10999: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationContainerRefContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Context which holds the route prop for a screen.
 */ var NavigationContainerRefContext = exports.NavigationContainerRefContext = /*#__PURE__*/ React.createContext(undefined); //# sourceMappingURL=NavigationContainerRefContext.js.map


}),
40653: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Context which holds the navigation prop for a screen.
 */ var NavigationContext = exports.NavigationContext = /*#__PURE__*/ React.createContext(undefined); //# sourceMappingURL=NavigationContext.js.map


}),
12800: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationHelpersContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Context which holds the navigation helpers of the parent navigator.
 * Navigators should use this context in their view component.
 */ var NavigationHelpersContext = exports.NavigationHelpersContext = /*#__PURE__*/ React.createContext(undefined); //# sourceMappingURL=NavigationHelpersContext.js.map


}),
93114: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationIndependentTree = NavigationIndependentTree;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationContext = __webpack_require__(40653);
var _NavigationIndependentTreeContext = __webpack_require__(68307);
var _NavigationRouteContext = __webpack_require__(50643);
var _jsxRuntime = __webpack_require__(7100);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Component to make the child navigation container independent of parent containers.
 */ function NavigationIndependentTree(ref) {
    var children = ref.children;
    return(/*#__PURE__*/ // We need to clear any existing contexts for nested independent container to work correctly
    (0, _jsxRuntime.jsx)(_NavigationRouteContext.NavigationRouteContext.Provider, {
        value: undefined,
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationContext.NavigationContext.Provider, {
            value: undefined,
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationIndependentTreeContext.NavigationIndependentTreeContext.Provider, {
                value: true,
                children: children
            })
        })
    }));
} //# sourceMappingURL=NavigationIndependentTree.js.map


}),
68307: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationIndependentTreeContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Context which marks the navigation tree as independent.
 */ var NavigationIndependentTreeContext = exports.NavigationIndependentTreeContext = /*#__PURE__*/ React.createContext(false); //# sourceMappingURL=NavigationIndependentTreeContext.js.map


}),
50643: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationRouteContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Context which holds the route prop for a screen.
 */ var NavigationRouteContext = exports.NavigationRouteContext = /*#__PURE__*/ React.createContext(undefined); //# sourceMappingURL=NavigationRouteContext.js.map


}),
26101: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationStateContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var MISSING_CONTEXT_ERROR = "Couldn't find a navigation context. Have you wrapped your app with 'NavigationContainer'? See https://reactnavigation.org/docs/getting-started for setup instructions.";
var NavigationStateContext = exports.NavigationStateContext = /*#__PURE__*/ React.createContext({
    isDefault: true,
    get getKey () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setKey () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getState () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setState () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get getIsInitial () {
        throw new Error(MISSING_CONTEXT_ERROR);
    }
}); //# sourceMappingURL=NavigationStateContext.js.map


}),
53119: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PreventRemoveContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * A type of an object that have a route key as an object key
 * and a value whether to prevent that route.
 */ var PreventRemoveContext = exports.PreventRemoveContext = /*#__PURE__*/ React.createContext(undefined); //# sourceMappingURL=PreventRemoveContext.js.map


}),
53284: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(17738);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PreventRemoveProvider = PreventRemoveProvider;
var _nonSecure = __webpack_require__(78803);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _useLatestCallback = _interopRequireDefault(__webpack_require__(34467));
var _NavigationHelpersContext = __webpack_require__(12800);
var _NavigationRouteContext = __webpack_require__(50643);
var _PreventRemoveContext = __webpack_require__(53119);
var _jsxRuntime = __webpack_require__(7100);
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Util function to transform map of prevented routes to a simpler object.
 */ var transformPreventedRoutes = (preventedRoutesMap)=>{
    var preventedRoutesToTransform = _to_consumable_array._(preventedRoutesMap.values());
    var preventedRoutes = preventedRoutesToTransform.reduce((acc, ref)=>{
        var routeKey = ref.routeKey, preventRemove = ref.preventRemove;
        var _acc_routeKey;
        acc[routeKey] = {
            preventRemove: ((_acc_routeKey = acc[routeKey]) === null || _acc_routeKey === void 0 ? void 0 : _acc_routeKey.preventRemove) || preventRemove
        };
        return acc;
    }, {});
    return preventedRoutes;
};
/**
 * Component used for managing which routes have to be prevented from removal in native-stack.
 */ function PreventRemoveProvider(ref) {
    var children = ref.children;
    var _React_useState = _sliced_to_array._(React.useState(()=>(0, _nonSecure.nanoid)()), 1), parentId = _React_useState[0];
    var _React_useState1 = _sliced_to_array._(React.useState(new Map()), 2), preventedRoutesMap = _React_useState1[0], setPreventedRoutesMap = _React_useState1[1];
    var navigation = React.useContext(_NavigationHelpersContext.NavigationHelpersContext);
    var route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    var preventRemoveContextValue = React.useContext(_PreventRemoveContext.PreventRemoveContext);
    // take `setPreventRemove` from parent context - if exist it means we're in a nested context
    var setParentPrevented = preventRemoveContextValue === null || preventRemoveContextValue === void 0 ? void 0 : preventRemoveContextValue.setPreventRemove;
    var setPreventRemove = (0, _useLatestCallback.default)((id, routeKey, preventRemove)=>{
        if (preventRemove && (navigation == null || (navigation === null || navigation === void 0 ? void 0 : navigation.getState().routes.every((route)=>route.key !== routeKey)))) {
            throw new Error(`Couldn't find a route with the key ${routeKey}. Is your component inside NavigationContent?`);
        }
        setPreventedRoutesMap((prevPrevented)=>{
            var _prevPrevented_get, _prevPrevented_get1;
            // values haven't changed - do nothing
            if (routeKey === ((_prevPrevented_get = prevPrevented.get(id)) === null || _prevPrevented_get === void 0 ? void 0 : _prevPrevented_get.routeKey) && preventRemove === ((_prevPrevented_get1 = prevPrevented.get(id)) === null || _prevPrevented_get1 === void 0 ? void 0 : _prevPrevented_get1.preventRemove)) {
                return prevPrevented;
            }
            var nextPrevented = new Map(prevPrevented);
            if (preventRemove) {
                nextPrevented.set(id, {
                    routeKey,
                    preventRemove
                });
            } else {
                nextPrevented.delete(id);
            }
            return nextPrevented;
        });
    });
    var isPrevented = _to_consumable_array._(preventedRoutesMap.values()).some((ref)=>{
        var preventRemove = ref.preventRemove;
        return preventRemove;
    });
    React.useEffect(()=>{
        if ((route === null || route === void 0 ? void 0 : route.key) !== undefined && setParentPrevented !== undefined) {
            // when route is defined (and setParentPrevented) it means we're in a nested stack
            // route.key then will be the route key of parent
            setParentPrevented(parentId, route.key, isPrevented);
            return ()=>{
                setParentPrevented(parentId, route.key, false);
            };
        }
        return;
    }, [
        parentId,
        isPrevented,
        route === null || route === void 0 ? void 0 : route.key,
        setParentPrevented
    ]);
    var value = React.useMemo(()=>({
            setPreventRemove,
            preventedRoutes: transformPreventedRoutes(preventedRoutesMap)
        }), [
        setPreventRemove,
        preventedRoutesMap
    ]);
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_PreventRemoveContext.PreventRemoveContext.Provider, {
        value: value,
        children: children
    });
} //# sourceMappingURL=PreventRemoveProvider.js.map


}),
6739: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _object_without_properties = __webpack_require__(45922);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SceneView = SceneView;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _EnsureSingleNavigator = __webpack_require__(37594);
var _NavigationStateContext = __webpack_require__(26101);
var _StaticContainer = __webpack_require__(72271);
var _useOptionsGetters = __webpack_require__(17222);
var _jsxRuntime = __webpack_require__(7100);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Component which takes care of rendering the screen for a route.
 * It provides all required contexts and applies optimizations when applicable.
 */ function SceneView(ref) {
    var screen = ref.screen, route = ref.route, navigation = ref.navigation, routeState = ref.routeState, getState = ref.getState, setState = ref.setState, options = ref.options, clearOptions = ref.clearOptions;
    var navigatorKeyRef = React.useRef();
    var getKey = React.useCallback(()=>navigatorKeyRef.current, []);
    var addOptionsGetter = (0, _useOptionsGetters.useOptionsGetters)({
        key: route.key,
        options,
        navigation
    }).addOptionsGetter;
    var setKey = React.useCallback((key)=>{
        navigatorKeyRef.current = key;
    }, []);
    var getCurrentState = React.useCallback(()=>{
        var state = getState();
        var currentRoute = state.routes.find((r)=>r.key === route.key);
        return currentRoute ? currentRoute.state : undefined;
    }, [
        getState,
        route.key
    ]);
    var setCurrentState = React.useCallback((child)=>{
        var state = getState();
        setState(_object_spread_props._(_object_spread._({}, state), {
            routes: state.routes.map((r)=>{
                if (r.key !== route.key) {
                    return r;
                }
                var nextRoute = _object_spread_props._(_object_spread._({}, r), {
                    state: child
                });
                // Before updating the state, cleanup any nested screen and state
                // This will avoid the navigator trying to handle them again
                if (nextRoute.params && ('state' in nextRoute.params && typeof nextRoute.params.state === 'object' && nextRoute.params.state !== null || 'screen' in nextRoute.params && typeof nextRoute.params.screen === 'string')) {
                    // @ts-expect-error: we don't have correct type for params
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    var _nextRoute_params = nextRoute.params, state = _nextRoute_params.state, screen = _nextRoute_params.screen, params = _nextRoute_params.params, initial = _nextRoute_params.initial, rest = _object_without_properties._(_nextRoute_params, [
                        "state",
                        "screen",
                        "params",
                        "initial"
                    ]);
                    if (Object.keys(rest).length) {
                        nextRoute.params = rest;
                    } else {
                        delete nextRoute.params;
                    }
                }
                return nextRoute;
            })
        }));
    }, [
        getState,
        route.key,
        setState
    ]);
    var isInitialRef = React.useRef(true);
    React.useEffect(()=>{
        isInitialRef.current = false;
    });
    // Clear options set by this screen when it is unmounted
    React.useEffect(()=>{
        return clearOptions;
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    var getIsInitial = React.useCallback(()=>isInitialRef.current, []);
    var context = React.useMemo(()=>({
            state: routeState,
            getState: getCurrentState,
            setState: setCurrentState,
            getKey,
            setKey,
            getIsInitial,
            addOptionsGetter
        }), [
        routeState,
        getCurrentState,
        setCurrentState,
        getKey,
        setKey,
        getIsInitial,
        addOptionsGetter
    ]);
    var ScreenComponent = screen.getComponent ? screen.getComponent() : screen.component;
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationStateContext.NavigationStateContext.Provider, {
        value: context,
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_EnsureSingleNavigator.EnsureSingleNavigator, {
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_StaticContainer.StaticContainer, {
                name: screen.name,
                render: ScreenComponent || screen.children,
                navigation: navigation,
                route: route,
                children: ScreenComponent !== undefined ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(ScreenComponent, {
                    navigation: navigation,
                    route: route
                }) : screen.children !== undefined ? screen.children({
                    navigation,
                    route
                }) : null
            })
        })
    });
} //# sourceMappingURL=SceneView.js.map


}),
17293: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Screen = Screen;
/**
 * Empty component used for specifying route configuration.
 */ function Screen(_) {
    /* istanbul ignore next */ return null;
} //# sourceMappingURL=Screen.js.map


}),
72271: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.StaticContainer = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Component which prevents updates for children if no props changed
 */ var StaticContainer = exports.StaticContainer = /*#__PURE__*/ React.memo(function StaticContainer(props) {
    return props.children;
}, (prevProps, nextProps)=>{
    var prevPropKeys = Object.keys(prevProps);
    var nextPropKeys = Object.keys(nextProps);
    if (prevPropKeys.length !== nextPropKeys.length) {
        return false;
    }
    for (var key of prevPropKeys){
        if (key === 'children') {
            continue;
        }
        if (prevProps[key] !== nextProps[key]) {
            return false;
        }
    }
    return true;
}); //# sourceMappingURL=StaticContainer.js.map


}),
52558: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _object_without_properties = __webpack_require__(45922);
var _sliced_to_array = __webpack_require__(17738);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createComponentForStaticNavigation = createComponentForStaticNavigation;
exports.createPathConfigForStaticNavigation = createPathConfigForStaticNavigation;
var _react = _interopRequireWildcard(__webpack_require__(92888));
var React = _react;
var _reactIs = __webpack_require__(55526);
var _useRoute = __webpack_require__(62865);
var _jsxRuntime = __webpack_require__(7100);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Flatten a type to remove all type alias names, unions etc.
 * This will show a plain object when hovering over the type.
 */ /**
 * keyof T doesn't work for union types. We can use distributive conditional types instead.
 * https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types
 */ /**
 * We get a union type when using keyof, but we want an intersection instead.
 * https://stackoverflow.com/a/50375286/1665026
 */ /**
 * Props for a screen component which is rendered by a static navigator.
 * Takes the route params as a generic argument.
 */ /**
 * Infer the param list from the static navigation config.
 */ var MemoizedScreen = /*#__PURE__*/ React.memo((ref)=>{
    var component = ref.component;
    var route = (0, _useRoute.useRoute)();
    var children = /*#__PURE__*/ React.createElement(component, {
        route
    });
    return children;
});
MemoizedScreen.displayName = 'Memo(Screen)';
var getItemsFromScreens = (Screen, screens)=>{
    return Object.entries(screens).map((ref)=>{
        var _ref = _sliced_to_array._(ref, 2), name = _ref[0], item = _ref[1];
        var component;
        var props = {};
        var useIf;
        var isNavigator = false;
        if ('screen' in item) {
            var screen = item.screen, _if = item.if, rest = _object_without_properties._(item, [
                "screen",
                "if"
            ]);
            useIf = _if;
            props = rest;
            if ((0, _reactIs.isValidElementType)(screen)) {
                component = screen;
            } else if ('config' in screen) {
                isNavigator = true;
                component = createComponentForStaticNavigation(screen, `${name}Navigator`);
            }
        } else if ((0, _reactIs.isValidElementType)(item)) {
            component = item;
        } else if ('config' in item) {
            isNavigator = true;
            component = createComponentForStaticNavigation(item, `${name}Navigator`);
        }
        if (component == null) {
            throw new Error(`Couldn't find a 'screen' property for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`);
        }
        var element = isNavigator ? /*#__PURE__*/ React.createElement(component, {}) : /*#__PURE__*/ (0, _jsxRuntime.jsx)(MemoizedScreen, {
            component: component
        });
        return ()=>{
            var shouldRender = useIf == null || useIf();
            if (!shouldRender) {
                return null;
            }
            return /*#__PURE__*/ (0, _jsxRuntime.jsx)(Screen, _object_spread_props._(_object_spread._({
                name: name
            }, props), {
                children: ()=>element
            }), name);
        };
    });
};
/**
 * Create a component that renders a navigator based on the static configuration.
 *
 * @param tree Static navigation config.
 * @param displayName Name of the component to be displayed in React DevTools.
 * @returns A component which renders the navigator.
 */ function createComponentForStaticNavigation(tree, displayName) {
    var Navigator = tree.Navigator, Group = tree.Group, Screen = tree.Screen, config = tree.config;
    var screens = config.screens, groups = config.groups, rest = _object_without_properties._(config, [
        "screens",
        "groups"
    ]);
    if (screens == null && groups == null) {
        throw new Error("Couldn't find a 'screens' or 'groups' property. Make sure to define your screens under a 'screens' property in the configuration.");
    }
    var items = [];
    // Loop through the config to find screens and groups
    // So we add the screens and groups in the same order as they are defined
    for(var _ref in config){
        var key = _ref;
        if (key === 'screens' && screens) {
            var _items;
            (_items = items).push.apply(_items, _to_consumable_array._(getItemsFromScreens(Screen, screens)));
        }
        if (key === 'groups' && groups) {
            var _items1;
            (_items1 = items).push.apply(_items1, _to_consumable_array._(Object.entries(groups).map((_param)=>{
                var _$_param = _sliced_to_array._(_param, 2), key = _$_param[0], _param_ = _$_param[1], useIf = _param_.if, group = _object_without_properties._(_param[1], [
                    "if"
                ]);
                var groupItems = getItemsFromScreens(Screen, group.screens);
                return ()=>{
                    // Call unconditionally since screen configs may contain `useIf` hooks
                    var children = groupItems.map((item)=>item());
                    var shouldRender = useIf == null || useIf();
                    if (!shouldRender) {
                        return null;
                    }
                    return /*#__PURE__*/ (0, _react.createElement)(Group, _object_spread_props._(_object_spread._({
                        navigationKey: key
                    }, group), {
                        key: key
                    }), children);
                };
            })));
        }
    }
    var NavigatorComponent = ()=>{
        var children = items.map((item)=>item());
        return /*#__PURE__*/ (0, _jsxRuntime.jsx)(Navigator, _object_spread_props._(_object_spread._({}, rest), {
            children: children
        }));
    };
    NavigatorComponent.displayName = displayName;
    return NavigatorComponent;
}
/**
 * Create a path config object from a static navigation config for deep linking.
 *
 * @param tree Static navigation config.
 * @param options Additional options from `linking.config`.
 * @param auto Whether to automatically generate paths for leaf screens.
 * @returns Path config object to use in linking config.
 *
 * @example
 * ```js
 * const config = {
 *   screens: {
 *     Home: {
 *       screens: createPathConfigForStaticNavigation(HomeTabs),
 *     },
 *   },
 * };
 * ```
 */ function createPathConfigForStaticNavigation(tree, options, auto) {
    var initialScreenConfig;
    var createPathConfigForTree = (t, o, skipInitialDetection)=>{
        var createPathConfigForScreens = (screens, initialRouteName)=>{
            return Object.fromEntries(Object.entries(screens)// Re-order to move the initial route to the front
            // This way we can detect the initial route correctly
            .sort((ref, ref1)=>{
                var _ref = _sliced_to_array._(ref, 1), a = _ref[0], _ref1 = _sliced_to_array._(ref1, 1), b = _ref1[0];
                if (a === initialRouteName) {
                    return -1;
                }
                if (b === initialRouteName) {
                    return 1;
                }
                return 0;
            }).map((ref)=>{
                var _ref = _sliced_to_array._(ref, 2), key = _ref[0], item = _ref[1];
                var screenConfig = {};
                if ('linking' in item) {
                    if (typeof item.linking === 'string') {
                        screenConfig.path = item.linking;
                    } else {
                        Object.assign(screenConfig, item.linking);
                    }
                    if (typeof screenConfig.path === 'string') {
                        screenConfig.path = screenConfig.path.replace(/^\//, '') // Remove extra leading slash
                        .replace(/\/$/, ''); // Remove extra trailing slash
                    }
                }
                var _$screens;
                var skipInitialDetectionInChild = skipInitialDetection || screenConfig.path != null && screenConfig.path !== '';
                if ('config' in item) {
                    _$screens = createPathConfigForTree(item, undefined, skipInitialDetectionInChild);
                } else if ('screen' in item && 'config' in item.screen && (item.screen.config.screens || item.screen.config.groups)) {
                    _$screens = createPathConfigForTree(item.screen, undefined, skipInitialDetectionInChild);
                }
                if (_$screens) {
                    screenConfig.screens = _$screens;
                }
                if (auto && !screenConfig.screens && // Skip generating path for screens that specify linking config as `undefined` or `null` explicitly
                !('linking' in item && item.linking == null)) {
                    if (screenConfig.path != null) {
                        if (!skipInitialDetection && screenConfig.path === '') {
                            // We encounter a leaf screen with empty path,
                            // Clear the initial screen config as it's not needed anymore
                            initialScreenConfig = undefined;
                        }
                    } else {
                        if (!skipInitialDetection && initialScreenConfig == null) {
                            initialScreenConfig = screenConfig;
                        }
                        screenConfig.path = key.replace(/([A-Z]+)/g, '-$1').replace(/^-/, '').toLowerCase();
                    }
                }
                return [
                    key,
                    screenConfig
                ];
            }).filter((ref)=>{
                var _ref = _sliced_to_array._(ref, 2), screen = _ref[1];
                return Object.keys(screen).length > 0;
            }));
        };
        var screens = {};
        // Loop through the config to find screens and groups
        // So we add the screens and groups in the same order as they are defined
        for(var key in t.config){
            if (key === 'screens' && t.config.screens) {
                Object.assign(screens, createPathConfigForScreens(t.config.screens, (o === null || o === void 0 ? void 0 : o.initialRouteName) ?? t.config.initialRouteName));
            }
            if (key === 'groups' && t.config.groups) {
                Object.entries(t.config.groups).forEach((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), group = _ref[1];
                    Object.assign(screens, createPathConfigForScreens(group.screens, (o === null || o === void 0 ? void 0 : o.initialRouteName) ?? t.config.initialRouteName));
                });
            }
        }
        if (Object.keys(screens).length === 0) {
            return undefined;
        }
        return screens;
    };
    var screens = createPathConfigForTree(tree, options, false);
    if (auto && initialScreenConfig) {
        initialScreenConfig.path = '';
    }
    return screens;
} //# sourceMappingURL=StaticNavigation.js.map


}),
38000: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UnhandledActionContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var UnhandledActionContext = exports.UnhandledActionContext = /*#__PURE__*/ React.createContext(undefined); //# sourceMappingURL=UnhandledActionContext.js.map


}),
68223: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.arrayStartsWith = arrayStartsWith;
/**
 * Compare two arrays to check if the first array starts with the second array.
 */ function arrayStartsWith(array, start) {
    if (start.length > array.length) {
        return false;
    }
    return start.every((it, index)=>it === array[index]);
} //# sourceMappingURL=arrayStartsWith.js.map


}),
30464: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.checkDuplicateRouteNames = checkDuplicateRouteNames;
function checkDuplicateRouteNames(state) {
    var duplicates = [];
    var getRouteNames = (location, state)=>{
        state.routes.forEach((route)=>{
            var _route_state_routeNames, _route_state;
            var currentLocation = location ? `${location} > ${route.name}` : route.name;
            (_route_state = route.state) === null || _route_state === void 0 ? void 0 : (_route_state_routeNames = _route_state.routeNames) === null || _route_state_routeNames === void 0 ? void 0 : _route_state_routeNames.forEach((routeName)=>{
                if (routeName === route.name) {
                    duplicates.push([
                        currentLocation,
                        `${currentLocation} > ${route.name}`
                    ]);
                }
            });
            if (route.state) {
                getRouteNames(currentLocation, route.state);
            }
        });
    };
    getRouteNames('', state);
    return duplicates;
} //# sourceMappingURL=checkDuplicateRouteNames.js.map


}),
79470: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.checkSerializable = checkSerializable;
var checkSerializableWithoutCircularReference = (o, seen, location)=>{
    if (o === undefined || o === null || typeof o === 'boolean' || typeof o === 'number' || typeof o === 'string') {
        return {
            serializable: true
        };
    }
    if (Object.prototype.toString.call(o) !== '[object Object]' && !Array.isArray(o)) {
        return {
            serializable: false,
            location,
            reason: typeof o === 'function' ? 'Function' : String(o)
        };
    }
    if (seen.has(o)) {
        return {
            serializable: false,
            reason: 'Circular reference',
            location
        };
    }
    seen.add(o);
    if (Array.isArray(o)) {
        for(var i = 0; i < o.length; i++){
            var childResult = checkSerializableWithoutCircularReference(o[i], new Set(seen), _to_consumable_array._(location).concat([
                i
            ]));
            if (!childResult.serializable) {
                return childResult;
            }
        }
    } else {
        for(var key in o){
            var childResult1 = checkSerializableWithoutCircularReference(o[key], new Set(seen), _to_consumable_array._(location).concat([
                key
            ]));
            if (!childResult1.serializable) {
                return childResult1;
            }
        }
    }
    return {
        serializable: true
    };
};
function checkSerializable(o) {
    return checkSerializableWithoutCircularReference(o, new Set(), []);
} //# sourceMappingURL=checkSerializable.js.map


}),
83700: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _sliced_to_array = __webpack_require__(17738);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NOT_INITIALIZED_ERROR = void 0;
exports.createNavigationContainerRef = createNavigationContainerRef;
var _routers = __webpack_require__(38686);
var NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = "The 'navigation' object hasn't been initialized yet. This might happen if you don't have a navigator mounted, or if the navigator hasn't finished mounting. See https://reactnavigation.org/docs/navigating-without-navigation-prop#handling-initialization for more details.";
function createNavigationContainerRef() {
    var methods = _to_consumable_array._(Object.keys(_routers.CommonActions)).concat([
        'addListener',
        'removeListener',
        'resetRoot',
        'dispatch',
        'isFocused',
        'canGoBack',
        'getRootState',
        'getState',
        'getParent',
        'getCurrentRoute',
        'getCurrentOptions'
    ]);
    var listeners = {};
    var removeListener = (event, callback)=>{
        if (listeners[event]) {
            listeners[event] = listeners[event].filter((cb)=>cb !== callback);
        }
    };
    var current = null;
    var ref = _object_spread._({
        get current () {
            return current;
        },
        set current (value){
            current = value;
            if (value != null) {
                Object.entries(listeners).forEach((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), event = _ref[0], callbacks = _ref[1];
                    callbacks.forEach((callback)=>{
                        value.addListener(event, callback);
                    });
                });
            }
        },
        isReady: ()=>{
            if (current == null) {
                return false;
            }
            return current.isReady();
        }
    }, methods.reduce((acc, name)=>{
        acc[name] = (...args)=>{
            if (current == null) {
                switch(name){
                    case 'addListener':
                        {
                            var _args = _sliced_to_array._(args, 2), event = _args[0], callback = _args[1];
                            listeners[event] = listeners[event] || [];
                            listeners[event].push(callback);
                            return ()=>removeListener(event, callback);
                        }
                    case 'removeListener':
                        {
                            var _args1 = _sliced_to_array._(args, 2), event1 = _args1[0], callback1 = _args1[1];
                            removeListener(event1, callback1);
                            break;
                        }
                    default:
                        console.error(NOT_INITIALIZED_ERROR);
                }
            } else {
                var _current;
                // @ts-expect-error: this is ok
                return (_current = current)[name].apply(_current, _to_consumable_array._(args));
            }
        };
        return acc;
    }, {}));
    return ref;
} //# sourceMappingURL=createNavigationContainerRef.js.map


}),
89339: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createNavigatorFactory = createNavigatorFactory;
var _Group = __webpack_require__(98963);
var _Screen = __webpack_require__(17293);
/**
 * Higher order component to create a `Navigator` and `Screen` pair.
 * Custom navigators should wrap the navigator component in `createNavigator` before exporting.
 *
 * @param Navigator The navigator component to wrap.
 * @returns Factory method to create a `Navigator` and `Screen` pair.
 */ function createNavigatorFactory(Navigator) {
    function createNavigator(config) {
        if (config != null) {
            return {
                Navigator,
                Screen: _Screen.Screen,
                Group: _Group.Group,
                config
            };
        }
        return {
            Navigator,
            Screen: _Screen.Screen,
            Group: _Group.Group
        };
    }
    return createNavigator;
} //# sourceMappingURL=createNavigatorFactory.js.map


}),
54303: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isPlainObject = exports.deepFreeze = void 0;
var isPlainObject = (value)=>{
    if (typeof value === 'object' && value !== null) {
        return Object.getPrototypeOf(value) === Object.prototype;
    }
    return false;
};
exports.isPlainObject = isPlainObject;
var deepFreeze = (object)=>{
    // We only freeze in development to catch issues early
    // Don't freeze in production to avoid unnecessary performance overhead
    if (true) {
        return object;
    }
    if (Object.isFrozen(object)) {
        return object;
    }
    if (!isPlainObject(object) && !Array.isArray(object)) {
        return object;
    }
    // Freeze properties before freezing self
    for(var key in object){
        var _Object_getOwnPropertyDescriptor;
        if ((_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(object, key)) === null || _Object_getOwnPropertyDescriptor === void 0 ? void 0 : _Object_getOwnPropertyDescriptor.configurable) {
            var value = object[key];
            deepFreeze(value);
        }
    }
    return Object.freeze(object);
};
exports.deepFreeze = deepFreeze; //# sourceMappingURL=deepFreeze.js.map


}),
85814: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.findFocusedRoute = findFocusedRoute;
function findFocusedRoute(state) {
    var current = state;
    while((current === null || current === void 0 ? void 0 : current.routes[current.index ?? 0].state) != null){
        current = current.routes[current.index ?? 0].state;
    }
    var route = current === null || current === void 0 ? void 0 : current.routes[(current === null || current === void 0 ? void 0 : current.index) ?? 0];
    return route;
} //# sourceMappingURL=findFocusedRoute.js.map


}),
50514: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _sliced_to_array = __webpack_require__(17738);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getActionFromState = getActionFromState;
function getActionFromState(state, options) {
    var _normalizedConfig_screens;
    // Create a normalized configs object which will be easier to use
    var normalizedConfig = options ? createNormalizedConfigItem(options) : {};
    var routes = state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;
    if (routes.length === 0) {
        return undefined;
    }
    if (!(routes.length === 1 && routes[0].key === undefined || routes.length === 2 && routes[0].key === undefined && routes[0].name === (normalizedConfig === null || normalizedConfig === void 0 ? void 0 : normalizedConfig.initialRouteName) && routes[1].key === undefined)) {
        return {
            type: 'RESET',
            payload: state
        };
    }
    var route = state.routes[state.index ?? state.routes.length - 1];
    var current = route === null || route === void 0 ? void 0 : route.state;
    var config = normalizedConfig === null || normalizedConfig === void 0 ? void 0 : (_normalizedConfig_screens = normalizedConfig.screens) === null || _normalizedConfig_screens === void 0 ? void 0 : _normalizedConfig_screens[route === null || route === void 0 ? void 0 : route.name];
    var params = _object_spread._({}, route.params);
    var payload = route ? {
        name: route.name,
        path: route.path,
        params
    } : undefined;
    while(current){
        var _config_screens;
        if (current.routes.length === 0) {
            return undefined;
        }
        var routes1 = current.index != null ? current.routes.slice(0, current.index + 1) : current.routes;
        var route1 = routes1[routes1.length - 1];
        // Explicitly set to override existing value when merging params
        Object.assign(params, {
            initial: undefined,
            screen: undefined,
            params: undefined,
            state: undefined
        });
        if (routes1.length === 1 && routes1[0].key === undefined) {
            params.initial = true;
            params.screen = route1.name;
        } else if (routes1.length === 2 && routes1[0].key === undefined && routes1[0].name === (config === null || config === void 0 ? void 0 : config.initialRouteName) && routes1[1].key === undefined) {
            params.initial = false;
            params.screen = route1.name;
        } else {
            params.state = current;
            break;
        }
        if (route1.state) {
            params.params = _object_spread._({}, route1.params);
            params = params.params;
        } else {
            params.path = route1.path;
            params.params = route1.params;
        }
        current = route1.state;
        config = config === null || config === void 0 ? void 0 : (_config_screens = config.screens) === null || _config_screens === void 0 ? void 0 : _config_screens[route1.name];
    }
    if (!payload) {
        return;
    }
    // Try to construct payload for a `NAVIGATE` action from the state
    // This lets us preserve the navigation state and not lose it
    return {
        type: 'NAVIGATE',
        payload
    };
}
var createNormalizedConfigItem = (config)=>typeof config === 'object' && config != null ? {
        initialRouteName: config.initialRouteName,
        screens: config.screens != null ? createNormalizedConfigs(config.screens) : undefined
    } : {};
var createNormalizedConfigs = (options)=>Object.entries(options).reduce((acc, ref)=>{
        var _ref = _sliced_to_array._(ref, 2), k = _ref[0], v = _ref[1];
        acc[k] = createNormalizedConfigItem(v);
        return acc;
    }, {}); //# sourceMappingURL=getActionFromState.js.map


}),
31963: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getFocusedRouteNameFromRoute = getFocusedRouteNameFromRoute;
var _useRouteCache = __webpack_require__(91516);
function getFocusedRouteNameFromRoute(route) {
    // @ts-expect-error: this isn't in type definitions coz we want this private
    var state = route[_useRouteCache.CHILD_STATE] ?? route.state;
    var params = route.params;
    var routeName = state ? // Get the currently active route name in the nested navigator
    state.routes[// If we have a partial state without index, for tab/drawer, first screen will be focused one, and last for stack
    // The type property will only exist for rehydrated state and not for state from deep link
    state.index ?? (typeof state.type === 'string' && state.type !== 'stack' ? 0 : state.routes.length - 1)].name : // If state doesn't exist, we need to default to `screen` param if available
    typeof (params === null || params === void 0 ? void 0 : params.screen) === 'string' ? params.screen : undefined;
    return routeName;
} //# sourceMappingURL=getFocusedRouteNameFromRoute.js.map


}),
61115: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _sliced_to_array = __webpack_require__(17738);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getPathFromState = getPathFromState;
var queryString = _interopRequireWildcard(__webpack_require__(85507));
var _getPatternParts = __webpack_require__(8619);
var _validatePathConfig = __webpack_require__(665);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var getActiveRoute = (state)=>{
    var route = typeof state.index === 'number' ? state.routes[state.index] : state.routes[state.routes.length - 1];
    if (route.state) {
        return getActiveRoute(route.state);
    }
    return route;
};
var cachedNormalizedConfigs = new WeakMap();
var getNormalizedConfigs = (options)=>{
    if (!(options === null || options === void 0 ? void 0 : options.screens)) return {};
    var cached = cachedNormalizedConfigs.get(options === null || options === void 0 ? void 0 : options.screens);
    if (cached) return cached;
    var normalizedConfigs = createNormalizedConfigs(options.screens);
    cachedNormalizedConfigs.set(options.screens, normalizedConfigs);
    return normalizedConfigs;
};
/**
 * Utility to serialize a navigation state object to a path string.
 *
 * @example
 * ```js
 * getPathFromState(
 *   {
 *     routes: [
 *       {
 *         name: 'Chat',
 *         params: { author: 'Jane', id: 42 },
 *       },
 *     ],
 *   },
 *   {
 *     screens: {
 *       Chat: {
 *         path: 'chat/:author/:id',
 *         stringify: { author: author => author.toLowerCase() }
 *       }
 *     }
 *   }
 * )
 * ```
 *
 * @param state Navigation state to serialize.
 * @param options Extra options to fine-tune how to serialize the path.
 * @returns Path representing the state, e.g. /foo/bar?count=42.
 */ function getPathFromState(state, options) {
    var _loop = function() {
        var _loop = function() {
            parts = currentOptions[route.name].parts;
            nestedRouteNames.push(route.name);
            if (route.params) {
                var _currentOptions_route_name;
                var stringify = (_currentOptions_route_name = currentOptions[route.name]) === null || _currentOptions_route_name === void 0 ? void 0 : _currentOptions_route_name.stringify;
                var currentParams = Object.fromEntries(Object.entries(route.params).map((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                    return [
                        key,
                        (stringify === null || stringify === void 0 ? void 0 : stringify[key]) ? stringify[key](value) : String(value)
                    ];
                }));
                if (parts === null || parts === void 0 ? void 0 : parts.length) {
                    Object.assign(allParams, currentParams);
                }
                if (focusedRoute === route) {
                    // If this is the focused route, keep the params for later use
                    // We save it here since it's been stringified already
                    focusedParams = _object_spread._({}, currentParams);
                    parts === null || parts === void 0 ? void 0 : parts.forEach((ref)=>{
                        var param = ref.param;
                        if (param) {
                            // Remove the params present in the pattern since we'll only use the rest for query string
                            if (focusedParams) {
                                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                                delete focusedParams[param];
                            }
                        }
                    });
                }
            }
            // If there is no `screens` property or no nested state, we return pattern
            if (!currentOptions[route.name].screens || route.state === undefined) {
                hasNext = false;
            } else {
                index = typeof route.state.index === 'number' ? route.state.index : route.state.routes.length - 1;
                var nextRoute = route.state.routes[index];
                var nestedConfig = currentOptions[route.name].screens;
                // if there is config for next route name, we go deeper
                if (nestedConfig && nextRoute.name in nestedConfig) {
                    route = nextRoute;
                    currentOptions = nestedConfig;
                } else {
                    // If not, there is no sense in going deeper in config
                    hasNext = false;
                }
            }
        };
        var index = typeof current.index === 'number' ? current.index : 0;
        var route = current.routes[index];
        var parts = void 0;
        var focusedParams = void 0;
        var currentOptions = configs;
        var focusedRoute = getActiveRoute(state);
        // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined
        var nestedRouteNames = [];
        var hasNext = true;
        while(route.name in currentOptions && hasNext)_loop();
        if (currentOptions[route.name] !== undefined) {
            path += parts === null || parts === void 0 ? void 0 : parts.map((ref)=>{
                var segment = ref.segment, param = ref.param, optional = ref.optional;
                // We don't know what to show for wildcard patterns
                // Showing the route name seems ok, though whatever we show here will be incorrect
                // Since the page doesn't actually exist
                if (segment === '*') {
                    return route.name;
                }
                // If the path has a pattern for a param, put the param in the path
                if (param) {
                    var value = allParams[param];
                    if (value === undefined && optional) {
                        // Optional params without value assigned in route.params should be ignored
                        return '';
                    }
                    // Valid characters according to
                    // https://datatracker.ietf.org/doc/html/rfc3986#section-3.3 (see pchar definition)
                    return String(value).replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]/g, (char)=>encodeURIComponent(char));
                }
                return encodeURIComponent(segment);
            }).join('/');
        } else {
            path += encodeURIComponent(route.name);
        }
        if (!focusedParams && focusedRoute.params) {
            focusedParams = Object.fromEntries(Object.entries(focusedRoute.params).map((ref)=>{
                var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                return [
                    key,
                    String(value)
                ];
            }));
        }
        if (route.state) {
            path += '/';
        } else if (focusedParams) {
            for(var param in focusedParams){
                if (focusedParams[param] === 'undefined') {
                    // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                    delete focusedParams[param];
                }
            }
            var query = queryString.stringify(focusedParams, {
                sort: false
            });
            if (query) {
                path += `?${query}`;
            }
        }
        current = route.state;
    };
    if (state == null) {
        throw Error(`Got '${String(state)}' for the navigation state. You must pass a valid state object.`);
    }
    if (options) {
        (0, _validatePathConfig.validatePathConfig)(options);
    }
    var configs = getNormalizedConfigs(options);
    var path = '/';
    var current = state;
    var allParams = {};
    while(current)_loop();
    // Include the root path if specified
    if (options === null || options === void 0 ? void 0 : options.path) {
        path = `${options.path}/${path}`;
    }
    // Remove multiple as well as trailing slashes
    path = path.replace(/\/+/g, '/');
    path = path.length > 1 ? path.replace(/\/$/, '') : path;
    // If path doesn't start with a slash, add it
    // This makes sure that history.pushState will update the path correctly instead of appending
    if (!path.startsWith('/')) {
        path = `/${path}`;
    }
    return path;
}
var createConfigItem = (config, parentParts)=>{
    if (typeof config === 'string') {
        // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern
        var parts = (0, _getPatternParts.getPatternParts)(config);
        if (parentParts) {
            return {
                parts: _to_consumable_array._(parentParts).concat(_to_consumable_array._(parts))
            };
        }
        return {
            parts
        };
    }
    if (config.exact && config.path === undefined) {
        throw new Error("A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.");
    }
    // If an object is specified as the value (e.g. Foo: { ... }),
    // It can have `path` property and `screens` prop which has nested configs
    var parts1 = config.exact !== true ? _to_consumable_array._(parentParts || []).concat(_to_consumable_array._(config.path ? (0, _getPatternParts.getPatternParts)(config.path) : [])) : config.path ? (0, _getPatternParts.getPatternParts)(config.path) : undefined;
    var screens = config.screens ? createNormalizedConfigs(config.screens, parts1) : undefined;
    return {
        parts: parts1,
        stringify: config.stringify,
        screens
    };
};
var createNormalizedConfigs = (options, parts)=>Object.fromEntries(Object.entries(options).map((ref)=>{
        var _ref = _sliced_to_array._(ref, 2), name = _ref[0], c = _ref[1];
        var result = createConfigItem(c, parts);
        return [
            name,
            result
        ];
    })); //# sourceMappingURL=getPathFromState.js.map


}),
8619: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(17738);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getPatternParts = getPatternParts;
/**
 * Parse a path into an array of parts with information about each segment.
 */ function getPatternParts(path) {
    var parts = [];
    var current = {
        segment: ''
    };
    var isRegex = false;
    var isParam = false;
    var regexInnerParens = 0;
    // One extra iteration to add the last character
    for(var i = 0; i <= path.length; i++){
        var char = path[i];
        if (char != null) {
            current.segment += char;
        }
        if (char === ':') {
            // The segment must start with a colon if it's a param
            if (current.segment === ':') {
                isParam = true;
            } else if (!isRegex) {
                throw new Error(`Encountered ':' in the middle of a segment in path: ${path}`);
            }
        } else if (char === '(') {
            if (isParam) {
                if (isRegex) {
                    // The '(' is part of the regex if we're already inside one
                    regexInnerParens++;
                } else {
                    isRegex = true;
                }
            } else {
                throw new Error(`Encountered '(' without preceding ':' in path: ${path}`);
            }
        } else if (char === ')') {
            if (isParam && isRegex) {
                if (regexInnerParens) {
                    // The ')' is part of the regex if we're already inside one
                    regexInnerParens--;
                    current.regex += char;
                } else {
                    isRegex = false;
                    isParam = false;
                }
            } else {
                throw new Error(`Encountered ')' without preceding '(' in path: ${path}`);
            }
        } else if (char === '?') {
            if (current.param) {
                isParam = false;
                current.optional = true;
            } else {
                throw new Error(`Encountered '?' without preceding ':' in path: ${path}`);
            }
        } else if (char == null || char === '/' && !isRegex) {
            isParam = false;
            // Remove trailing slash from segment
            current.segment = current.segment.replace(/\/$/, '');
            if (current.segment === '') {
                continue;
            }
            if (current.param) {
                current.param = current.param.replace(/^:/, '');
            }
            if (current.regex) {
                current.regex = current.regex.replace(/^\(/, '').replace(/\)$/, '');
            }
            parts.push(current);
            if (char == null) {
                break;
            }
            current = {
                segment: ''
            };
        }
        if (isRegex) {
            current.regex = current.regex || '';
            current.regex += char;
        }
        if (isParam && !isRegex) {
            current.param = current.param || '';
            current.param += char;
        }
    }
    if (isRegex) {
        throw new Error(`Could not find closing ')' in path: ${path}`);
    }
    var params = parts.map((part)=>part.param).filter(Boolean);
    for (var ref of params.entries()){
        var _ref = _sliced_to_array._(ref, 2), index = _ref[0], param = _ref[1];
        if (params.indexOf(param) !== index) {
            throw new Error(`Duplicate param name '${param}' found in path: ${path}`);
        }
    }
    return parts;
} //# sourceMappingURL=getPatternParts.js.map


}),
23651: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _sliced_to_array = __webpack_require__(17738);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getStateFromPath = getStateFromPath;
var _escapeStringRegexp = _interopRequireDefault(__webpack_require__(82063));
var queryString = _interopRequireWildcard(__webpack_require__(85507));
var _arrayStartsWith = __webpack_require__(68223);
var _findFocusedRoute = __webpack_require__(85814);
var _getPatternParts = __webpack_require__(8619);
var _isArrayEqual = __webpack_require__(6923);
var _validatePathConfig = __webpack_require__(665);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
/**
 * Utility to parse a path string to initial state object accepted by the container.
 * This is useful for deep linking when we need to handle the incoming URL.
 *
 * @example
 * ```js
 * getStateFromPath(
 *   '/chat/jane/42',
 *   {
 *     screens: {
 *       Chat: {
 *         path: 'chat/:author/:id',
 *         parse: { id: Number }
 *       }
 *     }
 *   }
 * )
 * ```
 * @param path Path string to parse and convert, e.g. /foo/bar?count=42.
 * @param options Extra options to fine-tune how to parse the path.
 */ function getStateFromPath(path, options) {
    var _options_path;
    var _getConfigResources = getConfigResources(options), initialRoutes = _getConfigResources.initialRoutes, configs = _getConfigResources.configs;
    var screens = options === null || options === void 0 ? void 0 : options.screens;
    var remaining = path.replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
    .replace(/^\//, '') // Remove extra leading slash
    .replace(/\?.*$/, ''); // Remove query params which we will handle later
    // Make sure there is a trailing slash
    remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;
    var prefix = options === null || options === void 0 ? void 0 : (_options_path = options.path) === null || _options_path === void 0 ? void 0 : _options_path.replace(/^\//, ''); // Remove extra leading slash
    if (prefix) {
        // Make sure there is a trailing slash
        var normalizedPrefix = prefix.endsWith('/') ? prefix : `${prefix}/`;
        // If the path doesn't start with the prefix, it's not a match
        if (!remaining.startsWith(normalizedPrefix)) {
            return undefined;
        }
        // Remove the prefix from the path
        remaining = remaining.replace(normalizedPrefix, '');
    }
    if (screens === undefined) {
        // When no config is specified, use the path segments as route names
        var routes = remaining.split('/').filter(Boolean).map((segment)=>{
            var name = decodeURIComponent(segment);
            return {
                name
            };
        });
        if (routes.length) {
            return createNestedStateObject(path, routes, initialRoutes);
        }
        return undefined;
    }
    if (remaining === '/') {
        // We need to add special handling of empty path so navigation to empty path also works
        // When handling empty path, we should only look at the root level config
        var match = configs.find((config)=>config.segments.join('/') === '');
        if (match) {
            return createNestedStateObject(path, match.routeNames.map((name)=>({
                    name
                })), initialRoutes, configs);
        }
        return undefined;
    }
    var result;
    var current;
    // We match the whole path against the regex instead of segments
    // This makes sure matches such as wildcard will catch any unmatched routes, even if nested
    var _matchAgainstConfigs = matchAgainstConfigs(remaining, configs), routes1 = _matchAgainstConfigs.routes, remainingPath = _matchAgainstConfigs.remainingPath;
    if (routes1 !== undefined) {
        // This will always be empty if full path matched
        current = createNestedStateObject(path, routes1, initialRoutes, configs);
        remaining = remainingPath;
        result = current;
    }
    if (current == null || result == null) {
        return undefined;
    }
    return result;
}
/**
 * Reference to the last used config resources. This is used to avoid recomputing the config resources when the options are the same.
 */ var cachedConfigResources = new WeakMap();
function getConfigResources(options) {
    if (!options) return prepareConfigResources();
    var cached = cachedConfigResources.get(options);
    if (cached) return cached;
    var resources = prepareConfigResources(options);
    cachedConfigResources.set(options, resources);
    return resources;
}
function prepareConfigResources(options) {
    if (options) {
        (0, _validatePathConfig.validatePathConfig)(options);
    }
    var initialRoutes = getInitialRoutes(options);
    var configs = getSortedNormalizedConfigs(initialRoutes, options === null || options === void 0 ? void 0 : options.screens);
    checkForDuplicatedConfigs(configs);
    var configWithRegexes = getConfigsWithRegexes(configs);
    return {
        initialRoutes,
        configs,
        configWithRegexes
    };
}
function getInitialRoutes(options) {
    var initialRoutes = [];
    if (options === null || options === void 0 ? void 0 : options.initialRouteName) {
        initialRoutes.push({
            initialRouteName: options.initialRouteName,
            parentScreens: []
        });
    }
    return initialRoutes;
}
function getSortedNormalizedConfigs(initialRoutes, ref) {
    var screens = ref === void 0 ? {} : ref;
    var _instance;
    // Create a normalized configs array which will be easier to use
    return (_instance = []).concat.apply(_instance, _to_consumable_array._(Object.keys(screens).map((key)=>createNormalizedConfigs(key, screens, initialRoutes, [], [], [])))).sort((a, b)=>{
        // Sort config from most specific to least specific:
        // - more segments
        // - static segments
        // - params with regex
        // - regular params
        // - wildcard
        // If 2 patterns are same, move the one with less route names up
        // This is an error state, so it's only useful for consistent error messages
        if ((0, _isArrayEqual.isArrayEqual)(a.segments, b.segments)) {
            return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));
        }
        // If one of the patterns starts with the other, it's more exhaustive
        // So move it up
        if ((0, _arrayStartsWith.arrayStartsWith)(a.segments, b.segments)) {
            return -1;
        }
        if ((0, _arrayStartsWith.arrayStartsWith)(b.segments, a.segments)) {
            return 1;
        }
        for(var i = 0; i < Math.max(a.segments.length, b.segments.length); i++){
            // if b is longer, b gets higher priority
            if (a.segments[i] == null) {
                return 1;
            }
            // if a is longer, a gets higher priority
            if (b.segments[i] == null) {
                return -1;
            }
            var aWildCard = a.segments[i] === '*';
            var bWildCard = b.segments[i] === '*';
            var aParam = a.segments[i].startsWith(':');
            var bParam = b.segments[i].startsWith(':');
            var aRegex = aParam && a.segments[i].includes('(');
            var bRegex = bParam && b.segments[i].includes('(');
            // if both are wildcard or regex, we compare next component
            if (aWildCard && bWildCard || aRegex && bRegex) {
                continue;
            }
            // if only a is wildcard, b gets higher priority
            if (aWildCard && !bWildCard) {
                return 1;
            }
            // if only b is wildcard, a gets higher priority
            if (bWildCard && !aWildCard) {
                return -1;
            }
            // If only a has a param, b gets higher priority
            if (aParam && !bParam) {
                return 1;
            }
            // If only b has a param, a gets higher priority
            if (bParam && !aParam) {
                return -1;
            }
            // if only a has regex, a gets higher priority
            if (aRegex && !bRegex) {
                return -1;
            }
            // if only b has regex, b gets higher priority
            if (bRegex && !aRegex) {
                return 1;
            }
        }
        return a.segments.length - b.segments.length;
    });
}
function checkForDuplicatedConfigs(configs) {
    // Check for duplicate patterns in the config
    configs.reduce((acc, config)=>{
        var pattern = config.segments.join('/');
        if (acc[pattern]) {
            var a = acc[pattern].routeNames;
            var b = config.routeNames;
            // It's not a problem if the path string omitted from a inner most screen
            // For example, it's ok if a path resolves to `A > B > C` or `A > B`
            var intersects = a.length > b.length ? b.every((it, i)=>a[i] === it) : a.every((it, i)=>b[i] === it);
            if (!intersects) {
                throw new Error(`Found conflicting screens with the same pattern. The pattern '${pattern}' resolves to both '${a.join(' > ')}' and '${b.join(' > ')}'. Patterns must be unique and cannot resolve to more than one screen.`);
            }
        }
        return Object.assign(acc, {
            [pattern]: config
        });
    }, {});
}
function getConfigsWithRegexes(configs) {
    return configs.map((c)=>_object_spread_props._(_object_spread._({}, c), {
            // Add `$` to the regex to make sure it matches till end of the path and not just beginning
            regex: c.regex ? new RegExp(c.regex.source + '$') : undefined
        }));
}
var matchAgainstConfigs = (remaining, configs)=>{
    var _loop = function(config) {
        if (!config.regex) {
            return "continue";
        }
        var match = remainingPath.match(config.regex);
        // If our regex matches, we need to extract params from the path
        if (match) {
            routes = config.routeNames.map((routeName)=>{
                var routeConfig = configs.find((c)=>{
                    // Check matching name AND pattern in case same screen is used at different levels in config
                    return c.screen === routeName && (0, _arrayStartsWith.arrayStartsWith)(config.segments, c.segments);
                });
                var params = routeConfig && match.groups ? Object.fromEntries(Object.entries(match.groups).map((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                    var index = Number(key.replace('param_', ''));
                    var param = routeConfig.params.find((it)=>it.index === index);
                    if ((param === null || param === void 0 ? void 0 : param.screen) === routeName && (param === null || param === void 0 ? void 0 : param.name)) {
                        return [
                            param.name,
                            value
                        ];
                    }
                    return null;
                }).filter((it)=>it != null).map((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                    var _routeConfig_parse;
                    if (value == null) {
                        return [
                            key,
                            undefined
                        ];
                    }
                    var decoded = decodeURIComponent(value);
                    var parsed = ((_routeConfig_parse = routeConfig.parse) === null || _routeConfig_parse === void 0 ? void 0 : _routeConfig_parse[key]) ? routeConfig.parse[key](decoded) : decoded;
                    return [
                        key,
                        parsed
                    ];
                })) : undefined;
                if (params && Object.keys(params).length) {
                    return {
                        name: routeName,
                        params
                    };
                }
                return {
                    name: routeName
                };
            });
            remainingPath = remainingPath.replace(match[0], '');
            return "break";
        }
    };
    var routes;
    var remainingPath = remaining;
    // Go through all configs, and see if the next path segment matches our regex
    for (var config of configs){
        var _ret = _loop(config);
        if (_ret === "break") break;
    }
    return {
        routes,
        remainingPath
    };
};
var createNormalizedConfigs = (screen, routeConfig, initials, paths, parentScreens, routeNames)=>{
    var configs = [];
    routeNames.push(screen);
    parentScreens.push(screen);
    var config = routeConfig[screen];
    if (typeof config === 'string') {
        paths.push({
            screen,
            path: config
        });
        configs.push(createConfigItem(screen, _to_consumable_array._(routeNames), _to_consumable_array._(paths)));
    } else if (typeof config === 'object') {
        var _config_alias;
        // if an object is specified as the value (e.g. Foo: { ... }),
        // it can have `path` property and
        // it could have `screens` prop which has nested configs
        if (typeof config.path === 'string') {
            var _configs;
            if (config.exact && config.path == null) {
                throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. \`path: ''\`.`);
            }
            // We should add alias configs after the main config
            // So unless they are more specific, main config will be matched first
            var aliasConfigs = [];
            if (config.alias) {
                for (var alias of config.alias){
                    if (typeof alias === 'string') {
                        aliasConfigs.push(createConfigItem(screen, _to_consumable_array._(routeNames), _to_consumable_array._(paths).concat([
                            {
                                screen,
                                path: alias
                            }
                        ]), config.parse));
                    } else if (typeof alias === 'object') {
                        aliasConfigs.push(createConfigItem(screen, _to_consumable_array._(routeNames), alias.exact ? [
                            {
                                screen,
                                path: alias.path
                            }
                        ] : _to_consumable_array._(paths).concat([
                            {
                                screen,
                                path: alias.path
                            }
                        ]), alias.parse));
                    }
                }
            }
            if (config.exact) {
                // If it's an exact path, we don't need to keep track of the parent screens
                // So we can clear it
                paths.length = 0;
            }
            paths.push({
                screen,
                path: config.path
            });
            configs.push(createConfigItem(screen, _to_consumable_array._(routeNames), _to_consumable_array._(paths), config.parse));
            (_configs = configs).push.apply(_configs, _to_consumable_array._(aliasConfigs));
        }
        if (typeof config !== 'string' && typeof config.path !== 'string' && ((_config_alias = config.alias) === null || _config_alias === void 0 ? void 0 : _config_alias.length)) {
            throw new Error(`Screen '${screen}' doesn't specify a 'path'. A 'path' needs to be specified in order to use 'alias'.`);
        }
        if (config.screens) {
            // property `initialRouteName` without `screens` has no purpose
            if (config.initialRouteName) {
                initials.push({
                    initialRouteName: config.initialRouteName,
                    parentScreens
                });
            }
            Object.keys(config.screens).forEach((nestedConfig)=>{
                var _configs;
                var result = createNormalizedConfigs(nestedConfig, config.screens, initials, _to_consumable_array._(paths), _to_consumable_array._(parentScreens), routeNames);
                (_configs = configs).push.apply(_configs, _to_consumable_array._(result));
            });
        }
    }
    routeNames.pop();
    return configs;
};
var createConfigItem = (screen, routeNames, paths, parse)=>{
    var _loop = function(ref) {
        var _$screen = ref.screen, path = ref.path;
        var _parts;
        (_parts = parts).push.apply(_parts, _to_consumable_array._((0, _getPatternParts.getPatternParts)(path).map((part)=>_object_spread_props._(_object_spread._({}, part), {
                screen: _$screen
            }))));
    };
    var parts = [];
    // Parse the path string into parts for easier matching
    for (var ref of paths)_loop(ref);
    var regex = parts.length ? new RegExp(`^(${parts.map((it, i)=>{
        if (it.param) {
            var reg = it.regex || '[^/]+';
            return `(((?<param_${i}>${reg})\\/)${it.optional ? '?' : ''})`;
        }
        return `${it.segment === '*' ? '.*' : (0, _escapeStringRegexp.default)(it.segment)}\\/`;
    }).join('')})$`) : undefined;
    var segments = parts.map((it)=>it.segment);
    var params = parts.map((it, i)=>it.param ? {
            index: i,
            screen: it.screen,
            name: it.param
        } : null).filter((it)=>it != null);
    return {
        screen,
        regex,
        segments,
        params,
        routeNames,
        parse
    };
};
var findParseConfigForRoute = (routeName, flatConfig)=>{
    for (var config of flatConfig){
        if (routeName === config.routeNames[config.routeNames.length - 1]) {
            return config.parse;
        }
    }
    return undefined;
};
// Try to find an initial route connected with the one passed
var findInitialRoute = (routeName, parentScreens, initialRoutes)=>{
    for (var config of initialRoutes){
        if (parentScreens.length === config.parentScreens.length) {
            var sameParents = true;
            for(var i = 0; i < parentScreens.length; i++){
                if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {
                    sameParents = false;
                    break;
                }
            }
            if (sameParents) {
                return routeName !== config.initialRouteName ? config.initialRouteName : undefined;
            }
        }
    }
    return undefined;
};
// returns state object with values depending on whether
// it is the end of state and if there is initialRoute for this level
var createStateObject = (initialRoute, route, isEmpty)=>{
    if (isEmpty) {
        if (initialRoute) {
            return {
                index: 1,
                routes: [
                    {
                        name: initialRoute
                    },
                    route
                ]
            };
        } else {
            return {
                routes: [
                    route
                ]
            };
        }
    } else {
        if (initialRoute) {
            return {
                index: 1,
                routes: [
                    {
                        name: initialRoute
                    },
                    _object_spread_props._(_object_spread._({}, route), {
                        state: {
                            routes: []
                        }
                    })
                ]
            };
        } else {
            return {
                routes: [
                    _object_spread_props._(_object_spread._({}, route), {
                        state: {
                            routes: []
                        }
                    })
                ]
            };
        }
    }
};
var createNestedStateObject = (path, routes, initialRoutes, flatConfig)=>{
    var route = routes.shift();
    var parentScreens = [];
    var initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
    parentScreens.push(route.name);
    var state = createStateObject(initialRoute, route, routes.length === 0);
    if (routes.length > 0) {
        var nestedState = state;
        while(route = routes.shift()){
            initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);
            var nestedStateIndex = nestedState.index || nestedState.routes.length - 1;
            nestedState.routes[nestedStateIndex].state = createStateObject(initialRoute, route, routes.length === 0);
            if (routes.length > 0) {
                nestedState = nestedState.routes[nestedStateIndex].state;
            }
            parentScreens.push(route.name);
        }
    }
    route = (0, _findFocusedRoute.findFocusedRoute)(state);
    route.path = path.replace(/\/$/, '');
    var params = parseQueryParams(path, flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined);
    if (params) {
        route.params = _object_spread._({}, route.params, params);
    }
    return state;
};
var parseQueryParams = (path, parseConfig)=>{
    var query = path.split('?')[1];
    var params = queryString.parse(query);
    if (parseConfig) {
        Object.keys(params).forEach((name)=>{
            if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {
                params[name] = parseConfig[name](params[name]);
            }
        });
    }
    return Object.keys(params).length ? params : undefined;
}; //# sourceMappingURL=getStateFromPath.js.map


}),
1519: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _exportNames = {
    BaseNavigationContainer: true,
    createNavigationContainerRef: true,
    createNavigatorFactory: true,
    CurrentRenderContext: true,
    findFocusedRoute: true,
    getActionFromState: true,
    getFocusedRouteNameFromRoute: true,
    getPathFromState: true,
    getStateFromPath: true,
    NavigationContainerRefContext: true,
    NavigationContext: true,
    NavigationHelpersContext: true,
    NavigationIndependentTree: true,
    NavigationRouteContext: true,
    PreventRemoveContext: true,
    PreventRemoveProvider: true,
    createComponentForStaticNavigation: true,
    createPathConfigForStaticNavigation: true,
    ThemeContext: true,
    ThemeProvider: true,
    useTheme: true,
    useFocusEffect: true,
    useIsFocused: true,
    useNavigation: true,
    useNavigationBuilder: true,
    useNavigationContainerRef: true,
    useNavigationIndependentTree: true,
    useNavigationState: true,
    usePreventRemove: true,
    usePreventRemoveContext: true,
    useRoute: true,
    validatePathConfig: true
};
Object.defineProperty(exports, "BaseNavigationContainer", ({
    enumerable: true,
    get: function() {
        return _BaseNavigationContainer.BaseNavigationContainer;
    }
}));
Object.defineProperty(exports, "CurrentRenderContext", ({
    enumerable: true,
    get: function() {
        return _CurrentRenderContext.CurrentRenderContext;
    }
}));
Object.defineProperty(exports, "NavigationContainerRefContext", ({
    enumerable: true,
    get: function() {
        return _NavigationContainerRefContext.NavigationContainerRefContext;
    }
}));
Object.defineProperty(exports, "NavigationContext", ({
    enumerable: true,
    get: function() {
        return _NavigationContext.NavigationContext;
    }
}));
Object.defineProperty(exports, "NavigationHelpersContext", ({
    enumerable: true,
    get: function() {
        return _NavigationHelpersContext.NavigationHelpersContext;
    }
}));
Object.defineProperty(exports, "NavigationIndependentTree", ({
    enumerable: true,
    get: function() {
        return _NavigationIndependentTree.NavigationIndependentTree;
    }
}));
Object.defineProperty(exports, "NavigationRouteContext", ({
    enumerable: true,
    get: function() {
        return _NavigationRouteContext.NavigationRouteContext;
    }
}));
Object.defineProperty(exports, "PreventRemoveContext", ({
    enumerable: true,
    get: function() {
        return _PreventRemoveContext.PreventRemoveContext;
    }
}));
Object.defineProperty(exports, "PreventRemoveProvider", ({
    enumerable: true,
    get: function() {
        return _PreventRemoveProvider.PreventRemoveProvider;
    }
}));
Object.defineProperty(exports, "ThemeContext", ({
    enumerable: true,
    get: function() {
        return _ThemeContext.ThemeContext;
    }
}));
Object.defineProperty(exports, "ThemeProvider", ({
    enumerable: true,
    get: function() {
        return _ThemeProvider.ThemeProvider;
    }
}));
Object.defineProperty(exports, "createComponentForStaticNavigation", ({
    enumerable: true,
    get: function() {
        return _StaticNavigation.createComponentForStaticNavigation;
    }
}));
Object.defineProperty(exports, "createNavigationContainerRef", ({
    enumerable: true,
    get: function() {
        return _createNavigationContainerRef.createNavigationContainerRef;
    }
}));
Object.defineProperty(exports, "createNavigatorFactory", ({
    enumerable: true,
    get: function() {
        return _createNavigatorFactory.createNavigatorFactory;
    }
}));
Object.defineProperty(exports, "createPathConfigForStaticNavigation", ({
    enumerable: true,
    get: function() {
        return _StaticNavigation.createPathConfigForStaticNavigation;
    }
}));
Object.defineProperty(exports, "findFocusedRoute", ({
    enumerable: true,
    get: function() {
        return _findFocusedRoute.findFocusedRoute;
    }
}));
Object.defineProperty(exports, "getActionFromState", ({
    enumerable: true,
    get: function() {
        return _getActionFromState.getActionFromState;
    }
}));
Object.defineProperty(exports, "getFocusedRouteNameFromRoute", ({
    enumerable: true,
    get: function() {
        return _getFocusedRouteNameFromRoute.getFocusedRouteNameFromRoute;
    }
}));
Object.defineProperty(exports, "getPathFromState", ({
    enumerable: true,
    get: function() {
        return _getPathFromState.getPathFromState;
    }
}));
Object.defineProperty(exports, "getStateFromPath", ({
    enumerable: true,
    get: function() {
        return _getStateFromPath.getStateFromPath;
    }
}));
Object.defineProperty(exports, "useFocusEffect", ({
    enumerable: true,
    get: function() {
        return _useFocusEffect.useFocusEffect;
    }
}));
Object.defineProperty(exports, "useIsFocused", ({
    enumerable: true,
    get: function() {
        return _useIsFocused.useIsFocused;
    }
}));
Object.defineProperty(exports, "useNavigation", ({
    enumerable: true,
    get: function() {
        return _useNavigation.useNavigation;
    }
}));
Object.defineProperty(exports, "useNavigationBuilder", ({
    enumerable: true,
    get: function() {
        return _useNavigationBuilder.useNavigationBuilder;
    }
}));
Object.defineProperty(exports, "useNavigationContainerRef", ({
    enumerable: true,
    get: function() {
        return _useNavigationContainerRef.useNavigationContainerRef;
    }
}));
Object.defineProperty(exports, "useNavigationIndependentTree", ({
    enumerable: true,
    get: function() {
        return _useNavigationIndependentTree.useNavigationIndependentTree;
    }
}));
Object.defineProperty(exports, "useNavigationState", ({
    enumerable: true,
    get: function() {
        return _useNavigationState.useNavigationState;
    }
}));
Object.defineProperty(exports, "usePreventRemove", ({
    enumerable: true,
    get: function() {
        return _usePreventRemove.usePreventRemove;
    }
}));
Object.defineProperty(exports, "usePreventRemoveContext", ({
    enumerable: true,
    get: function() {
        return _usePreventRemoveContext.usePreventRemoveContext;
    }
}));
Object.defineProperty(exports, "useRoute", ({
    enumerable: true,
    get: function() {
        return _useRoute.useRoute;
    }
}));
Object.defineProperty(exports, "useTheme", ({
    enumerable: true,
    get: function() {
        return _useTheme.useTheme;
    }
}));
Object.defineProperty(exports, "validatePathConfig", ({
    enumerable: true,
    get: function() {
        return _validatePathConfig.validatePathConfig;
    }
}));
var _BaseNavigationContainer = __webpack_require__(54670);
var _createNavigationContainerRef = __webpack_require__(83700);
var _createNavigatorFactory = __webpack_require__(89339);
var _CurrentRenderContext = __webpack_require__(86861);
var _findFocusedRoute = __webpack_require__(85814);
var _getActionFromState = __webpack_require__(50514);
var _getFocusedRouteNameFromRoute = __webpack_require__(31963);
var _getPathFromState = __webpack_require__(61115);
var _getStateFromPath = __webpack_require__(23651);
var _NavigationContainerRefContext = __webpack_require__(10999);
var _NavigationContext = __webpack_require__(40653);
var _NavigationHelpersContext = __webpack_require__(12800);
var _NavigationIndependentTree = __webpack_require__(93114);
var _NavigationRouteContext = __webpack_require__(50643);
var _PreventRemoveContext = __webpack_require__(53119);
var _PreventRemoveProvider = __webpack_require__(53284);
var _StaticNavigation = __webpack_require__(52558);
var _ThemeContext = __webpack_require__(90931);
var _ThemeProvider = __webpack_require__(56163);
var _useTheme = __webpack_require__(42433);
var _types = __webpack_require__(66372);
Object.keys(_types).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _types[key];
        }
    });
});
var _useFocusEffect = __webpack_require__(14861);
var _useIsFocused = __webpack_require__(47149);
var _useNavigation = __webpack_require__(966);
var _useNavigationBuilder = __webpack_require__(71026);
var _useNavigationContainerRef = __webpack_require__(26172);
var _useNavigationIndependentTree = __webpack_require__(72798);
var _useNavigationState = __webpack_require__(5172);
var _usePreventRemove = __webpack_require__(97582);
var _usePreventRemoveContext = __webpack_require__(7223);
var _useRoute = __webpack_require__(62865);
var _validatePathConfig = __webpack_require__(665);
var _routers = __webpack_require__(38686);
Object.keys(_routers).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _routers[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _routers[key];
        }
    });
}); //# sourceMappingURL=index.js.map


}),
6923: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isArrayEqual = isArrayEqual;
/**
 * Compare two arrays with primitive values as the content.
 * We need to make sure that both values and order match.
 */ function isArrayEqual(a, b) {
    if (a === b) {
        return true;
    }
    if (a.length !== b.length) {
        return false;
    }
    return a.every((it, index)=>it === b[index]);
} //# sourceMappingURL=isArrayEqual.js.map


}),
18831: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isRecordEqual = isRecordEqual;
/**
 * Compare two records with primitive values as the content.
 */ function isRecordEqual(a, b) {
    if (a === b) {
        return true;
    }
    var aKeys = Object.keys(a);
    var bKeys = Object.keys(b);
    if (aKeys.length !== bKeys.length) {
        return false;
    }
    return aKeys.every((key)=>a[key] === b[key]);
} //# sourceMappingURL=isRecordEqual.js.map


}),
90931: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ThemeContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var ThemeContext = exports.ThemeContext = /*#__PURE__*/ React.createContext(undefined);
ThemeContext.displayName = 'ThemeContext'; //# sourceMappingURL=ThemeContext.js.map


}),
56163: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ThemeProvider = ThemeProvider;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _ThemeContext = __webpack_require__(90931);
var _jsxRuntime = __webpack_require__(7100);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function ThemeProvider(ref) {
    var value = ref.value, children = ref.children;
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_ThemeContext.ThemeContext.Provider, {
        value: value,
        children: children
    });
} //# sourceMappingURL=ThemeProvider.js.map


}),
42433: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useTheme = useTheme;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _ThemeContext = __webpack_require__(90931);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useTheme() {
    var theme = React.useContext(_ThemeContext.ThemeContext);
    if (theme == null) {
        throw new Error("Couldn't find a theme. Is your component inside NavigationContainer or does it have a theme?");
    }
    return theme;
} //# sourceMappingURL=useTheme.js.map


}),
66372: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _class_call_check = __webpack_require__(81230);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.PrivateValueStore = void 0;
var PrivateValueStore = function PrivateValueStore() {
    _class_call_check._(this, PrivateValueStore);
};
exports.PrivateValueStore = PrivateValueStore; //# sourceMappingURL=types.js.map


}),
83802: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useChildListeners = useChildListeners;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook which lets child navigators add action listeners.
 */ function useChildListeners() {
    var _React_useRef = React.useRef({
        action: [],
        focus: []
    }), listeners = _React_useRef.current;
    var addListener = React.useCallback((type, listener)=>{
        listeners[type].push(listener);
        var removed = false;
        return ()=>{
            var index = listeners[type].indexOf(listener);
            if (!removed && index > -1) {
                removed = true;
                listeners[type].splice(index, 1);
            }
        };
    }, [
        listeners
    ]);
    return {
        listeners,
        addListener
    };
} //# sourceMappingURL=useChildListeners.js.map


}),
90687: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useComponent = useComponent;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _jsxRuntime = __webpack_require__(7100);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var NavigationContent = (ref)=>{
    var render = ref.render, children = ref.children;
    return render(children);
};
function useComponent(render) {
    var renderRef = React.useRef(render);
    // Normally refs shouldn't be mutated in render
    // But we return a component which will be rendered
    // So it's just for immediate consumption
    renderRef.current = render;
    React.useEffect(()=>{
        renderRef.current = null;
    });
    return React.useRef((ref)=>{
        var children = ref.children;
        var _$render = renderRef.current;
        if (_$render === null) {
            throw new Error('The returned component must be rendered in the same render phase as the hook.');
        }
        return /*#__PURE__*/ (0, _jsxRuntime.jsx)(NavigationContent, {
            render: _$render,
            children: children
        });
    }).current;
} //# sourceMappingURL=useComponent.js.map


}),
80279: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useCurrentRender = useCurrentRender;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _CurrentRenderContext = __webpack_require__(86861);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Write the current options, so that server renderer can get current values
 * Mutating values like this is not safe in async mode, but it doesn't apply to SSR
 */ function useCurrentRender(ref) {
    var state = ref.state, navigation = ref.navigation, descriptors = ref.descriptors;
    var current = React.useContext(_CurrentRenderContext.CurrentRenderContext);
    if (current && navigation.isFocused()) {
        current.options = descriptors[state.routes[state.index].key].options;
    }
} //# sourceMappingURL=useCurrentRender.js.map


}),
95572: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_without_properties = __webpack_require__(45922);
var _sliced_to_array = __webpack_require__(17738);
var _to_consumable_array = __webpack_require__(58678);
var _to_property_key = __webpack_require__(21903);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useDescriptors = useDescriptors;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationBuilderContext = __webpack_require__(58911);
var _NavigationContext = __webpack_require__(40653);
var _NavigationRouteContext = __webpack_require__(50643);
var _SceneView = __webpack_require__(6739);
var _ThemeContext = __webpack_require__(90931);
var _useNavigationCache = __webpack_require__(97805);
var _useRouteCache = __webpack_require__(91516);
var _jsxRuntime = __webpack_require__(7100);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to create descriptor objects for the child routes.
 *
 * A descriptor object provides 3 things:
 * - Helper method to render a screen
 * - Options specified by the screen for the navigator
 * - Navigation object intended for the route
 */ function useDescriptors(ref) {
    var state = ref.state, screens = ref.screens, navigation = ref.navigation, screenOptions = ref.screenOptions, screenLayout = ref.screenLayout, onAction = ref.onAction, getState = ref.getState, setState = ref.setState, addListener = ref.addListener, addKeyedListener = ref.addKeyedListener, onRouteFocus = ref.onRouteFocus, router = ref.router, emitter = ref.emitter;
    var theme = React.useContext(_ThemeContext.ThemeContext);
    var _React_useState = _sliced_to_array._(React.useState({}), 2), options = _React_useState[0], setOptions = _React_useState[1];
    var _React_useContext = React.useContext(_NavigationBuilderContext.NavigationBuilderContext), onDispatchAction = _React_useContext.onDispatchAction, onOptionsChange = _React_useContext.onOptionsChange, scheduleUpdate = _React_useContext.scheduleUpdate, flushUpdates = _React_useContext.flushUpdates, stackRef = _React_useContext.stackRef;
    var context = React.useMemo(()=>({
            navigation,
            onAction,
            addListener,
            addKeyedListener,
            onRouteFocus,
            onDispatchAction,
            onOptionsChange,
            scheduleUpdate,
            flushUpdates,
            stackRef
        }), [
        navigation,
        onAction,
        addListener,
        addKeyedListener,
        onRouteFocus,
        onDispatchAction,
        onOptionsChange,
        scheduleUpdate,
        flushUpdates,
        stackRef
    ]);
    var _ref = (0, _useNavigationCache.useNavigationCache)({
        state,
        getState,
        navigation,
        setOptions,
        router,
        emitter
    }), base = _ref.base, navigations = _ref.navigations;
    var routes = (0, _useRouteCache.useRouteCache)(state.routes);
    var getOptions = (route, navigation, overrides)=>{
        var config = screens[route.name];
        var screen = config.props;
        var optionsList = [
            // The default `screenOptions` passed to the navigator
            screenOptions
        ].concat(// The `screenOptions` props passed to `Group` elements
        _to_consumable_array._(config.options ? config.options.filter(Boolean) : []), [
            // The `options` prop passed to `Screen` elements,
            screen.options,
            // The options set via `navigation.setOptions`
            overrides
        ]);
        return optionsList.reduce((acc, curr)=>Object.assign(acc, // @ts-expect-error: we check for function but TS still complains
            typeof curr !== 'function' ? curr : curr({
                route,
                navigation,
                theme
            })), {});
    };
    var render = (route, navigation, customOptions, routeState)=>{
        var config = screens[route.name];
        var screen = config.props;
        var clearOptions = ()=>setOptions((o)=>{
                if (route.key in o) {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    var _route_key = route.key, _ = o[_route_key], rest = _object_without_properties._(o, [
                        _route_key
                    ].map(_to_property_key._));
                    return rest;
                }
                return o;
            });
        var layout = // The `layout` prop passed to `Screen` elements,
        screen.layout ?? // The `screenLayout` props passed to `Group` elements
        config.layout ?? // The default `screenLayout` passed to the navigator
        screenLayout;
        var element = /*#__PURE__*/ (0, _jsxRuntime.jsx)(_SceneView.SceneView, {
            navigation: navigation,
            route: route,
            screen: screen,
            routeState: routeState,
            getState: getState,
            setState: setState,
            options: customOptions,
            clearOptions: clearOptions
        });
        if (layout != null) {
            element = layout({
                route,
                navigation,
                // @ts-expect-error: in practice `theme` will be defined
                theme,
                children: element
            });
        }
        return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationBuilderContext.NavigationBuilderContext.Provider, {
            value: context,
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationContext.NavigationContext.Provider, {
                value: navigation,
                children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationRouteContext.NavigationRouteContext.Provider, {
                    value: route,
                    children: element
                })
            })
        }, route.key);
    };
    var descriptors = routes.reduce((acc, route, i)=>{
        var navigation = navigations[route.key];
        var customOptions = getOptions(route, navigation, options[route.key]);
        var element = render(route, navigation, customOptions, state.routes[i].state);
        acc[route.key] = {
            route,
            // @ts-expect-error: it's missing action helpers, fix later
            navigation,
            render () {
                return element;
            },
            options: customOptions
        };
        return acc;
    }, {});
    /**
   * Create a descriptor object for a route.
   *
   * @param route Route object for which the descriptor should be created
   * @param placeholder Whether the descriptor should be a placeholder, e.g. for a route not yet in the state
   * @returns Descriptor object
   */ var describe = (route, placeholder)=>{
        if (!placeholder) {
            if (!(route.key in descriptors)) {
                throw new Error(`Couldn't find a route with the key ${route.key}.`);
            }
            return descriptors[route.key];
        }
        var navigation = base;
        var customOptions = getOptions(route, navigation, {});
        var element = render(route, navigation, customOptions, undefined);
        return {
            route,
            navigation,
            render () {
                return element;
            },
            options: customOptions
        };
    };
    return {
        describe,
        descriptors
    };
} //# sourceMappingURL=useDescriptors.js.map


}),
86908: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useEventEmitter = useEventEmitter;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to manage the event system used by the navigator to notify screens of various events.
 */ function useEventEmitter(listen) {
    var listenRef = React.useRef(listen);
    React.useEffect(()=>{
        listenRef.current = listen;
    });
    var listeners = React.useRef(Object.create(null));
    var create = React.useCallback((target)=>{
        var removeListener = (type, callback)=>{
            var callbacks = listeners.current[type] ? listeners.current[type][target] : undefined;
            if (!callbacks) {
                return;
            }
            var index = callbacks.indexOf(callback);
            if (index > -1) {
                callbacks.splice(index, 1);
            }
        };
        var addListener = (type, callback)=>{
            listeners.current[type] = listeners.current[type] || {};
            listeners.current[type][target] = listeners.current[type][target] || [];
            listeners.current[type][target].push(callback);
            var removed = false;
            return ()=>{
                // Prevent removing other listeners when unsubscribing same listener multiple times
                if (!removed) {
                    removed = true;
                    removeListener(type, callback);
                }
            };
        };
        return {
            addListener,
            removeListener
        };
    }, []);
    var emit = React.useCallback((ref)=>{
        var type = ref.type, data = ref.data, target = ref.target, canPreventDefault = ref.canPreventDefault;
        var _instance;
        var _items_target, _listenRef_current;
        var items = listeners.current[type] || {};
        // Copy the current list of callbacks in case they are mutated during execution
        var callbacks = target !== undefined ? (_items_target = items[target]) === null || _items_target === void 0 ? void 0 : _items_target.slice() : (_instance = []).concat.apply(_instance, _to_consumable_array._(Object.keys(items).map((t)=>items[t]))).filter((cb, i, self)=>self.lastIndexOf(cb) === i);
        var event = {
            get type () {
                return type;
            }
        };
        if (target !== undefined) {
            Object.defineProperty(event, 'target', {
                enumerable: true,
                get () {
                    return target;
                }
            });
        }
        if (data !== undefined) {
            Object.defineProperty(event, 'data', {
                enumerable: true,
                get () {
                    return data;
                }
            });
        }
        if (canPreventDefault) {
            var defaultPrevented = false;
            Object.defineProperties(event, {
                defaultPrevented: {
                    enumerable: true,
                    get () {
                        return defaultPrevented;
                    }
                },
                preventDefault: {
                    enumerable: true,
                    value () {
                        defaultPrevented = true;
                    }
                }
            });
        }
        (_listenRef_current = listenRef.current) === null || _listenRef_current === void 0 ? void 0 : _listenRef_current.call(listenRef, event);
        callbacks === null || callbacks === void 0 ? void 0 : callbacks.forEach((cb)=>cb(event));
        return event;
    }, []);
    return React.useMemo(()=>({
            create,
            emit
        }), [
        create,
        emit
    ]);
} //# sourceMappingURL=useEventEmitter.js.map


}),
14861: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useFocusEffect = useFocusEffect;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _useNavigation = __webpack_require__(966);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to run an effect in a focused screen, similar to `React.useEffect`.
 * This can be used to perform side-effects such as fetching data or subscribing to events.
 * The passed callback should be wrapped in `React.useCallback` to avoid running the effect too often.
 *
 * @param callback Memoized callback containing the effect, should optionally return a cleanup function.
 */ function useFocusEffect(effect) {
    var navigation = (0, _useNavigation.useNavigation)();
    // eslint-disable-next-line prefer-rest-params
    if (arguments[1] !== undefined) {
        var message = "You passed a second argument to 'useFocusEffect', but it only accepts one argument. " + "If you want to pass a dependency array, you can use 'React.useCallback':\n\n" + 'useFocusEffect(\n' + '  React.useCallback(() => {\n' + '    // Your code here\n' + '  }, [depA, depB])\n' + ');\n\n' + 'See usage guide: https://reactnavigation.org/docs/use-focus-effect';
        console.error(message);
    }
    React.useEffect(()=>{
        var isFocused = false;
        var cleanup;
        var callback = ()=>{
            var destroy = effect();
            if (destroy === undefined || typeof destroy === 'function') {
                return destroy;
            }
            if (false) { var message }
        };
        // We need to run the effect on initial render/dep changes if the screen is focused
        if (navigation.isFocused()) {
            cleanup = callback();
            isFocused = true;
        }
        var unsubscribeFocus = navigation.addListener('focus', ()=>{
            // If callback was already called for focus, avoid calling it again
            // The focus event may also fire on initial render, so we guard against running the effect twice
            if (isFocused) {
                return;
            }
            if (cleanup !== undefined) {
                cleanup();
            }
            cleanup = callback();
            isFocused = true;
        });
        var unsubscribeBlur = navigation.addListener('blur', ()=>{
            if (cleanup !== undefined) {
                cleanup();
            }
            cleanup = undefined;
            isFocused = false;
        });
        return ()=>{
            if (cleanup !== undefined) {
                cleanup();
            }
            unsubscribeFocus();
            unsubscribeBlur();
        };
    }, [
        effect,
        navigation
    ]);
} //# sourceMappingURL=useFocusEffect.js.map


}),
68516: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useFocusEvents = useFocusEvents;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationContext = __webpack_require__(40653);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to take care of emitting `focus` and `blur` events.
 */ function useFocusEvents(ref) {
    var state = ref.state, emitter = ref.emitter;
    var navigation = React.useContext(_NavigationContext.NavigationContext);
    var lastFocusedKeyRef = React.useRef();
    var currentFocusedKey = state.routes[state.index].key;
    // When the parent screen changes its focus state, we also need to change child's focus
    // Coz the child screen can't be focused if the parent screen is out of focus
    React.useEffect(()=>navigation === null || navigation === void 0 ? void 0 : navigation.addListener('focus', ()=>{
            lastFocusedKeyRef.current = currentFocusedKey;
            emitter.emit({
                type: 'focus',
                target: currentFocusedKey
            });
        }), [
        currentFocusedKey,
        emitter,
        navigation
    ]);
    React.useEffect(()=>navigation === null || navigation === void 0 ? void 0 : navigation.addListener('blur', ()=>{
            lastFocusedKeyRef.current = undefined;
            emitter.emit({
                type: 'blur',
                target: currentFocusedKey
            });
        }), [
        currentFocusedKey,
        emitter,
        navigation
    ]);
    React.useEffect(()=>{
        var lastFocusedKey = lastFocusedKeyRef.current;
        lastFocusedKeyRef.current = currentFocusedKey;
        // We wouldn't have `lastFocusedKey` on initial mount
        // Fire focus event for the current route on mount if there's no parent navigator
        if (lastFocusedKey === undefined && !navigation) {
            emitter.emit({
                type: 'focus',
                target: currentFocusedKey
            });
        }
        // We should only emit events when the focused key changed and navigator is focused
        // When navigator is not focused, screens inside shouldn't receive focused status either
        if (lastFocusedKey === currentFocusedKey || !(navigation ? navigation.isFocused() : true)) {
            return;
        }
        if (lastFocusedKey === undefined) {
            // Only fire events after initial mount
            return;
        }
        emitter.emit({
            type: 'blur',
            target: lastFocusedKey
        });
        emitter.emit({
            type: 'focus',
            target: currentFocusedKey
        });
    }, [
        currentFocusedKey,
        emitter,
        navigation
    ]);
} //# sourceMappingURL=useFocusEvents.js.map


}),
48114: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useFocusedListenersChildrenAdapter = useFocusedListenersChildrenAdapter;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationBuilderContext = __webpack_require__(58911);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook for passing focus callback to children
 */ function useFocusedListenersChildrenAdapter(ref) {
    var navigation = ref.navigation, focusedListeners = ref.focusedListeners;
    var addListener = React.useContext(_NavigationBuilderContext.NavigationBuilderContext).addListener;
    var listener = React.useCallback((callback)=>{
        if (navigation.isFocused()) {
            for (var listener of focusedListeners){
                var _listener = listener(callback), handled = _listener.handled, result = _listener.result;
                if (handled) {
                    return {
                        handled,
                        result
                    };
                }
            }
            return {
                handled: true,
                result: callback(navigation)
            };
        } else {
            return {
                handled: false,
                result: null
            };
        }
    }, [
        focusedListeners,
        navigation
    ]);
    React.useEffect(()=>addListener === null || addListener === void 0 ? void 0 : addListener('focus', listener), [
        addListener,
        listener
    ]);
} //# sourceMappingURL=useFocusedListenersChildrenAdapter.js.map


}),
47149: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useIsFocused = useIsFocused;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _useNavigation = __webpack_require__(966);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to get the current focus state of the screen. Returns a `true` if screen is focused, otherwise `false`.
 * This can be used if a component needs to render something based on the focus state.
 */ function useIsFocused() {
    var navigation = (0, _useNavigation.useNavigation)();
    var subscribe = React.useCallback((callback)=>{
        var unsubscribeFocus = navigation.addListener('focus', callback);
        var unsubscribeBlur = navigation.addListener('blur', callback);
        return ()=>{
            unsubscribeFocus();
            unsubscribeBlur();
        };
    }, [
        navigation
    ]);
    var value = React.useSyncExternalStore(subscribe, navigation.isFocused, navigation.isFocused);
    return value;
} //# sourceMappingURL=useIsFocused.js.map


}),
20862: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useIsomorphicLayoutEffect = void 0;
var _react = __webpack_require__(92888);
var useIsomorphicLayoutEffect = exports.useIsomorphicLayoutEffect = _react.useLayoutEffect; //# sourceMappingURL=useIsomorphicLayoutEffect.native.js.map


}),
37279: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useKeyedChildListeners = useKeyedChildListeners;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook which lets child navigators add getters to be called for obtaining rehydrated state.
 */ function useKeyedChildListeners() {
    var _React_useRef = React.useRef(Object.assign(Object.create(null), {
        getState: {},
        beforeRemove: {}
    })), keyedListeners = _React_useRef.current;
    var addKeyedListener = React.useCallback((type, key, listener)=>{
        // @ts-expect-error: according to ref stated above you can use `key` to index type
        keyedListeners[type][key] = listener;
        return ()=>{
            // @ts-expect-error: according to ref stated above you can use `key` to index type
            keyedListeners[type][key] = undefined;
        };
    }, [
        keyedListeners
    ]);
    return {
        keyedListeners,
        addKeyedListener
    };
} //# sourceMappingURL=useKeyedChildListeners.js.map


}),
67238: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLazyValue = useLazyValue;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useLazyValue(create) {
    var lazyRef = React.useRef();
    if (lazyRef.current === undefined) {
        lazyRef.current = create();
    }
    return lazyRef.current;
} //# sourceMappingURL=useLazyValue.js.map


}),
966: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useNavigation = useNavigation;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationContainerRefContext = __webpack_require__(10999);
var _NavigationContext = __webpack_require__(40653);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to access the navigation prop of the parent screen anywhere.
 *
 * @returns Navigation prop of the parent screen.
 */ function useNavigation() {
    var root = React.useContext(_NavigationContainerRefContext.NavigationContainerRefContext);
    var navigation = React.useContext(_NavigationContext.NavigationContext);
    if (navigation === undefined && root === undefined) {
        throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    // FIXME: Figure out a better way to do this
    return navigation ?? root;
} //# sourceMappingURL=useNavigation.js.map


}),
71026: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_without_properties = __webpack_require__(45922);
var _sliced_to_array = __webpack_require__(17738);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useNavigationBuilder = useNavigationBuilder;
var _routers = __webpack_require__(38686);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _reactIs = __webpack_require__(55526);
var _useLatestCallback = _interopRequireDefault(__webpack_require__(34467));
var _deepFreeze = __webpack_require__(54303);
var _Group = __webpack_require__(98963);
var _isArrayEqual = __webpack_require__(6923);
var _isRecordEqual = __webpack_require__(18831);
var _NavigationHelpersContext = __webpack_require__(12800);
var _NavigationRouteContext = __webpack_require__(50643);
var _NavigationStateContext = __webpack_require__(26101);
var _PreventRemoveProvider = __webpack_require__(53284);
var _Screen = __webpack_require__(17293);
var _types = __webpack_require__(66372);
var _useChildListeners = __webpack_require__(83802);
var _useComponent = __webpack_require__(90687);
var _useCurrentRender = __webpack_require__(80279);
var _useDescriptors = __webpack_require__(95572);
var _useEventEmitter = __webpack_require__(86908);
var _useFocusedListenersChildrenAdapter = __webpack_require__(48114);
var _useFocusEvents = __webpack_require__(68516);
var _useIsomorphicLayoutEffect = __webpack_require__(20862);
var _useKeyedChildListeners = __webpack_require__(37279);
var _useLazyValue = __webpack_require__(67238);
var _useNavigationHelpers = __webpack_require__(12951);
var _useOnAction = __webpack_require__(47309);
var _useOnGetState = __webpack_require__(6459);
var _useOnRouteFocus = __webpack_require__(78104);
var _useRegisterNavigator = __webpack_require__(4918);
var _useScheduleUpdate = __webpack_require__(82706);
var _jsxRuntime = __webpack_require__(7100);
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
// This is to make TypeScript compiler happy
_types.PrivateValueStore;
var isValidKey = (key)=>key === undefined || typeof key === 'string' && key !== '';
/**
 * Extract route config object from React children elements.
 *
 * @param children React Elements to extract the config from.
 */ var getRouteConfigsFromChildren = (children, groupKey, groupOptions, groupLayout)=>{
    var configs = React.Children.toArray(children).reduce((acc, child)=>{
        var _child_type, _child_props;
        if (/*#__PURE__*/ React.isValidElement(child)) {
            if (child.type === _Screen.Screen) {
                // We can only extract the config from `Screen` elements
                // If something else was rendered, it's probably a bug
                if (!isValidKey(child.props.navigationKey)) {
                    throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the screen '${child.props.name}'. It must be a non-empty string or 'undefined'.`);
                }
                acc.push({
                    keys: [
                        groupKey,
                        child.props.navigationKey
                    ],
                    options: groupOptions,
                    layout: groupLayout,
                    props: child.props
                });
                return acc;
            }
            if (child.type === React.Fragment || child.type === _Group.Group) {
                var // When we encounter a fragment or group, we need to dive into its children to extract the configs
                // This is handy to conditionally define a group of screens
                _acc;
                if (!isValidKey(child.props.navigationKey)) {
                    throw new Error(`Got an invalid 'navigationKey' prop (${JSON.stringify(child.props.navigationKey)}) for the group. It must be a non-empty string or 'undefined'.`);
                }
                (_acc = acc).push.apply(_acc, _to_consumable_array._(getRouteConfigsFromChildren(child.props.children, child.props.navigationKey, child.type !== _Group.Group ? groupOptions : groupOptions != null ? _to_consumable_array._(groupOptions).concat([
                    child.props.screenOptions
                ]) : [
                    child.props.screenOptions
                ], typeof child.props.screenLayout === 'function' ? child.props.screenLayout : groupLayout)));
                return acc;
            }
        }
        throw new Error(`A navigator can only contain 'Screen', 'Group' or 'React.Fragment' as its direct children (found ${React.isValidElement(child) ? `'${typeof child.type === 'string' ? child.type : (_child_type = child.type) === null || _child_type === void 0 ? void 0 : _child_type.name}'${child.props != null && typeof child.props === 'object' && 'name' in child.props && ((_child_props = child.props) === null || _child_props === void 0 ? void 0 : _child_props.name) ? ` for the screen '${child.props.name}'` : ''}` : typeof child === 'object' ? JSON.stringify(child) : `'${String(child)}'`}). To render this component in the navigator, pass it in the 'component' prop to 'Screen'.`);
    }, []);
    if (false) {}
    return configs;
};
/**
 * Hook for building navigators.
 *
 * @param createRouter Factory method which returns router object.
 * @param options Options object containing `children` and additional options for the router.
 * @returns An object containing `state`, `navigation`, `descriptors` objects.
 */ function useNavigationBuilder(createRouter, options) {
    var navigatorKey = (0, _useRegisterNavigator.useRegisterNavigator)();
    var route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    var children = options.children, layout = options.layout, screenOptions = options.screenOptions, screenLayout = options.screenLayout, screenListeners = options.screenListeners, rest = _object_without_properties._(options, [
        "children",
        "layout",
        "screenOptions",
        "screenLayout",
        "screenListeners"
    ]);
    var routeConfigs = getRouteConfigsFromChildren(children);
    var router = (0, _useLazyValue.useLazyValue)(()=>{
        if (rest.initialRouteName != null && routeConfigs.every((config)=>config.props.name !== rest.initialRouteName)) {
            throw new Error(`Couldn't find a screen named '${rest.initialRouteName}' to use as 'initialRouteName'.`);
        }
        return createRouter(rest);
    });
    var screens = routeConfigs.reduce((acc, config)=>{
        if (config.props.name in acc) {
            throw new Error(`A navigator cannot contain multiple 'Screen' components with the same name (found duplicate screen named '${config.props.name}')`);
        }
        acc[config.props.name] = config;
        return acc;
    }, {});
    var routeNames = routeConfigs.map((config)=>config.props.name);
    var routeKeyList = routeNames.reduce((acc, curr)=>{
        acc[curr] = screens[curr].keys.map((key)=>key ?? '').join(':');
        return acc;
    }, {});
    var routeParamList = routeNames.reduce((acc, curr)=>{
        var initialParams = screens[curr].props.initialParams;
        acc[curr] = initialParams;
        return acc;
    }, {});
    var routeGetIdList = routeNames.reduce((acc, curr)=>Object.assign(acc, {
            [curr]: screens[curr].props.getId
        }), {});
    if (!routeNames.length) {
        throw new Error("Couldn't find any screens for the navigator. Have you defined any screens as its children?");
    }
    var isStateValid = React.useCallback((state)=>state.type === undefined || state.type === router.type, [
        router.type
    ]);
    var isStateInitialized = React.useCallback((state)=>state !== undefined && state.stale === false && isStateValid(state), [
        isStateValid
    ]);
    var _React_useContext = React.useContext(_NavigationStateContext.NavigationStateContext), currentState = _React_useContext.state, getCurrentState = _React_useContext.getState, setCurrentState = _React_useContext.setState, setKey = _React_useContext.setKey, getKey = _React_useContext.getKey, getIsInitial = _React_useContext.getIsInitial;
    var stateCleanedUp = React.useRef(false);
    var setState = (0, _useLatestCallback.default)((state)=>{
        if (stateCleanedUp.current) {
            // State might have been already cleaned up due to unmount
            // We do not want to expose API allowing to override this
            // This would lead to old data preservation on main navigator unmount
            return;
        }
        setCurrentState(state);
    });
    var _React_useMemo = _sliced_to_array._(React.useMemo(()=>{
        var _route_params, _route_params1, _route_params2;
        var initialRouteParamList = routeNames.reduce((acc, curr)=>{
            var _route_params, _route_params1, _route_params2;
            var initialParams = screens[curr].props.initialParams;
            var initialParamsFromParams = (route === null || route === void 0 ? void 0 : (_route_params = route.params) === null || _route_params === void 0 ? void 0 : _route_params.state) == null && (route === null || route === void 0 ? void 0 : (_route_params1 = route.params) === null || _route_params1 === void 0 ? void 0 : _route_params1.initial) !== false && (route === null || route === void 0 ? void 0 : (_route_params2 = route.params) === null || _route_params2 === void 0 ? void 0 : _route_params2.screen) === curr ? route.params.params : undefined;
            acc[curr] = initialParams !== undefined || initialParamsFromParams !== undefined ? _object_spread._({}, initialParams, initialParamsFromParams) : undefined;
            return acc;
        }, {});
        // If the current state isn't initialized on first render, we initialize it
        // We also need to re-initialize it if the state passed from parent was changed (maybe due to reset)
        // Otherwise assume that the state was provided as initial state
        // So we need to rehydrate it to make it usable
        if ((currentState === undefined || !isStateValid(currentState)) && (route === null || route === void 0 ? void 0 : (_route_params = route.params) === null || _route_params === void 0 ? void 0 : _route_params.state) == null && !(typeof (route === null || route === void 0 ? void 0 : (_route_params1 = route.params) === null || _route_params1 === void 0 ? void 0 : _route_params1.screen) === 'string' && (route === null || route === void 0 ? void 0 : (_route_params2 = route.params) === null || _route_params2 === void 0 ? void 0 : _route_params2.initial) !== false)) {
            return [
                router.getInitialState({
                    routeNames,
                    routeParamList: initialRouteParamList,
                    routeGetIdList
                }),
                true
            ];
        } else {
            var _route_params3, _route_params4, _route_params5;
            var stateFromParams;
            if ((route === null || route === void 0 ? void 0 : (_route_params3 = route.params) === null || _route_params3 === void 0 ? void 0 : _route_params3.state) != null) {
                stateFromParams = route.params.state;
            } else if (typeof (route === null || route === void 0 ? void 0 : (_route_params4 = route.params) === null || _route_params4 === void 0 ? void 0 : _route_params4.screen) === 'string' && (route === null || route === void 0 ? void 0 : (_route_params5 = route.params) === null || _route_params5 === void 0 ? void 0 : _route_params5.initial) !== false) {
                stateFromParams = {
                    index: 0,
                    routes: [
                        {
                            name: route.params.screen,
                            params: route.params.params,
                            path: route.params.path
                        }
                    ]
                };
            }
            return [
                router.getRehydratedState(stateFromParams ?? currentState, {
                    routeNames,
                    routeParamList: initialRouteParamList,
                    routeGetIdList
                }),
                false
            ];
        }
    // We explicitly don't include routeNames, route.params etc. in the dep list
    // below. We want to avoid forcing a new state to be calculated in those cases
    // Instead, we handle changes to these in the nextState code below. Note
    // that some changes to routeConfigs are explicitly ignored, such as changes
    // to initialParams
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [
        currentState,
        router,
        isStateValid
    ]), 2), initializedState = _React_useMemo[0], isFirstStateInitialization = _React_useMemo[1];
    var previousRouteKeyListRef = React.useRef(routeKeyList);
    React.useEffect(()=>{
        previousRouteKeyListRef.current = routeKeyList;
    });
    var previousRouteKeyList = previousRouteKeyListRef.current;
    var state = // If the state isn't initialized, or stale, use the state we initialized instead
    // The state won't update until there's a change needed in the state we have initialized locally
    // So it'll be `undefined` or stale until the first navigation event happens
    isStateInitialized(currentState) ? currentState : initializedState;
    var nextState = state;
    if (!(0, _isArrayEqual.isArrayEqual)(state.routeNames, routeNames) || !(0, _isRecordEqual.isRecordEqual)(routeKeyList, previousRouteKeyList)) {
        var _options_UNSTABLE_getStateForRouteNamesChange;
        var navigatorStateForNextRouteNamesChange = (_options_UNSTABLE_getStateForRouteNamesChange = options.UNSTABLE_getStateForRouteNamesChange) === null || _options_UNSTABLE_getStateForRouteNamesChange === void 0 ? void 0 : _options_UNSTABLE_getStateForRouteNamesChange.call(options, state);
        // When the list of route names change, the router should handle it to remove invalid routes
        nextState = navigatorStateForNextRouteNamesChange ? // @ts-expect-error this is ok
        router.getRehydratedState(navigatorStateForNextRouteNamesChange, {
            routeNames,
            routeParamList,
            routeGetIdList
        }) : router.getStateForRouteNamesChange(state, {
            routeNames,
            routeParamList,
            routeGetIdList,
            routeKeyChanges: Object.keys(routeKeyList).filter((name)=>name in previousRouteKeyList && routeKeyList[name] !== previousRouteKeyList[name])
        });
    }
    var previousNestedParamsRef = React.useRef(route === null || route === void 0 ? void 0 : route.params);
    React.useEffect(()=>{
        previousNestedParamsRef.current = route === null || route === void 0 ? void 0 : route.params;
    }, [
        route === null || route === void 0 ? void 0 : route.params
    ]);
    if (route === null || route === void 0 ? void 0 : route.params) {
        var previousParams = previousNestedParamsRef.current;
        var action;
        if (typeof route.params.state === 'object' && route.params.state != null && route.params !== previousParams) {
            // If the route was updated with new state, we should reset to it
            action = _routers.CommonActions.reset(route.params.state);
        } else if (typeof route.params.screen === 'string' && (route.params.initial === false && isFirstStateInitialization || route.params !== previousParams)) {
            // If the route was updated with new screen name and/or params, we should navigate there
            action = _routers.CommonActions.navigate({
                name: route.params.screen,
                params: route.params.params,
                path: route.params.path
            });
        }
        // The update should be limited to current navigator only, so we call the router manually
        var updatedState = action ? router.getStateForAction(nextState, action, {
            routeNames,
            routeParamList,
            routeGetIdList
        }) : null;
        nextState = updatedState !== null ? router.getRehydratedState(updatedState, {
            routeNames,
            routeParamList,
            routeGetIdList
        }) : nextState;
    }
    var shouldUpdate = state !== nextState;
    (0, _useScheduleUpdate.useScheduleUpdate)(()=>{
        if (shouldUpdate) {
            // If the state needs to be updated, we'll schedule an update
            setState(nextState);
        }
    });
    // The up-to-date state will come in next render, but we don't need to wait for it
    // We can't use the outdated state since the screens have changed, which will cause error due to mismatched config
    // So we override the state object we return to use the latest state as soon as possible
    state = nextState;
    React.useEffect(()=>{
        // In strict mode, React will double-invoke effects.
        // So we need to reset the flag if component was not unmounted
        stateCleanedUp.current = false;
        setKey(navigatorKey);
        if (!getIsInitial()) {
            // If it's not initial render, we need to update the state
            // This will make sure that our container gets notifier of state changes due to new mounts
            // This is necessary for proper screen tracking, URL updates etc.
            setState(nextState);
        }
        return ()=>{
            // We need to clean up state for this navigator on unmount
            if (getCurrentState() !== undefined && getKey() === navigatorKey) {
                setCurrentState(undefined);
                stateCleanedUp.current = true;
            }
        };
    // eslint-disable-next-line react-hooks/exhaustive-deps
    }, []);
    // In some cases (e.g. route names change), internal state might have changed
    // But it hasn't been committed yet, so hasn't propagated to the sync external store
    // During this time, we need to return the internal state in `getState`
    // Otherwise it can result in inconsistent state during render in children
    // To avoid this, we use a ref for render phase, and immediately clear it on commit
    var stateRef = React.useRef(state);
    stateRef.current = state;
    (0, _useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(()=>{
        stateRef.current = null;
    });
    var getState = (0, _useLatestCallback.default)(()=>{
        var currentState = getCurrentState();
        return (0, _deepFreeze.deepFreeze)(isStateInitialized(currentState) ? currentState : initializedState);
    });
    var emitter = (0, _useEventEmitter.useEventEmitter)((e)=>{
        var _instance;
        var routeNames = [];
        var route;
        if (e.target) {
            route = state.routes.find((route)=>route.key === e.target);
            if (route === null || route === void 0 ? void 0 : route.name) {
                routeNames.push(route.name);
            }
        } else {
            var _routeNames;
            route = state.routes[state.index];
            (_routeNames = routeNames).push.apply(_routeNames, _to_consumable_array._(Object.keys(screens).filter((name)=>(route === null || route === void 0 ? void 0 : route.name) === name)));
        }
        if (route == null) {
            return;
        }
        var navigation = descriptors[route.key].navigation;
        var listeners = (_instance = []).concat.apply(_instance, // Get an array of listeners for all screens + common listeners on navigator
        _to_consumable_array._([
            screenListeners
        ].concat(_to_consumable_array._(routeNames.map((name)=>{
            var listeners = screens[name].props.listeners;
            return listeners;
        }))).map((listeners)=>{
            var map = typeof listeners === 'function' ? listeners({
                route: route,
                navigation
            }) : listeners;
            return map ? Object.keys(map).filter((type)=>type === e.type).map((type)=>map === null || map === void 0 ? void 0 : map[type]) : undefined;
        })))// We don't want same listener to be called multiple times for same event
        // So we remove any duplicate functions from the array
        .filter((cb, i, self)=>cb && self.lastIndexOf(cb) === i);
        listeners.forEach((listener)=>listener === null || listener === void 0 ? void 0 : listener(e));
    });
    (0, _useFocusEvents.useFocusEvents)({
        state,
        emitter
    });
    React.useEffect(()=>{
        emitter.emit({
            type: 'state',
            data: {
                state
            }
        });
    }, [
        emitter,
        state
    ]);
    var _ref = (0, _useChildListeners.useChildListeners)(), childListeners = _ref.listeners, addListener = _ref.addListener;
    var _ref1 = (0, _useKeyedChildListeners.useKeyedChildListeners)(), keyedListeners = _ref1.keyedListeners, addKeyedListener = _ref1.addKeyedListener;
    var onAction = (0, _useOnAction.useOnAction)({
        router,
        getState,
        setState,
        key: route === null || route === void 0 ? void 0 : route.key,
        actionListeners: childListeners.action,
        beforeRemoveListeners: keyedListeners.beforeRemove,
        routerConfigOptions: {
            routeNames,
            routeParamList,
            routeGetIdList
        },
        emitter
    });
    var onRouteFocus = (0, _useOnRouteFocus.useOnRouteFocus)({
        router,
        key: route === null || route === void 0 ? void 0 : route.key,
        getState,
        setState
    });
    var navigation = (0, _useNavigationHelpers.useNavigationHelpers)({
        id: options.id,
        onAction,
        getState,
        emitter,
        router,
        stateRef
    });
    (0, _useFocusedListenersChildrenAdapter.useFocusedListenersChildrenAdapter)({
        navigation,
        focusedListeners: childListeners.focus
    });
    (0, _useOnGetState.useOnGetState)({
        getState,
        getStateListeners: keyedListeners.getState
    });
    var _ref2 = (0, _useDescriptors.useDescriptors)({
        state,
        screens,
        navigation,
        screenOptions,
        screenLayout,
        onAction,
        getState,
        setState,
        onRouteFocus,
        addListener,
        addKeyedListener,
        router,
        // @ts-expect-error: this should have both core and custom events, but too much work right now
        emitter
    }), describe = _ref2.describe, descriptors = _ref2.descriptors;
    (0, _useCurrentRender.useCurrentRender)({
        state,
        navigation,
        descriptors
    });
    var NavigationContent = (0, _useComponent.useComponent)((children)=>{
        var element = layout != null ? layout({
            state,
            descriptors,
            navigation,
            children
        }) : children;
        return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationHelpersContext.NavigationHelpersContext.Provider, {
            value: navigation,
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_PreventRemoveProvider.PreventRemoveProvider, {
                children: element
            })
        });
    });
    return {
        state,
        navigation,
        describe,
        descriptors,
        NavigationContent
    };
} //# sourceMappingURL=useNavigationBuilder.js.map


}),
97805: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _object_without_properties = __webpack_require__(45922);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useNavigationCache = useNavigationCache;
var _routers = __webpack_require__(38686);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationBuilderContext = __webpack_require__(58911);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to cache navigation objects for each screen in the navigator.
 * It's important to cache them to make sure navigation objects don't change between renders.
 * This lets us apply optimizations like `React.memo` to minimize re-rendering screens.
 */ function useNavigationCache(ref) {
    var state = ref.state, getState = ref.getState, navigation = ref.navigation, setOptions = ref.setOptions, router = ref.router, emitter = ref.emitter;
    var stackRef = React.useContext(_NavigationBuilderContext.NavigationBuilderContext).stackRef;
    var base = React.useMemo(()=>{
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        var emit = navigation.emit, rest = _object_without_properties._(navigation, [
            "emit"
        ]);
        var actions = _object_spread._({}, router.actionCreators, _routers.CommonActions);
        var dispatch = ()=>{
            throw new Error('Actions cannot be dispatched from a placeholder screen.');
        };
        var helpers = Object.keys(actions).reduce((acc, name)=>{
            acc[name] = dispatch;
            return acc;
        }, {});
        return _object_spread_props._(_object_spread._({}, rest, helpers), {
            addListener: ()=>{
                // Event listeners are not supported for placeholder screens
                return ()=>{
                // Empty function
                };
            },
            removeListener: ()=>{
            // Event listeners are not supported for placeholder screens
            },
            dispatch,
            getParent: (id)=>{
                if (id !== undefined && id === rest.getId()) {
                    return base;
                }
                return rest.getParent(id);
            },
            setOptions: ()=>{
                throw new Error('Options cannot be set from a placeholder screen.');
            },
            isFocused: ()=>false
        });
    }, [
        navigation,
        router.actionCreators
    ]);
    // Cache object which holds navigation objects for each screen
    // We use `React.useMemo` instead of `React.useRef` coz we want to invalidate it when deps change
    // In reality, these deps will rarely change, if ever
    var cache = React.useMemo(()=>({
            current: {}
        }), // eslint-disable-next-line react-hooks/exhaustive-deps
    [
        base,
        getState,
        navigation,
        setOptions,
        emitter
    ]);
    cache.current = state.routes.reduce((acc, route)=>{
        var previous = cache.current[route.key];
        if (previous) {
            // If a cached navigation object already exists, reuse it
            acc[route.key] = previous;
        } else {
            var dispatch = (thunk)=>{
                var action = typeof thunk === 'function' ? thunk(getState()) : thunk;
                if (action != null) {
                    navigation.dispatch(_object_spread._({
                        source: route.key
                    }, action));
                }
            };
            var withStack = (callback)=>{
                var isStackSet = false;
                try {
                    if (false) {}
                    callback();
                } finally{
                    if (isStackSet && stackRef) {
                        stackRef.current = undefined;
                    }
                }
            };
            var actions = _object_spread._({}, router.actionCreators, _routers.CommonActions);
            var helpers = Object.keys(actions).reduce((acc, name)=>{
                var _actions;
                acc[name] = (...args)=>withStack(()=>// @ts-expect-error: name is a valid key, but TypeScript is dumb
                        dispatch((_actions = actions)[name].apply(_actions, _to_consumable_array._(args))));
                return acc;
            }, {});
            acc[route.key] = _object_spread_props._(_object_spread._({}, base, helpers, emitter.create(route.key)), {
                dispatch: (thunk)=>withStack(()=>dispatch(thunk)),
                getParent: (id)=>{
                    if (id !== undefined && id === base.getId()) {
                        // If the passed id is the same as the current navigation id,
                        // we return the cached navigation object for the relevant route
                        return acc[route.key];
                    }
                    return base.getParent(id);
                },
                setOptions: (options)=>{
                    setOptions((o)=>_object_spread_props._(_object_spread._({}, o), {
                            [route.key]: _object_spread._({}, o[route.key], options)
                        }));
                },
                isFocused: ()=>{
                    var state = base.getState();
                    if (state.routes[state.index].key !== route.key) {
                        return false;
                    }
                    // If the current screen is focused, we also need to check if parent navigator is focused
                    // This makes sure that we return the focus state in the whole tree, not just this navigator
                    return navigation ? navigation.isFocused() : true;
                }
            });
        }
        return acc;
    }, {});
    return {
        base,
        navigations: cache.current
    };
} //# sourceMappingURL=useNavigationCache.js.map


}),
26172: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useNavigationContainerRef = useNavigationContainerRef;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _createNavigationContainerRef = __webpack_require__(83700);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useNavigationContainerRef() {
    var navigation = React.useRef(null);
    if (navigation.current == null) {
        navigation.current = (0, _createNavigationContainerRef.createNavigationContainerRef)();
    }
    return navigation.current;
} //# sourceMappingURL=useNavigationContainerRef.js.map


}),
12951: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useNavigationHelpers = useNavigationHelpers;
var _routers = __webpack_require__(38686);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationContext = __webpack_require__(40653);
var _types = __webpack_require__(66372);
var _UnhandledActionContext = __webpack_require__(38000);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
// This is to make TypeScript compiler happy
_types.PrivateValueStore;
/**
 * Navigation object with helper methods to be used by a navigator.
 * This object includes methods for common actions as well as methods the parent screen's navigation object.
 */ function useNavigationHelpers(ref) {
    var navigatorId = ref.id, onAction = ref.onAction, getState = ref.getState, emitter = ref.emitter, router = ref.router, stateRef = ref.stateRef;
    var onUnhandledAction = React.useContext(_UnhandledActionContext.UnhandledActionContext);
    var parentNavigationHelpers = React.useContext(_NavigationContext.NavigationContext);
    return React.useMemo(()=>{
        var dispatch = (op)=>{
            var action = typeof op === 'function' ? op(getState()) : op;
            var handled = onAction(action);
            if (!handled) {
                onUnhandledAction === null || onUnhandledAction === void 0 ? void 0 : onUnhandledAction(action);
            }
        };
        var actions = _object_spread._({}, router.actionCreators, _routers.CommonActions);
        var helpers = Object.keys(actions).reduce((acc, name)=>{
            var _actions;
            // @ts-expect-error: name is a valid key, but TypeScript is dumb
            acc[name] = (...args)=>dispatch((_actions = actions)[name].apply(_actions, _to_consumable_array._(args)));
            return acc;
        }, {});
        var navigationHelpers = _object_spread_props._(_object_spread._({}, parentNavigationHelpers, helpers), {
            dispatch,
            emit: emitter.emit,
            isFocused: parentNavigationHelpers ? parentNavigationHelpers.isFocused : ()=>true,
            canGoBack: ()=>{
                var state = getState();
                return router.getStateForAction(state, _routers.CommonActions.goBack(), {
                    routeNames: state.routeNames,
                    routeParamList: {},
                    routeGetIdList: {}
                }) !== null || (parentNavigationHelpers === null || parentNavigationHelpers === void 0 ? void 0 : parentNavigationHelpers.canGoBack()) || false;
            },
            getId: ()=>navigatorId,
            getParent: (id)=>{
                if (id !== undefined) {
                    var current = navigationHelpers;
                    while(current && id !== current.getId()){
                        current = current.getParent();
                    }
                    return current;
                }
                return parentNavigationHelpers;
            },
            getState: ()=>{
                // FIXME: Workaround for when the state is read during render
                // By this time, we haven't committed the new state yet
                // Without this `useSyncExternalStore` will keep reading the old state
                // This may result in `useNavigationState` or `useIsFocused` returning wrong values
                // Apart from `useSyncExternalStore`, `getState` should never be called during render
                if (stateRef.current != null) {
                    return stateRef.current;
                }
                return getState();
            }
        });
        return navigationHelpers;
    }, [
        router,
        parentNavigationHelpers,
        emitter.emit,
        getState,
        onAction,
        onUnhandledAction,
        navigatorId,
        stateRef
    ]);
} //# sourceMappingURL=useNavigationHelpers.js.map


}),
72798: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useNavigationIndependentTree = useNavigationIndependentTree;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationIndependentTreeContext = __webpack_require__(68307);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useNavigationIndependentTree() {
    return React.useContext(_NavigationIndependentTreeContext.NavigationIndependentTreeContext);
} //# sourceMappingURL=useNavigationIndependentTree.js.map


}),
5172: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useNavigationState = useNavigationState;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _withSelector = __webpack_require__(65632);
var _useNavigation = __webpack_require__(966);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to get a value from the current navigation state using a selector.
 *
 * @param selector Selector function to get a value from the state.
 */ function useNavigationState(selector) {
    var navigation = (0, _useNavigation.useNavigation)();
    var subscribe = React.useCallback((callback)=>{
        var unsubscribe = navigation.addListener('state', callback);
        return unsubscribe;
    }, [
        navigation
    ]);
    var value = (0, _withSelector.useSyncExternalStoreWithSelector)(subscribe, navigation.getState, navigation.getState, selector);
    return value;
} //# sourceMappingURL=useNavigationState.js.map


}),
47309: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useOnAction = useOnAction;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _DeprecatedNavigationInChildContext = __webpack_require__(88862);
var _NavigationBuilderContext = __webpack_require__(58911);
var _useOnPreventRemove = __webpack_require__(29237);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to handle actions for a navigator, including state updates and bubbling.
 *
 * Bubbling an action is achieved in 2 ways:
 * 1. To bubble action to parent, we expose the action handler in context and then access the parent context
 * 2. To bubble action to child, child adds event listeners subscribing to actions from parent
 *
 * When the action handler handles as action, it returns `true`, otherwise `false`.
 */ function useOnAction(ref) {
    var router = ref.router, getState = ref.getState, setState = ref.setState, key = ref.key, actionListeners = ref.actionListeners, beforeRemoveListeners = ref.beforeRemoveListeners, routerConfigOptions = ref.routerConfigOptions, emitter = ref.emitter;
    var _React_useContext = React.useContext(_NavigationBuilderContext.NavigationBuilderContext), onActionParent = _React_useContext.onAction, onRouteFocusParent = _React_useContext.onRouteFocus, addListenerParent = _React_useContext.addListener, onDispatchAction = _React_useContext.onDispatchAction;
    var navigationInChildEnabled = React.useContext(_DeprecatedNavigationInChildContext.DeprecatedNavigationInChildContext);
    var routerConfigOptionsRef = React.useRef(routerConfigOptions);
    React.useEffect(()=>{
        routerConfigOptionsRef.current = routerConfigOptions;
    });
    var onAction = React.useCallback((action, ref)=>{
        var visitedNavigators = ref === void 0 ? new Set() : ref;
        var state = getState();
        // Since actions can bubble both up and down, they could come to the same navigator again
        // We keep track of navigators which have already tried to handle the action and return if it's already visited
        if (visitedNavigators.has(state.key)) {
            return false;
        }
        visitedNavigators.add(state.key);
        if (typeof action.target !== 'string' || action.target === state.key) {
            var result = router.getStateForAction(state, action, routerConfigOptionsRef.current);
            // If a target is specified and set to current navigator, the action shouldn't bubble
            // So instead of `null`, we use the state object for such cases to signal that action was handled
            result = result === null && action.target === state.key ? state : result;
            if (result !== null) {
                onDispatchAction(action, state === result);
                if (state !== result) {
                    var isPrevented = (0, _useOnPreventRemove.shouldPreventRemove)(emitter, beforeRemoveListeners, state.routes, result.routes, action);
                    if (isPrevented) {
                        return true;
                    }
                    setState(result);
                }
                if (onRouteFocusParent !== undefined) {
                    // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree
                    // This means we need to focus all of the parent navigators of this navigator as well
                    var shouldFocus = router.shouldActionChangeFocus(action);
                    if (shouldFocus && key !== undefined) {
                        onRouteFocusParent(key);
                    }
                }
                return true;
            }
        }
        if (onActionParent !== undefined) {
            // Bubble action to the parent if the current navigator didn't handle it
            if (onActionParent(action, visitedNavigators)) {
                return true;
            }
        }
        if (typeof action.target === 'string' || // For backward compatibility
        action.type === 'NAVIGATE_DEPRECATED' || navigationInChildEnabled) {
            // If the action wasn't handled by current navigator or a parent navigator, let children handle it
            // Handling this when target isn't specified is deprecated and will be removed in the future
            for(var i = actionListeners.length - 1; i >= 0; i--){
                var listener = actionListeners[i];
                if (listener(action, visitedNavigators)) {
                    return true;
                }
            }
        }
        return false;
    }, [
        actionListeners,
        beforeRemoveListeners,
        emitter,
        getState,
        navigationInChildEnabled,
        key,
        onActionParent,
        onDispatchAction,
        onRouteFocusParent,
        router,
        setState
    ]);
    (0, _useOnPreventRemove.useOnPreventRemove)({
        getState,
        emitter,
        beforeRemoveListeners
    });
    React.useEffect(()=>addListenerParent === null || addListenerParent === void 0 ? void 0 : addListenerParent('action', onAction), [
        addListenerParent,
        onAction
    ]);
    return onAction;
} //# sourceMappingURL=useOnAction.js.map


}),
6459: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useOnGetState = useOnGetState;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _isArrayEqual = __webpack_require__(6923);
var _NavigationBuilderContext = __webpack_require__(58911);
var _NavigationRouteContext = __webpack_require__(50643);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useOnGetState(ref) {
    var getState = ref.getState, getStateListeners = ref.getStateListeners;
    var addKeyedListener = React.useContext(_NavigationBuilderContext.NavigationBuilderContext).addKeyedListener;
    var route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    var key = route ? route.key : 'root';
    var getRehydratedState = React.useCallback(()=>{
        var state = getState();
        // Avoid returning new route objects if we don't need to
        var routes = state.routes.map((route)=>{
            var _getStateListeners_route_key;
            var childState = (_getStateListeners_route_key = getStateListeners[route.key]) === null || _getStateListeners_route_key === void 0 ? void 0 : _getStateListeners_route_key.call(getStateListeners);
            if (route.state === childState) {
                return route;
            }
            return _object_spread_props._(_object_spread._({}, route), {
                state: childState
            });
        });
        if ((0, _isArrayEqual.isArrayEqual)(state.routes, routes)) {
            return state;
        }
        return _object_spread_props._(_object_spread._({}, state), {
            routes
        });
    }, [
        getState,
        getStateListeners
    ]);
    React.useEffect(()=>{
        return addKeyedListener === null || addKeyedListener === void 0 ? void 0 : addKeyedListener('getState', key, getRehydratedState);
    }, [
        addKeyedListener,
        getRehydratedState,
        key
    ]);
} //# sourceMappingURL=useOnGetState.js.map


}),
29237: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.shouldPreventRemove = void 0;
exports.useOnPreventRemove = useOnPreventRemove;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationBuilderContext = __webpack_require__(58911);
var _NavigationRouteContext = __webpack_require__(50643);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var VISITED_ROUTE_KEYS = Symbol('VISITED_ROUTE_KEYS');
var shouldPreventRemove = (emitter, beforeRemoveListeners, currentRoutes, nextRoutes, action)=>{
    var nextRouteKeys = nextRoutes.map((route)=>route.key);
    // Call these in reverse order so last screens handle the event first
    var removedRoutes = currentRoutes.filter((route)=>!nextRouteKeys.includes(route.key)).reverse();
    var visitedRouteKeys = // @ts-expect-error: add this property to mark that we've already emitted this action
    action[VISITED_ROUTE_KEYS] ?? new Set();
    var beforeRemoveAction = _object_spread_props._(_object_spread._({}, action), {
        [VISITED_ROUTE_KEYS]: visitedRouteKeys
    });
    for (var route of removedRoutes){
        var _beforeRemoveListeners_route_key;
        if (visitedRouteKeys.has(route.key)) {
            continue;
        }
        // First, we need to check if any child screens want to prevent it
        var isPrevented = (_beforeRemoveListeners_route_key = beforeRemoveListeners[route.key]) === null || _beforeRemoveListeners_route_key === void 0 ? void 0 : _beforeRemoveListeners_route_key.call(beforeRemoveListeners, beforeRemoveAction);
        if (isPrevented) {
            return true;
        }
        visitedRouteKeys.add(route.key);
        var event = emitter.emit({
            type: 'beforeRemove',
            target: route.key,
            data: {
                action: beforeRemoveAction
            },
            canPreventDefault: true
        });
        if (event.defaultPrevented) {
            return true;
        }
    }
    return false;
};
exports.shouldPreventRemove = shouldPreventRemove;
function useOnPreventRemove(ref) {
    var getState = ref.getState, emitter = ref.emitter, beforeRemoveListeners = ref.beforeRemoveListeners;
    var addKeyedListener = React.useContext(_NavigationBuilderContext.NavigationBuilderContext).addKeyedListener;
    var route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    var routeKey = route === null || route === void 0 ? void 0 : route.key;
    React.useEffect(()=>{
        if (routeKey) {
            return addKeyedListener === null || addKeyedListener === void 0 ? void 0 : addKeyedListener('beforeRemove', routeKey, (action)=>{
                var state = getState();
                return shouldPreventRemove(emitter, beforeRemoveListeners, state.routes, [], action);
            });
        }
    }, [
        addKeyedListener,
        beforeRemoveListeners,
        emitter,
        getState,
        routeKey
    ]);
} //# sourceMappingURL=useOnPreventRemove.js.map


}),
78104: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useOnRouteFocus = useOnRouteFocus;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationBuilderContext = __webpack_require__(58911);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to handle focus actions for a route.
 * Focus action needs to be treated specially, coz when a nested route is focused,
 * the parent navigators also needs to be focused.
 */ function useOnRouteFocus(ref) {
    var router = ref.router, getState = ref.getState, sourceRouteKey = ref.key, setState = ref.setState;
    var _React_useContext = React.useContext(_NavigationBuilderContext.NavigationBuilderContext), onRouteFocusParent = _React_useContext.onRouteFocus;
    return React.useCallback((key)=>{
        var state = getState();
        var result = router.getStateForRouteFocus(state, key);
        if (result !== state) {
            setState(result);
        }
        if (onRouteFocusParent !== undefined && sourceRouteKey !== undefined) {
            onRouteFocusParent(sourceRouteKey);
        }
    }, [
        getState,
        onRouteFocusParent,
        router,
        setState,
        sourceRouteKey
    ]);
} //# sourceMappingURL=useOnRouteFocus.js.map


}),
17222: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useOptionsGetters = useOptionsGetters;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationBuilderContext = __webpack_require__(58911);
var _NavigationStateContext = __webpack_require__(26101);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useOptionsGetters(ref) {
    var key = ref.key, options = ref.options, navigation = ref.navigation;
    var optionsRef = React.useRef(options);
    var optionsGettersFromChildRef = React.useRef({});
    var onOptionsChange = React.useContext(_NavigationBuilderContext.NavigationBuilderContext).onOptionsChange;
    var _React_useContext = React.useContext(_NavigationStateContext.NavigationStateContext), parentAddOptionsGetter = _React_useContext.addOptionsGetter;
    var optionsChangeListener = React.useCallback(()=>{
        var isFocused = (navigation === null || navigation === void 0 ? void 0 : navigation.isFocused()) ?? true;
        var hasChildren = Object.keys(optionsGettersFromChildRef.current).length;
        if (isFocused && !hasChildren) {
            onOptionsChange(optionsRef.current ?? {});
        }
    }, [
        navigation,
        onOptionsChange
    ]);
    React.useEffect(()=>{
        optionsRef.current = options;
        optionsChangeListener();
        return navigation === null || navigation === void 0 ? void 0 : navigation.addListener('focus', optionsChangeListener);
    }, [
        navigation,
        options,
        optionsChangeListener
    ]);
    var getOptionsFromListener = React.useCallback(()=>{
        for(var key in optionsGettersFromChildRef.current){
            if (key in optionsGettersFromChildRef.current) {
                var _optionsGettersFromChildRef_current_key, _optionsGettersFromChildRef_current;
                var result = (_optionsGettersFromChildRef_current_key = (_optionsGettersFromChildRef_current = optionsGettersFromChildRef.current)[key]) === null || _optionsGettersFromChildRef_current_key === void 0 ? void 0 : _optionsGettersFromChildRef_current_key.call(_optionsGettersFromChildRef_current);
                // null means unfocused route
                if (result !== null) {
                    return result;
                }
            }
        }
        return null;
    }, []);
    var getCurrentOptions = React.useCallback(()=>{
        var isFocused = (navigation === null || navigation === void 0 ? void 0 : navigation.isFocused()) ?? true;
        if (!isFocused) {
            return null;
        }
        var optionsFromListener = getOptionsFromListener();
        if (optionsFromListener !== null) {
            return optionsFromListener;
        }
        return optionsRef.current;
    }, [
        navigation,
        getOptionsFromListener
    ]);
    React.useEffect(()=>{
        return parentAddOptionsGetter === null || parentAddOptionsGetter === void 0 ? void 0 : parentAddOptionsGetter(key, getCurrentOptions);
    }, [
        getCurrentOptions,
        parentAddOptionsGetter,
        key
    ]);
    var addOptionsGetter = React.useCallback((key, getter)=>{
        optionsGettersFromChildRef.current[key] = getter;
        optionsChangeListener();
        return ()=>{
            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
            delete optionsGettersFromChildRef.current[key];
            optionsChangeListener();
        };
    }, [
        optionsChangeListener
    ]);
    return {
        addOptionsGetter,
        getCurrentOptions
    };
} //# sourceMappingURL=useOptionsGetters.js.map


}),
97582: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(17738);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.usePreventRemove = usePreventRemove;
var _nonSecure = __webpack_require__(78803);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _useLatestCallback = _interopRequireDefault(__webpack_require__(34467));
var _useNavigation = __webpack_require__(966);
var _usePreventRemoveContext = __webpack_require__(7223);
var _useRoute = __webpack_require__(62865);
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to prevent screen from being removed. Can be used to prevent users from leaving the screen.
 *
 * @param preventRemove Boolean indicating whether to prevent screen from being removed.
 * @param callback Function which is executed when screen was prevented from being removed.
 */ function usePreventRemove(preventRemove, callback) {
    var _React_useState = _sliced_to_array._(React.useState(()=>(0, _nonSecure.nanoid)()), 1), id = _React_useState[0];
    var navigation = (0, _useNavigation.useNavigation)();
    var _ref = (0, _useRoute.useRoute)(), routeKey = _ref.key;
    var setPreventRemove = (0, _usePreventRemoveContext.usePreventRemoveContext)().setPreventRemove;
    React.useEffect(()=>{
        setPreventRemove(id, routeKey, preventRemove);
        return ()=>{
            setPreventRemove(id, routeKey, false);
        };
    }, [
        setPreventRemove,
        id,
        routeKey,
        preventRemove
    ]);
    var beforeRemoveListener = (0, _useLatestCallback.default)((e)=>{
        if (!preventRemove) {
            return;
        }
        e.preventDefault();
        callback({
            data: e.data
        });
    });
    React.useEffect(()=>navigation === null || navigation === void 0 ? void 0 : navigation.addListener('beforeRemove', beforeRemoveListener), [
        navigation,
        beforeRemoveListener
    ]);
} //# sourceMappingURL=usePreventRemove.js.map


}),
7223: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.usePreventRemoveContext = usePreventRemoveContext;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _PreventRemoveContext = __webpack_require__(53119);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function usePreventRemoveContext() {
    var value = React.useContext(_PreventRemoveContext.PreventRemoveContext);
    if (value == null) {
        throw new Error("Couldn't find the prevent remove context. Is your component inside NavigationContent?");
    }
    return value;
} //# sourceMappingURL=usePreventRemoveContext.js.map


}),
4918: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(17738);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useRegisterNavigator = useRegisterNavigator;
var _nonSecure = __webpack_require__(78803);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _EnsureSingleNavigator = __webpack_require__(37594);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Register a navigator in the parent context (either a navigation container or a screen).
 * This is used to prevent multiple navigators under a single container or screen.
 */ function useRegisterNavigator() {
    var _React_useState = _sliced_to_array._(React.useState(()=>(0, _nonSecure.nanoid)()), 1), key = _React_useState[0];
    var container = React.useContext(_EnsureSingleNavigator.SingleNavigatorContext);
    if (container === undefined) {
        throw new Error("Couldn't register the navigator. Have you wrapped your app with 'NavigationContainer'?\n\nThis can also happen if there are multiple copies of '@react-navigation' packages installed.");
    }
    React.useEffect(()=>{
        var register = container.register, unregister = container.unregister;
        register(key);
        return ()=>unregister(key);
    }, [
        container,
        key
    ]);
    return key;
} //# sourceMappingURL=useRegisterNavigator.js.map


}),
62865: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useRoute = useRoute;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationRouteContext = __webpack_require__(50643);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to access the route prop of the parent screen anywhere.
 *
 * @returns Route prop of the parent screen.
 */ function useRoute() {
    var route = React.useContext(_NavigationRouteContext.NavigationRouteContext);
    if (route === undefined) {
        throw new Error("Couldn't find a route object. Is your component inside a screen in a navigator?");
    }
    return route;
} //# sourceMappingURL=useRoute.js.map


}),
91516: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_without_properties = __webpack_require__(45922);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CHILD_STATE = void 0;
exports.useRouteCache = useRouteCache;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _isRecordEqual = __webpack_require__(18831);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Utilities such as `getFocusedRouteNameFromRoute` need to access state.
 * So we need a way to suppress the warning for those use cases.
 * This is fine since they are internal utilities and this is not public API.
 */ var CHILD_STATE = exports.CHILD_STATE = Symbol('CHILD_STATE');
/**
 * Hook to cache route props for each screen in the navigator.
 * This lets add warnings and modifications to the route object but keep references between renders.
 */ function useRouteCache(routes) {
    // Cache object which holds route objects for each screen
    var cache = React.useMemo(()=>({
            current: new Map()
        }), []);
    if (true) {
        // We don't want the overhead of creating extra maps every render in prod
        return routes;
    }
    cache.current = routes.reduce((acc, route)=>{
        var previous = cache.current.get(route.key);
        var state = route.state, routeWithoutState = _object_without_properties._(route, [
            "state"
        ]);
        var proxy;
        if (previous && (0, _isRecordEqual.isRecordEqual)(previous, routeWithoutState)) {
            // If a cached route object already exists, reuse it
            proxy = previous;
        } else {
            proxy = routeWithoutState;
        }
        if (false) { var value, key }
        Object.defineProperty(proxy, CHILD_STATE, {
            enumerable: false,
            configurable: true,
            value: state
        });
        acc.set(route.key, proxy);
        return acc;
    }, new Map());
    return Array.from(cache.current.values());
} //# sourceMappingURL=useRouteCache.js.map


}),
82706: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useScheduleUpdate = useScheduleUpdate;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationBuilderContext = __webpack_require__(58911);
var _useIsomorphicLayoutEffect = __webpack_require__(20862);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * When screen config changes, we want to update the navigator in the same update phase.
 * However, navigation state is in the root component and React won't let us update it from a child.
 * This is a workaround for that, the scheduled update is stored in the ref without actually calling setState.
 * It lets all subsequent updates access the latest state so it stays correct.
 * Then we call setState during after the component updates.
 */ function useScheduleUpdate(callback) {
    var _React_useContext = React.useContext(_NavigationBuilderContext.NavigationBuilderContext), scheduleUpdate = _React_useContext.scheduleUpdate, flushUpdates = _React_useContext.flushUpdates;
    // FIXME: This is potentially unsafe
    // However, since we are using sync store, it might be fine
    scheduleUpdate(callback);
    (0, _useIsomorphicLayoutEffect.useIsomorphicLayoutEffect)(flushUpdates);
} //# sourceMappingURL=useScheduleUpdate.js.map


}),
79674: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useSyncState = useSyncState;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _useLatestCallback = _interopRequireDefault(__webpack_require__(34467));
var _deepFreeze = __webpack_require__(54303);
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var createStore = (getInitialState)=>{
    var listeners = [];
    var initialized = false;
    var state;
    var getState = ()=>{
        if (initialized) {
            return state;
        }
        initialized = true;
        state = (0, _deepFreeze.deepFreeze)(getInitialState());
        return state;
    };
    var isBatching = false;
    var didUpdate = false;
    var setState = (newState)=>{
        state = (0, _deepFreeze.deepFreeze)(newState);
        didUpdate = true;
        if (!isBatching) {
            listeners.forEach((listener)=>listener());
        }
    };
    var subscribe = (callback)=>{
        listeners.push(callback);
        return ()=>{
            var index = listeners.indexOf(callback);
            if (index > -1) {
                listeners.splice(index, 1);
            }
        };
    };
    var batchUpdates = (callback)=>{
        isBatching = true;
        callback();
        isBatching = false;
        if (didUpdate) {
            didUpdate = false;
            listeners.forEach((listener)=>listener());
        }
    };
    return {
        getState,
        setState,
        batchUpdates,
        subscribe
    };
};
function useSyncState(getInitialState) {
    var store = React.useRef(createStore(getInitialState)).current;
    var state = React.useSyncExternalStore(store.subscribe, store.getState, store.getState);
    React.useDebugValue(state);
    var pendingUpdatesRef = React.useRef([]);
    var scheduleUpdate = (0, _useLatestCallback.default)((callback)=>{
        pendingUpdatesRef.current.push(callback);
    });
    var flushUpdates = (0, _useLatestCallback.default)(()=>{
        var pendingUpdates = pendingUpdatesRef.current;
        pendingUpdatesRef.current = [];
        if (pendingUpdates.length !== 0) {
            store.batchUpdates(()=>{
                // Flush all the pending updates
                for (var update of pendingUpdates){
                    update();
                }
            });
        }
    });
    return {
        state,
        getState: store.getState,
        setState: store.setState,
        scheduleUpdate,
        flushUpdates
    };
} //# sourceMappingURL=useSyncState.js.map


}),
665: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _sliced_to_array = __webpack_require__(17738);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.validatePathConfig = validatePathConfig;
var formatToList = (items)=>Object.entries(items).map((ref)=>{
        var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
        return `- ${key} (${value})`;
    }).join('\n');
function validatePathConfig(config, ref) {
    var root = ref === void 0 ? true : ref;
    var validation = _object_spread._({
        path: 'string',
        initialRouteName: 'string',
        screens: 'object'
    }, root ? null : {
        alias: 'array',
        exact: 'boolean',
        stringify: 'object',
        parse: 'object'
    });
    if (typeof config !== 'object' || config === null) {
        throw new Error(`Expected the configuration to be an object, but got ${JSON.stringify(config)}.`);
    }
    var validationErrors = Object.fromEntries(Object.keys(config).map((key)=>{
        if (key in validation) {
            var type = validation[key];
            // @ts-expect-error: we know the key exists
            var value = config[key];
            if (value !== undefined) {
                if (type === 'array') {
                    if (!Array.isArray(value)) {
                        return [
                            key,
                            `expected 'Array', got '${typeof value}'`
                        ];
                    }
                } else if (typeof value !== type) {
                    return [
                        key,
                        `expected '${type}', got '${typeof value}'`
                    ];
                }
            }
        } else {
            return [
                key,
                'extraneous'
            ];
        }
        return null;
    }).filter(Boolean));
    if (Object.keys(validationErrors).length) {
        throw new Error(`Found invalid properties in the configuration:\n${formatToList(validationErrors)}\n\nYou can only specify the following properties:\n${formatToList(validation)}\n\nIf you want to specify configuration for screens, you need to specify them under a 'screens' property.\n\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`);
    }
    if (root && 'path' in config && typeof config.path === 'string' && config.path.includes(':')) {
        throw new Error(`Found invalid path '${config.path}'. The 'path' in the top-level configuration cannot contain patterns for params.`);
    }
    if ('screens' in config && config.screens) {
        Object.entries(config.screens).forEach((ref)=>{
            var _ref = _sliced_to_array._(ref, 2), _ = _ref[0], value = _ref[1];
            if (typeof value !== 'string') {
                validatePathConfig(value, false);
            }
        });
    }
} //# sourceMappingURL=validatePathConfig.js.map


}),
90644: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _object_without_properties = __webpack_require__(45922);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Link = Link;
var _core = __webpack_require__(1519);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _reactNative = __webpack_require__(38160);
var _useLinkProps = __webpack_require__(79585);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Component to render link to another screen using a path.
 * Uses an anchor tag on the web.
 *
 * @param props.screen Name of the screen to navigate to (e.g. `'Feeds'`).
 * @param props.params Params to pass to the screen to navigate to (e.g. `{ sort: 'hot' }`).
 * @param props.href Optional absolute path to use for the href (e.g. `/feeds/hot`).
 * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
 * @param props.children Child elements to render the content.
 */ function Link(_param) {
    var screen = _param.screen, params = _param.params, action = _param.action, href = _param.href, style = _param.style, rest = _object_without_properties._(_param, [
        "screen",
        "params",
        "action",
        "href",
        "style"
    ]);
    var _ref = (0, _core.useTheme)(), colors = _ref.colors, fonts = _ref.fonts;
    // @ts-expect-error: This is already type-checked by the prop types
    var props = (0, _useLinkProps.useLinkProps)({
        screen,
        params,
        action,
        href
    });
    var onPress = (e)=>{
        if ('onPress' in rest) {
            var _rest_onPress;
            (_rest_onPress = rest.onPress) === null || _rest_onPress === void 0 ? void 0 : _rest_onPress.call(rest, e);
        }
        // Let user prevent default behavior
        if (!e.defaultPrevented) {
            props.onPress(e);
        }
    };
    return /*#__PURE__*/ React.createElement(_reactNative.Text, _object_spread_props._(_object_spread._({}, props, rest, _reactNative.Platform.select({
        web: {
            onClick: onPress
        },
        default: {
            onPress
        }
    })), {
        style: [
            {
                color: colors.primary
            },
            fonts.regular,
            style
        ]
    }));
} //# sourceMappingURL=Link.js.map


}),
6616: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LinkingContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var MISSING_CONTEXT_ERROR = "Couldn't find a LinkingContext context.";
var LinkingContext = exports.LinkingContext = /*#__PURE__*/ React.createContext({
    get options () {
        throw new Error(MISSING_CONTEXT_ERROR);
    }
});
LinkingContext.displayName = 'LinkingContext'; //# sourceMappingURL=LinkingContext.js.map


}),
27072: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LocaleDirContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var LocaleDirContext = exports.LocaleDirContext = /*#__PURE__*/ React.createContext('ltr');
LocaleDirContext.displayName = 'LocaleDirContext'; //# sourceMappingURL=LocaleDirContext.js.map


}),
63508: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _object_without_properties = __webpack_require__(45922);
var _sliced_to_array = __webpack_require__(17738);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NavigationContainer = void 0;
var _core = __webpack_require__(1519);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _reactNative = __webpack_require__(38160);
var _useLatestCallback = _interopRequireDefault(__webpack_require__(34467));
var _LinkingContext = __webpack_require__(6616);
var _LocaleDirContext = __webpack_require__(27072);
var _DefaultTheme = __webpack_require__(19644);
var _UnhandledLinkingContext = __webpack_require__(49981);
var _useBackButton = __webpack_require__(69334);
var _useDocumentTitle = __webpack_require__(95429);
var _useLinking = __webpack_require__(19748);
var _useThenable = __webpack_require__(75234);
var _jsxRuntime = __webpack_require__(7100);
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
globalThis.REACT_NAVIGATION_DEVTOOLS = new WeakMap();
/**
 * Container component which holds the navigation state designed for React Native apps.
 * This should be rendered at the root wrapping the whole app.
 *
 * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).
 * @param props.onReady Callback which is called after the navigation tree mounts.
 * @param props.onStateChange Callback which is called with the latest navigation state when it changes.
 * @param props.onUnhandledAction Callback which is called when an action is not handled.
 * @param props.direction Text direction of the components. Defaults to `'ltr'`.
 * @param props.theme Theme object for the UI elements.
 * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.
 * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.
 * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which refers to the navigation object containing helper methods.
 */ function NavigationContainerInner(_param, ref) {
    var _param_direction = _param.direction, direction = _param_direction === void 0 ? _reactNative.I18nManager.getConstants().isRTL ? 'rtl' : 'ltr' : _param_direction, _param_theme = _param.theme, theme = _param_theme === void 0 ? _DefaultTheme.DefaultTheme : _param_theme, linking = _param.linking, _param_fallback = _param.fallback, fallback = _param_fallback === void 0 ? null : _param_fallback, documentTitle = _param.documentTitle, onReady = _param.onReady, onStateChange = _param.onStateChange, rest = _object_without_properties._(_param, [
        "direction",
        "theme",
        "linking",
        "fallback",
        "documentTitle",
        "onReady",
        "onStateChange"
    ]);
    var isLinkingEnabled = linking ? linking.enabled !== false : false;
    if (linking === null || linking === void 0 ? void 0 : linking.config) {
        (0, _core.validatePathConfig)(linking.config);
    }
    var refContainer = React.useRef(null);
    (0, _useBackButton.useBackButton)(refContainer);
    (0, _useDocumentTitle.useDocumentTitle)(refContainer, documentTitle);
    var _React_useState = _sliced_to_array._(React.useState(), 2), lastUnhandledLink = _React_useState[0], setLastUnhandledLink = _React_useState[1];
    var getInitialState = (0, _useLinking.useLinking)(refContainer, _object_spread._({
        enabled: isLinkingEnabled,
        prefixes: []
    }, linking), setLastUnhandledLink).getInitialState;
    var linkingContext = React.useMemo(()=>({
            options: linking
        }), [
        linking
    ]);
    var unhandledLinkingContext = React.useMemo(()=>({
            lastUnhandledLink,
            setLastUnhandledLink
        }), [
        lastUnhandledLink,
        setLastUnhandledLink
    ]);
    var onReadyForLinkingHandling = (0, _useLatestCallback.default)(()=>{
        var _refContainer_current_getCurrentRoute, _refContainer_current;
        // If the screen path matches lastUnhandledLink, we do not track it
        var path = (_refContainer_current = refContainer.current) === null || _refContainer_current === void 0 ? void 0 : (_refContainer_current_getCurrentRoute = _refContainer_current.getCurrentRoute()) === null || _refContainer_current_getCurrentRoute === void 0 ? void 0 : _refContainer_current_getCurrentRoute.path;
        setLastUnhandledLink((previousLastUnhandledLink)=>{
            if (previousLastUnhandledLink === path) {
                return undefined;
            }
            return previousLastUnhandledLink;
        });
        onReady === null || onReady === void 0 ? void 0 : onReady();
    });
    var onStateChangeForLinkingHandling = (0, _useLatestCallback.default)((state)=>{
        var _refContainer_current_getCurrentRoute, _refContainer_current;
        // If the screen path matches lastUnhandledLink, we do not track it
        var path = (_refContainer_current = refContainer.current) === null || _refContainer_current === void 0 ? void 0 : (_refContainer_current_getCurrentRoute = _refContainer_current.getCurrentRoute()) === null || _refContainer_current_getCurrentRoute === void 0 ? void 0 : _refContainer_current_getCurrentRoute.path;
        setLastUnhandledLink((previousLastUnhandledLink)=>{
            if (previousLastUnhandledLink === path) {
                return undefined;
            }
            return previousLastUnhandledLink;
        });
        onStateChange === null || onStateChange === void 0 ? void 0 : onStateChange(state);
    });
    // Add additional linking related info to the ref
    // This will be used by the devtools
    React.useEffect(()=>{
        if (refContainer.current) {
            REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {
                get linking () {
                    return _object_spread_props._(_object_spread._({}, linking), {
                        enabled: isLinkingEnabled,
                        prefixes: (linking === null || linking === void 0 ? void 0 : linking.prefixes) ?? [],
                        getStateFromPath: (linking === null || linking === void 0 ? void 0 : linking.getStateFromPath) ?? _core.getStateFromPath,
                        getPathFromState: (linking === null || linking === void 0 ? void 0 : linking.getPathFromState) ?? _core.getPathFromState,
                        getActionFromState: (linking === null || linking === void 0 ? void 0 : linking.getActionFromState) ?? _core.getActionFromState
                    });
                }
            });
        }
    });
    var _ref = _sliced_to_array._((0, _useThenable.useThenable)(getInitialState), 2), isResolved = _ref[0], initialState = _ref[1];
    React.useImperativeHandle(ref, ()=>refContainer.current);
    var isLinkingReady = rest.initialState != null || !isLinkingEnabled || isResolved;
    if (!isLinkingReady) {
        // This is temporary until we have Suspense for data-fetching
        // Then the fallback will be handled by a parent `Suspense` component
        return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_core.ThemeProvider, {
            value: theme,
            children: fallback
        });
    }
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_LocaleDirContext.LocaleDirContext.Provider, {
        value: direction,
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_UnhandledLinkingContext.UnhandledLinkingContext.Provider, {
            value: unhandledLinkingContext,
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_LinkingContext.LinkingContext.Provider, {
                value: linkingContext,
                children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_core.BaseNavigationContainer, _object_spread_props._(_object_spread._({}, rest), {
                    theme: theme,
                    onReady: onReadyForLinkingHandling,
                    onStateChange: onStateChangeForLinkingHandling,
                    initialState: rest.initialState == null ? initialState : rest.initialState,
                    ref: refContainer
                }))
            })
        })
    });
}
var NavigationContainer = exports.NavigationContainer = /*#__PURE__*/ React.forwardRef(NavigationContainerInner); //# sourceMappingURL=NavigationContainer.js.map


}),
11090: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ServerContainer = void 0;
var _core = __webpack_require__(1519);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _ServerContext = __webpack_require__(15167);
var _jsxRuntime = __webpack_require__(7100);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Container component for server rendering.
 *
 * @param props.location Location object to base the initial URL for SSR.
 * @param props.children Child elements to render the content.
 * @param props.ref Ref object which contains helper methods.
 */ var ServerContainer = exports.ServerContainer = /*#__PURE__*/ React.forwardRef(function ServerContainer(ref, ref1) {
    var children = ref.children, location = ref.location;
    React.useEffect(()=>{
        console.error("'ServerContainer' should only be used on the server with 'react-dom/server' for SSR.");
    }, []);
    // eslint-disable-next-line @eslint-react/no-unstable-context-value
    var current = {};
    if (ref1) {
        var value = {
            getCurrentOptions () {
                return current.options;
            }
        };
        // We write to the `ref` during render instead of `React.useImperativeHandle`
        // This is because `useImperativeHandle` will update the ref after 'commit',
        // and there's no 'commit' phase during SSR.
        // Mutating ref during render is unsafe in concurrent mode, but we don't care about it for SSR.
        if (typeof ref1 === 'function') {
            ref1(value);
        } else {
            // @ts-expect-error: the TS types are incorrect and say that ref.current is readonly
            ref1.current = value;
        }
    }
    return(/*#__PURE__*/ // eslint-disable-next-line @eslint-react/no-unstable-context-value
    (0, _jsxRuntime.jsx)(_ServerContext.ServerContext.Provider, {
        value: {
            location
        },
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_core.CurrentRenderContext.Provider, {
            value: current,
            children: children
        })
    }));
}); //# sourceMappingURL=ServerContainer.js.map


}),
15167: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ServerContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var ServerContext = exports.ServerContext = /*#__PURE__*/ React.createContext(undefined); //# sourceMappingURL=ServerContext.js.map


}),
49981: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UnhandledLinkingContext = void 0;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var MISSING_CONTEXT_ERROR = "Couldn't find an UnhandledLinkingContext context.";
var UnhandledLinkingContext = exports.UnhandledLinkingContext = /*#__PURE__*/ React.createContext({
    get lastUnhandledLink () {
        throw new Error(MISSING_CONTEXT_ERROR);
    },
    get setLastUnhandledLink () {
        throw new Error(MISSING_CONTEXT_ERROR);
    }
});
UnhandledLinkingContext.displayName = 'UnhandledLinkingContext'; //# sourceMappingURL=UnhandledLinkingContext.js.map


}),
16036: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _object_without_properties = __webpack_require__(45922);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createStaticNavigation = createStaticNavigation;
var _core = __webpack_require__(1519);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _NavigationContainer = __webpack_require__(63508);
var _jsxRuntime = __webpack_require__(7100);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Create a navigation component from a static navigation config.
 * The returned component is a wrapper around `NavigationContainer`.
 *
 * @param tree Static navigation config.
 * @returns Navigation component to use in your app.
 */ function createStaticNavigation(tree) {
    var Component = (0, _core.createComponentForStaticNavigation)(tree, 'RootNavigator');
    function Navigation(_param, ref) {
        var linking = _param.linking, rest = _object_without_properties._(_param, [
            "linking"
        ]);
        var _linking_config, _linking_config1;
        var linkingConfig = React.useMemo(()=>{
            var _linking_config, _linking_config1, _linking_config2;
            var screens = (0, _core.createPathConfigForStaticNavigation)(tree, {
                initialRouteName: linking === null || linking === void 0 ? void 0 : (_linking_config = linking.config) === null || _linking_config === void 0 ? void 0 : _linking_config.initialRouteName
            }, (linking === null || linking === void 0 ? void 0 : linking.enabled) === 'auto');
            if (!screens) return;
            return {
                path: linking === null || linking === void 0 ? void 0 : (_linking_config1 = linking.config) === null || _linking_config1 === void 0 ? void 0 : _linking_config1.path,
                initialRouteName: linking === null || linking === void 0 ? void 0 : (_linking_config2 = linking.config) === null || _linking_config2 === void 0 ? void 0 : _linking_config2.initialRouteName,
                screens
            };
        }, [
            linking === null || linking === void 0 ? void 0 : linking.enabled,
            linking === null || linking === void 0 ? void 0 : (_linking_config = linking.config) === null || _linking_config === void 0 ? void 0 : _linking_config.path,
            linking === null || linking === void 0 ? void 0 : (_linking_config1 = linking.config) === null || _linking_config1 === void 0 ? void 0 : _linking_config1.initialRouteName
        ]);
        var memoizedLinking = React.useMemo(()=>{
            if (!linking) {
                return undefined;
            }
            var enabled = typeof linking.enabled === 'boolean' ? linking.enabled : (linkingConfig === null || linkingConfig === void 0 ? void 0 : linkingConfig.screens) != null;
            return _object_spread_props._(_object_spread._({}, linking), {
                enabled,
                config: linkingConfig
            });
        }, [
            linking,
            linkingConfig
        ]);
        if ((linking === null || linking === void 0 ? void 0 : linking.enabled) === true && (linkingConfig === null || linkingConfig === void 0 ? void 0 : linkingConfig.screens) == null) {
            throw new Error('Linking is enabled but no linking configuration was found for the screens.\n\n' + 'To solve this:\n' + "- Specify a 'linking' property for the screens you want to link to.\n" + "- Or set 'linking.enabled' to 'auto' to generate paths automatically.\n\n" + 'See usage guide: https://reactnavigation.org/docs/static-configuration#linking');
        }
        return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NavigationContainer.NavigationContainer, _object_spread_props._(_object_spread._({}, rest), {
            ref: ref,
            linking: memoizedLinking,
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(Component, {})
        }));
    }
    return /*#__PURE__*/ React.forwardRef(Navigation);
} //# sourceMappingURL=createStaticNavigation.js.map


}),
26158: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _to_array = __webpack_require__(32780);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.extractPathFromURL = extractPathFromURL;
var _escapeStringRegexp = _interopRequireDefault(__webpack_require__(82063));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
function extractPathFromURL(prefixes, url) {
    for (var prefix of prefixes){
        var _prefix_match;
        var protocol = ((_prefix_match = prefix.match(/^[^:]+:/)) === null || _prefix_match === void 0 ? void 0 : _prefix_match[0]) ?? '';
        var host = prefix.replace(new RegExp(`^${(0, _escapeStringRegexp.default)(protocol)}`), '').replace(/\/+/g, '/') // Replace multiple slash (//) with single ones
        .replace(/^\//, ''); // Remove extra leading slash
        var prefixRegex = new RegExp(`^${(0, _escapeStringRegexp.default)(protocol)}(/)*${host.split('.').map((it)=>it === '*' ? '[^/]+' : (0, _escapeStringRegexp.default)(it)).join('\\.')}`);
        var _url_split = _to_array._(url.split('?')), originAndPath = _url_split[0], searchParams = _url_split.slice(1);
        var normalizedURL = originAndPath.replace(/\/+/g, '/').concat(searchParams.length ? `?${searchParams.join('?')}` : '');
        if (prefixRegex.test(normalizedURL)) {
            return normalizedURL.replace(prefixRegex, '');
        }
    }
    return undefined;
} //# sourceMappingURL=extractPathFromURL.js.map


}),
28868: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _exportNames = {
    createStaticNavigation: true,
    Link: true,
    LinkingContext: true,
    LocaleDirContext: true,
    NavigationContainer: true,
    ServerContainer: true,
    DarkTheme: true,
    DefaultTheme: true,
    UNSTABLE_UnhandledLinkingContext: true,
    useLinkBuilder: true,
    useLinkProps: true,
    useLinkTo: true,
    useLocale: true,
    useScrollToTop: true
};
Object.defineProperty(exports, "DarkTheme", ({
    enumerable: true,
    get: function() {
        return _DarkTheme.DarkTheme;
    }
}));
Object.defineProperty(exports, "DefaultTheme", ({
    enumerable: true,
    get: function() {
        return _DefaultTheme.DefaultTheme;
    }
}));
Object.defineProperty(exports, "Link", ({
    enumerable: true,
    get: function() {
        return _Link.Link;
    }
}));
Object.defineProperty(exports, "LinkingContext", ({
    enumerable: true,
    get: function() {
        return _LinkingContext.LinkingContext;
    }
}));
Object.defineProperty(exports, "LocaleDirContext", ({
    enumerable: true,
    get: function() {
        return _LocaleDirContext.LocaleDirContext;
    }
}));
Object.defineProperty(exports, "NavigationContainer", ({
    enumerable: true,
    get: function() {
        return _NavigationContainer.NavigationContainer;
    }
}));
Object.defineProperty(exports, "ServerContainer", ({
    enumerable: true,
    get: function() {
        return _ServerContainer.ServerContainer;
    }
}));
Object.defineProperty(exports, "UNSTABLE_UnhandledLinkingContext", ({
    enumerable: true,
    get: function() {
        return _UnhandledLinkingContext.UnhandledLinkingContext;
    }
}));
Object.defineProperty(exports, "createStaticNavigation", ({
    enumerable: true,
    get: function() {
        return _createStaticNavigation.createStaticNavigation;
    }
}));
Object.defineProperty(exports, "useLinkBuilder", ({
    enumerable: true,
    get: function() {
        return _useLinkBuilder.useLinkBuilder;
    }
}));
Object.defineProperty(exports, "useLinkProps", ({
    enumerable: true,
    get: function() {
        return _useLinkProps.useLinkProps;
    }
}));
Object.defineProperty(exports, "useLinkTo", ({
    enumerable: true,
    get: function() {
        return _useLinkTo.useLinkTo;
    }
}));
Object.defineProperty(exports, "useLocale", ({
    enumerable: true,
    get: function() {
        return _useLocale.useLocale;
    }
}));
Object.defineProperty(exports, "useScrollToTop", ({
    enumerable: true,
    get: function() {
        return _useScrollToTop.useScrollToTop;
    }
}));
var _createStaticNavigation = __webpack_require__(16036);
var _Link = __webpack_require__(90644);
var _LinkingContext = __webpack_require__(6616);
var _LocaleDirContext = __webpack_require__(27072);
var _NavigationContainer = __webpack_require__(63508);
var _ServerContainer = __webpack_require__(11090);
var _DarkTheme = __webpack_require__(49323);
var _DefaultTheme = __webpack_require__(19644);
var _types = __webpack_require__(2934);
Object.keys(_types).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _types[key];
        }
    });
});
var _UnhandledLinkingContext = __webpack_require__(49981);
var _useLinkBuilder = __webpack_require__(33773);
var _useLinkProps = __webpack_require__(79585);
var _useLinkTo = __webpack_require__(76859);
var _useLocale = __webpack_require__(85007);
var _useScrollToTop = __webpack_require__(34730);
var _core = __webpack_require__(1519);
Object.keys(_core).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _core[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _core[key];
        }
    });
}); //# sourceMappingURL=index.js.map


}),
49323: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DarkTheme = void 0;
var _fonts = __webpack_require__(75793);
var DarkTheme = exports.DarkTheme = {
    dark: true,
    colors: {
        primary: 'rgb(10, 132, 255)',
        background: 'rgb(1, 1, 1)',
        card: 'rgb(18, 18, 18)',
        text: 'rgb(229, 229, 231)',
        border: 'rgb(39, 39, 41)',
        notification: 'rgb(255, 69, 58)'
    },
    fonts: _fonts.fonts
}; //# sourceMappingURL=DarkTheme.js.map


}),
19644: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DefaultTheme = void 0;
var _fonts = __webpack_require__(75793);
var DefaultTheme = exports.DefaultTheme = {
    dark: false,
    colors: {
        primary: 'rgb(0, 122, 255)',
        background: 'rgb(242, 242, 242)',
        card: 'rgb(255, 255, 255)',
        text: 'rgb(28, 28, 30)',
        border: 'rgb(216, 216, 216)',
        notification: 'rgb(255, 59, 48)'
    },
    fonts: _fonts.fonts
}; //# sourceMappingURL=DefaultTheme.js.map


}),
75793: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fonts = void 0;
var _reactNative = __webpack_require__(38160);
var WEB_FONT_STACK = 'system-ui, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"';
var fonts = exports.fonts = _reactNative.Platform.select({
    web: {
        regular: {
            fontFamily: WEB_FONT_STACK,
            fontWeight: '400'
        },
        medium: {
            fontFamily: WEB_FONT_STACK,
            fontWeight: '500'
        },
        bold: {
            fontFamily: WEB_FONT_STACK,
            fontWeight: '600'
        },
        heavy: {
            fontFamily: WEB_FONT_STACK,
            fontWeight: '700'
        }
    },
    ios: {
        regular: {
            fontFamily: 'System',
            fontWeight: '400'
        },
        medium: {
            fontFamily: 'System',
            fontWeight: '500'
        },
        bold: {
            fontFamily: 'System',
            fontWeight: '600'
        },
        heavy: {
            fontFamily: 'System',
            fontWeight: '700'
        }
    },
    default: {
        regular: {
            fontFamily: 'sans-serif',
            fontWeight: 'normal'
        },
        medium: {
            fontFamily: 'sans-serif-medium',
            fontWeight: 'normal'
        },
        bold: {
            fontFamily: 'sans-serif',
            fontWeight: '600'
        },
        heavy: {
            fontFamily: 'sans-serif',
            fontWeight: '700'
        }
    }
}); //# sourceMappingURL=fonts.js.map


}),
2934: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=types.js.map


}),
69334: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useBackButton = useBackButton;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _reactNative = __webpack_require__(38160);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useBackButton(ref) {
    React.useEffect(()=>{
        var subscription = _reactNative.BackHandler.addEventListener('hardwareBackPress', ()=>{
            var navigation = ref.current;
            if (navigation == null) {
                return false;
            }
            if (navigation.canGoBack()) {
                navigation.goBack();
                return true;
            }
            return false;
        });
        return ()=>subscription.remove();
    }, [
        ref
    ]);
} //# sourceMappingURL=useBackButton.native.js.map


}),
95429: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useDocumentTitle = useDocumentTitle;
// eslint-disable-next-line @eslint-react/hooks-extra/ensure-custom-hooks-using-other-hooks
function useDocumentTitle() {
// Noop for native platforms
} //# sourceMappingURL=useDocumentTitle.native.js.map


}),
33773: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLinkBuilder = useLinkBuilder;
var _core = __webpack_require__(1519);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _LinkingContext = __webpack_require__(6616);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var getRootStateForNavigate = (navigation, state)=>{
    var parent = navigation.getParent();
    if (parent) {
        var parentState = parent.getState();
        return getRootStateForNavigate(parent, {
            index: 0,
            routes: [
                _object_spread_props._(_object_spread._({}, parentState.routes[parentState.index]), {
                    state: state
                })
            ]
        });
    }
    return state;
};
/**
 * Helpers to build href or action based on the linking options.
 * @returns `buildHref` to build an `href` for screen and `buildAction` to build an action from an `href`.
 */ function useLinkBuilder() {
    var navigation = React.useContext(_core.NavigationHelpersContext);
    var linking = React.useContext(_LinkingContext.LinkingContext);
    var buildHref = React.useCallback((name, params)=>{
        var options = linking.options;
        if ((options === null || options === void 0 ? void 0 : options.enabled) === false) {
            return undefined;
        }
        var state = navigation ? getRootStateForNavigate(navigation, {
            index: 0,
            routes: [
                {
                    name,
                    params
                }
            ]
        }) : // If we couldn't find a navigation object in context, we're at root
        // So we'll construct a basic state object to use
        {
            index: 0,
            routes: [
                {
                    name,
                    params
                }
            ]
        };
        var path = (options === null || options === void 0 ? void 0 : options.getPathFromState) ? options.getPathFromState(state, options === null || options === void 0 ? void 0 : options.config) : (0, _core.getPathFromState)(state, options === null || options === void 0 ? void 0 : options.config);
        return path;
    }, [
        linking,
        navigation
    ]);
    var buildAction = React.useCallback((href)=>{
        if (!href.startsWith('/')) {
            throw new Error(`The href must start with '/' (${href}).`);
        }
        var options = linking.options;
        var state = (options === null || options === void 0 ? void 0 : options.getStateFromPath) ? options.getStateFromPath(href, options.config) : (0, _core.getStateFromPath)(href, options === null || options === void 0 ? void 0 : options.config);
        if (state) {
            var action = (0, _core.getActionFromState)(state, options === null || options === void 0 ? void 0 : options.config);
            return action ?? _core.CommonActions.reset(state);
        } else {
            throw new Error('Failed to parse the href to a navigation state.');
        }
    }, [
        linking
    ]);
    return {
        buildHref,
        buildAction
    };
} //# sourceMappingURL=useLinkBuilder.js.map


}),
79585: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLinkProps = useLinkProps;
var _core = __webpack_require__(1519);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _reactNative = __webpack_require__(38160);
var _LinkingContext = __webpack_require__(6616);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var getStateFromParams = (params)=>{
    if (params === null || params === void 0 ? void 0 : params.state) {
        return params.state;
    }
    if (params === null || params === void 0 ? void 0 : params.screen) {
        return {
            routes: [
                {
                    name: params.screen,
                    params: params.params,
                    // @ts-expect-error this is fine 
                    state: params.screen ? getStateFromParams(params.params) : undefined
                }
            ]
        };
    }
    return undefined;
};
/**
 * Hook to get props for an anchor tag so it can work with in page navigation.
 *
 * @param props.screen Name of the screen to navigate to (e.g. `'Feeds'`).
 * @param props.params Params to pass to the screen to navigate to (e.g. `{ sort: 'hot' }`).
 * @param props.href Optional absolute path to use for the href (e.g. `/feeds/hot`).
 * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.
 */ function useLinkProps(ref) {
    var screen = ref.screen, params = ref.params, href = ref.href, action = ref.action;
    var root = React.useContext(_core.NavigationContainerRefContext);
    var navigation = React.useContext(_core.NavigationHelpersContext);
    var options = React.useContext(_LinkingContext.LinkingContext).options;
    var onPress = (e)=>{
        var // @ts-expect-error: these properties exist on web, but not in React Native
        _e_currentTarget;
        // @ts-expect-error: these properties exist on web, but not in React Native
        var hasModifierKey = e.metaKey || e.altKey || e.ctrlKey || e.shiftKey; // ignore clicks with modifier keys
        // @ts-expect-error: these properties exist on web, but not in React Native
        var isLeftClick = e.button == null || e.button === 0; // only handle left clicks
        var isSelfTarget = [
            undefined,
            null,
            '',
            'self'
        ].includes((_e_currentTarget = e.currentTarget) === null || _e_currentTarget === void 0 ? void 0 : _e_currentTarget.target); // let browser handle "target=_blank" etc.
        var shouldHandle = false;
        if (_reactNative.Platform.OS !== 'web' || !e) {
            shouldHandle = true;
        } else if (!hasModifierKey && isLeftClick && isSelfTarget) {
            e.preventDefault();
            shouldHandle = true;
        }
        if (shouldHandle) {
            if (action) {
                if (navigation) {
                    navigation.dispatch(action);
                } else if (root) {
                    root.dispatch(action);
                } else {
                    throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
                }
            } else {
                // @ts-expect-error This is already type-checked by the prop types
                navigation === null || navigation === void 0 ? void 0 : navigation.navigate(screen, params);
            }
        }
    };
    var getPathFromStateHelper = (options === null || options === void 0 ? void 0 : options.getPathFromState) ?? _core.getPathFromState;
    return {
        href: href ?? (_reactNative.Platform.OS === 'web' && screen != null ? getPathFromStateHelper({
            routes: [
                {
                    // @ts-expect-error this is fine 
                    name: screen,
                    // @ts-expect-error this is fine 
                    params: params,
                    // @ts-expect-error this is fine 
                    state: getStateFromParams(params)
                }
            ]
        }, options === null || options === void 0 ? void 0 : options.config) : undefined),
        accessibilityRole: 'link',
        onPress
    };
} //# sourceMappingURL=useLinkProps.js.map


}),
76859: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLinkTo = useLinkTo;
var _core = __webpack_require__(1519);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _useLinkBuilder = __webpack_require__(33773);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Helper to navigate to a screen using a href based on the linking options.
 * @returns function that receives the href to navigate to.
 */ function useLinkTo() {
    var navigation = React.useContext(_core.NavigationContainerRefContext);
    var buildAction = (0, _useLinkBuilder.useLinkBuilder)().buildAction;
    var linkTo = React.useCallback((href)=>{
        if (navigation === undefined) {
            throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
        }
        var action = buildAction(href);
        navigation.dispatch(action);
    }, [
        buildAction,
        navigation
    ]);
    return linkTo;
} //# sourceMappingURL=useLinkTo.js.map


}),
19748: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLinking = useLinking;
var _core = __webpack_require__(1519);
var React = _interopRequireWildcard(__webpack_require__(92888));
var _reactNative = __webpack_require__(38160);
var _extractPathFromURL = __webpack_require__(26158);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var linkingHandlers = [];
function useLinking(ref, ref1, onUnhandledLinking) {
    var _ref_enabled = ref1.enabled, enabled = _ref_enabled === void 0 ? true : _ref_enabled, prefixes = ref1.prefixes, filter = ref1.filter, config = ref1.config, _ref_getInitialURL = ref1.getInitialURL, getInitialURL = _ref_getInitialURL === void 0 ? ()=>Promise.race([
            _reactNative.Linking.getInitialURL(),
            new Promise((resolve)=>{
                // Timeout in 150ms if `getInitialState` doesn't resolve
                // Workaround for https://github.com/facebook/react-native/issues/25675
                setTimeout(resolve, 150);
            })
        ]) : _ref_getInitialURL, _ref_subscribe = ref1.subscribe, subscribe = _ref_subscribe === void 0 ? (listener)=>{
        var _reactNative_Linking_removeEventListener;
        var callback = (ref)=>{
            var url = ref.url;
            return listener(url);
        };
        var subscription = _reactNative.Linking.addEventListener('url', callback);
        // Storing this in a local variable stops Jest from complaining about import after teardown
        // @ts-expect-error: removeEventListener is not present in newer RN versions
        var removeEventListener = (_reactNative_Linking_removeEventListener = _reactNative.Linking.removeEventListener) === null || _reactNative_Linking_removeEventListener === void 0 ? void 0 : _reactNative_Linking_removeEventListener.bind(_reactNative.Linking);
        return ()=>{
            // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7
            if (subscription === null || subscription === void 0 ? void 0 : subscription.remove) {
                subscription.remove();
            } else {
                removeEventListener === null || removeEventListener === void 0 ? void 0 : removeEventListener('url', callback);
            }
        };
    } : _ref_subscribe, _ref_getStateFromPath = ref1.getStateFromPath, getStateFromPath = _ref_getStateFromPath === void 0 ? _core.getStateFromPath : _ref_getStateFromPath, _ref_getActionFromState = ref1.getActionFromState, getActionFromState = _ref_getActionFromState === void 0 ? _core.getActionFromState : _ref_getActionFromState;
    var independent = (0, _core.useNavigationIndependentTree)();
    React.useEffect(()=>{
        if (true) {
            return undefined;
        }
        if (independent) {
            return undefined;
        }
        if (enabled !== false && linkingHandlers.length) {
            console.error([
                'Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:',
                "- You don't have multiple NavigationContainers in the app each with 'linking' enabled",
                '- Only a single instance of the root component is rendered',
                _reactNative.Platform.OS === 'android' ? "- You have set 'android:launchMode=singleTask' in the '<activity />' section of the 'AndroidManifest.xml' file to avoid launching multiple instances" : ''
            ].join('\n').trim());
        }
        var handler = Symbol();
        if (enabled !== false) {
            linkingHandlers.push(handler);
        }
        return ()=>{
            var index = linkingHandlers.indexOf(handler);
            if (index > -1) {
                linkingHandlers.splice(index, 1);
            }
        };
    }, [
        enabled,
        independent
    ]);
    // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners
    // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`
    // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect
    var enabledRef = React.useRef(enabled);
    var prefixesRef = React.useRef(prefixes);
    var filterRef = React.useRef(filter);
    var configRef = React.useRef(config);
    var getInitialURLRef = React.useRef(getInitialURL);
    var getStateFromPathRef = React.useRef(getStateFromPath);
    var getActionFromStateRef = React.useRef(getActionFromState);
    React.useEffect(()=>{
        enabledRef.current = enabled;
        prefixesRef.current = prefixes;
        filterRef.current = filter;
        configRef.current = config;
        getInitialURLRef.current = getInitialURL;
        getStateFromPathRef.current = getStateFromPath;
        getActionFromStateRef.current = getActionFromState;
    });
    var getStateFromURL = React.useCallback((url)=>{
        if (!url || filterRef.current && !filterRef.current(url)) {
            return undefined;
        }
        var path = (0, _extractPathFromURL.extractPathFromURL)(prefixesRef.current, url);
        return path !== undefined ? getStateFromPathRef.current(path, configRef.current) : undefined;
    }, []);
    var getInitialState = React.useCallback(()=>{
        var state;
        if (enabledRef.current) {
            var url = getInitialURLRef.current();
            if (url != null) {
                if (typeof url !== 'string') {
                    return url.then((url)=>{
                        var state = getStateFromURL(url);
                        if (typeof url === 'string') {
                            // If the link were handled, it gets cleared in NavigationContainer
                            onUnhandledLinking((0, _extractPathFromURL.extractPathFromURL)(prefixes, url));
                        }
                        return state;
                    });
                } else {
                    onUnhandledLinking((0, _extractPathFromURL.extractPathFromURL)(prefixes, url));
                }
            }
            state = getStateFromURL(url);
        }
        var thenable = {
            then (onfulfilled) {
                return Promise.resolve(onfulfilled ? onfulfilled(state) : state);
            },
            catch () {
                return thenable;
            }
        };
        return thenable;
    }, [
        getStateFromURL,
        onUnhandledLinking,
        prefixes
    ]);
    React.useEffect(()=>{
        var listener = (url)=>{
            if (!enabled) {
                return;
            }
            var navigation = ref.current;
            var state = navigation ? getStateFromURL(url) : undefined;
            if (navigation && state) {
                // If the link were handled, it gets cleared in NavigationContainer
                onUnhandledLinking((0, _extractPathFromURL.extractPathFromURL)(prefixes, url));
                var rootState = navigation.getRootState();
                if (state.routes.some((r)=>!(rootState === null || rootState === void 0 ? void 0 : rootState.routeNames.includes(r.name)))) {
                    return;
                }
                var action = getActionFromStateRef.current(state, configRef.current);
                if (action !== undefined) {
                    try {
                        navigation.dispatch(action);
                    } catch (e) {
                        // Ignore any errors from deep linking.
                        // This could happen in case of malformed links, navigation object not being initialized etc.
                        console.warn(`An error occurred when trying to handle the link '${url}': ${typeof e === 'object' && e != null && 'message' in e ? e.message : e}`);
                    }
                } else {
                    navigation.resetRoot(state);
                }
            }
        };
        return subscribe(listener);
    }, [
        enabled,
        getStateFromURL,
        onUnhandledLinking,
        prefixes,
        ref,
        subscribe
    ]);
    return {
        getInitialState
    };
} //# sourceMappingURL=useLinking.native.js.map


}),
85007: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useLocale = useLocale;
var React = _interopRequireWildcard(__webpack_require__(92888));
var _LocaleDirContext = __webpack_require__(27072);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
/**
 * Hook to access the text direction specified in the `NavigationContainer`.
 */ function useLocale() {
    var direction = React.useContext(_LocaleDirContext.LocaleDirContext);
    if (direction === undefined) {
        throw new Error("Couldn't determine the text direction. Is your component inside NavigationContainer?");
    }
    return {
        direction
    };
} //# sourceMappingURL=useLocale.js.map


}),
34730: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useScrollToTop = useScrollToTop;
var _core = __webpack_require__(1519);
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function getScrollableNode(ref) {
    if (ref.current == null) {
        return null;
    }
    if ('scrollToTop' in ref.current || 'scrollTo' in ref.current || 'scrollToOffset' in ref.current || 'scrollResponderScrollTo' in ref.current) {
        // This is already a scrollable node.
        return ref.current;
    } else if ('getScrollResponder' in ref.current) {
        // If the view is a wrapper like FlatList, SectionList etc.
        // We need to use `getScrollResponder` to get access to the scroll responder
        return ref.current.getScrollResponder();
    } else if ('getNode' in ref.current) {
        // When a `ScrollView` is wrapped in `Animated.createAnimatedComponent`
        // we need to use `getNode` to get the ref to the actual scrollview.
        // Note that `getNode` is deprecated in newer versions of react-native
        // this is why we check if we already have a scrollable node above.
        return ref.current.getNode();
    } else {
        return ref.current;
    }
}
function useScrollToTop(ref) {
    var navigation = React.useContext(_core.NavigationContext);
    var route = (0, _core.useRoute)();
    if (navigation === undefined) {
        throw new Error("Couldn't find a navigation object. Is your component inside NavigationContainer?");
    }
    React.useEffect(()=>{
        var tabNavigations = [];
        var currentNavigation = navigation;
        // If the screen is nested inside multiple tab navigators, we should scroll to top for any of them
        // So we need to find all the parent tab navigators and add the listeners there
        while(currentNavigation){
            if (currentNavigation.getState().type === 'tab') {
                tabNavigations.push(currentNavigation);
            }
            currentNavigation = currentNavigation.getParent();
        }
        if (tabNavigations.length === 0) {
            return;
        }
        var unsubscribers = tabNavigations.map((tab)=>{
            return tab.addListener(// We don't wanna import tab types here to avoid extra deps
            // in addition, there are multiple tab implementations
            // @ts-expect-error the `tabPress` event is only available when navigation type is tab
            'tabPress', (e)=>{
                // We should scroll to top only when the screen is focused
                var isFocused = navigation.isFocused();
                // In a nested stack navigator, tab press resets the stack to first screen
                // So we should scroll to top only when we are on first screen
                var isFirst = tabNavigations.includes(navigation) || navigation.getState().routes[0].key === route.key;
                // Run the operation in the next frame so we're sure all listeners have been run
                // This is necessary to know if preventDefault() has been called
                requestAnimationFrame(()=>{
                    var scrollable = getScrollableNode(ref);
                    if (isFocused && isFirst && scrollable && !e.defaultPrevented) {
                        if ('scrollToTop' in scrollable) {
                            scrollable.scrollToTop();
                        } else if ('scrollTo' in scrollable) {
                            scrollable.scrollTo({
                                y: 0,
                                animated: true
                            });
                        } else if ('scrollToOffset' in scrollable) {
                            scrollable.scrollToOffset({
                                offset: 0,
                                animated: true
                            });
                        } else if ('scrollResponderScrollTo' in scrollable) {
                            scrollable.scrollResponderScrollTo({
                                y: 0,
                                animated: true
                            });
                        }
                    }
                });
            });
        });
        return ()=>{
            unsubscribers.forEach((unsubscribe)=>unsubscribe());
        };
    }, [
        navigation,
        ref,
        route.key
    ]);
} //# sourceMappingURL=useScrollToTop.js.map


}),
75234: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _async_to_generator = __webpack_require__(12807);
var _sliced_to_array = __webpack_require__(17738);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useThenable = useThenable;
var React = _interopRequireWildcard(__webpack_require__(92888));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useThenable(create) {
    var _React_useState = _sliced_to_array._(React.useState(create), 1), promise = _React_useState[0];
    var initialState = [
        false,
        undefined
    ];
    // Check if our thenable is synchronous
    // eslint-disable-next-line promise/catch-or-return, promise/always-return
    promise.then((result)=>{
        initialState = [
            true,
            result
        ];
    });
    var _React_useState1 = _sliced_to_array._(React.useState(initialState), 2), state = _React_useState1[0], setState = _React_useState1[1];
    var _state = _sliced_to_array._(state, 1), resolved = _state[0];
    React.useEffect(()=>{
        var cancelled = false;
        var resolve = /*#__PURE__*/ function() {
            var _ref = _async_to_generator._(function*() {
                var result;
                try {
                    result = yield promise;
                } finally{
                    if (!cancelled) {
                        setState([
                            true,
                            result
                        ]);
                    }
                }
            });
            return function resolve() {
                return _ref.apply(this, arguments);
            };
        }();
        if (!resolved) {
            resolve();
        }
        return ()=>{
            cancelled = true;
        };
    }, [
        promise,
        resolved
    ]);
    return state;
} //# sourceMappingURL=useThenable.js.map


}),
10369: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.BaseRouter = void 0;
var _nonSecure = __webpack_require__(78803);
/**
 * Base router object that can be used when writing custom routers.
 * This provides few helper methods to handle common actions such as `RESET`.
 */ var BaseRouter = exports.BaseRouter = {
    getStateForAction (state, action) {
        switch(action.type){
            case 'SET_PARAMS':
                {
                    var index = action.source ? state.routes.findIndex((r)=>r.key === action.source) : state.index;
                    if (index === -1) {
                        return null;
                    }
                    return _object_spread_props._(_object_spread._({}, state), {
                        routes: state.routes.map((r, i)=>i === index ? _object_spread_props._(_object_spread._({}, r), {
                                params: _object_spread._({}, r.params, action.payload.params)
                            }) : r)
                    });
                }
            case 'RESET':
                {
                    var nextState = action.payload;
                    if (nextState.routes.length === 0 || nextState.routes.some((route)=>!state.routeNames.includes(route.name))) {
                        return null;
                    }
                    if (nextState.stale === false) {
                        if (state.routeNames.length !== nextState.routeNames.length || nextState.routeNames.some((name)=>!state.routeNames.includes(name))) {
                            return null;
                        }
                        return _object_spread_props._(_object_spread._({}, nextState), {
                            routes: nextState.routes.map((route)=>route.key ? route : _object_spread_props._(_object_spread._({}, route), {
                                    key: `${route.name}-${(0, _nonSecure.nanoid)()}`
                                }))
                        });
                    }
                    return nextState;
                }
            default:
                return null;
        }
    },
    shouldActionChangeFocus (action) {
        return action.type === 'NAVIGATE' || action.type === 'NAVIGATE_DEPRECATED';
    }
}; //# sourceMappingURL=BaseRouter.js.map


}),
64563: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(17738);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.goBack = goBack;
exports.navigate = navigate;
exports.navigateDeprecated = navigateDeprecated;
exports.preload = preload;
exports.reset = reset;
exports.setParams = setParams;
function goBack() {
    return {
        type: 'GO_BACK'
    };
}
function navigate(...args) {
    if (typeof args[0] === 'string') {
        var _args = _sliced_to_array._(args, 3), name = _args[0], params = _args[1], merge = _args[2];
        return {
            type: 'NAVIGATE',
            payload: {
                name,
                params,
                merge
            }
        };
    } else {
        var payload = args[0] || {};
        if (!('name' in payload)) {
            throw new Error('You need to specify a name when calling navigate with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigate for usage.');
        }
        return {
            type: 'NAVIGATE',
            payload
        };
    }
}
function navigateDeprecated(...args) {
    if (typeof args[0] === 'string') {
        return {
            type: 'NAVIGATE_DEPRECATED',
            payload: {
                name: args[0],
                params: args[1]
            }
        };
    } else {
        var payload = args[0] || {};
        if (!('name' in payload)) {
            throw new Error('You need to specify a name when calling navigate with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigatelegacy for usage.');
        }
        return {
            type: 'NAVIGATE_DEPRECATED',
            payload
        };
    }
}
function reset(state) {
    return {
        type: 'RESET',
        payload: state
    };
}
function setParams(params) {
    return {
        type: 'SET_PARAMS',
        payload: {
            params
        }
    };
}
function preload(name, params) {
    return {
        type: 'PRELOAD',
        payload: {
            name,
            params
        }
    };
} //# sourceMappingURL=CommonActions.js.map


}),
81490: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _object_without_properties = __webpack_require__(45922);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DrawerActions = void 0;
exports.DrawerRouter = DrawerRouter;
var _nonSecure = __webpack_require__(78803);
var _TabRouter = __webpack_require__(53218);
var DrawerActions = exports.DrawerActions = _object_spread_props._(_object_spread._({}, _TabRouter.TabActions), {
    openDrawer () {
        return {
            type: 'OPEN_DRAWER'
        };
    },
    closeDrawer () {
        return {
            type: 'CLOSE_DRAWER'
        };
    },
    toggleDrawer () {
        return {
            type: 'TOGGLE_DRAWER'
        };
    }
});
function DrawerRouter(_param) {
    var _param_defaultStatus = _param.defaultStatus, defaultStatus = _param_defaultStatus === void 0 ? 'closed' : _param_defaultStatus, rest = _object_without_properties._(_param, [
        "defaultStatus"
    ]);
    var router = (0, _TabRouter.TabRouter)(rest);
    var isDrawerInHistory = (state)=>{
        var _state_history;
        return Boolean((_state_history = state.history) === null || _state_history === void 0 ? void 0 : _state_history.some((it)=>it.type === 'drawer'));
    };
    var addDrawerToHistory = (state)=>{
        if (isDrawerInHistory(state)) {
            return state;
        }
        return _object_spread_props._(_object_spread._({}, state), {
            history: _to_consumable_array._(state.history).concat([
                {
                    type: 'drawer',
                    status: defaultStatus === 'open' ? 'closed' : 'open'
                }
            ])
        });
    };
    var removeDrawerFromHistory = (state)=>{
        if (!isDrawerInHistory(state)) {
            return state;
        }
        return _object_spread_props._(_object_spread._({}, state), {
            history: state.history.filter((it)=>it.type !== 'drawer')
        });
    };
    var openDrawer = (state)=>{
        if (defaultStatus === 'open') {
            return removeDrawerFromHistory(state);
        }
        return addDrawerToHistory(state);
    };
    var closeDrawer = (state)=>{
        if (defaultStatus === 'open') {
            return addDrawerToHistory(state);
        }
        return removeDrawerFromHistory(state);
    };
    return _object_spread_props._(_object_spread._({}, router), {
        type: 'drawer',
        getInitialState (ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeGetIdList = ref.routeGetIdList;
            var state = router.getInitialState({
                routeNames,
                routeParamList,
                routeGetIdList
            });
            return _object_spread_props._(_object_spread._({}, state), {
                default: defaultStatus,
                stale: false,
                type: 'drawer',
                key: `drawer-${(0, _nonSecure.nanoid)()}`
            });
        },
        getRehydratedState (partialState, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeGetIdList = ref.routeGetIdList;
            if (partialState.stale === false) {
                return partialState;
            }
            var state = router.getRehydratedState(partialState, {
                routeNames,
                routeParamList,
                routeGetIdList
            });
            if (isDrawerInHistory(partialState)) {
                // Re-sync the drawer entry in history to correct it if it was wrong
                state = removeDrawerFromHistory(state);
                state = addDrawerToHistory(state);
            }
            return _object_spread_props._(_object_spread._({}, state), {
                default: defaultStatus,
                type: 'drawer',
                key: `drawer-${(0, _nonSecure.nanoid)()}`
            });
        },
        getStateForRouteFocus (state, key) {
            var result = router.getStateForRouteFocus(state, key);
            return closeDrawer(result);
        },
        getStateForAction (state, action, options) {
            switch(action.type){
                case 'OPEN_DRAWER':
                    return openDrawer(state);
                case 'CLOSE_DRAWER':
                    return closeDrawer(state);
                case 'TOGGLE_DRAWER':
                    if (isDrawerInHistory(state)) {
                        return removeDrawerFromHistory(state);
                    }
                    return addDrawerToHistory(state);
                case 'JUMP_TO':
                case 'NAVIGATE':
                case 'NAVIGATE_DEPRECATED':
                    {
                        var result = router.getStateForAction(state, action, options);
                        if (result != null && result.index !== state.index) {
                            return closeDrawer(result);
                        }
                        return result;
                    }
                case 'GO_BACK':
                    if (isDrawerInHistory(state)) {
                        return removeDrawerFromHistory(state);
                    }
                    return router.getStateForAction(state, action, options);
                default:
                    return router.getStateForAction(state, action, options);
            }
        },
        actionCreators: DrawerActions
    });
} //# sourceMappingURL=DrawerRouter.js.map


}),
14247: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
var _to_consumable_array = __webpack_require__(58678);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.StackActions = void 0;
exports.StackRouter = StackRouter;
var _nonSecure = __webpack_require__(78803);
var _BaseRouter = __webpack_require__(10369);
var StackActions = exports.StackActions = {
    replace (name, params) {
        return {
            type: 'REPLACE',
            payload: {
                name,
                params
            }
        };
    },
    push (name, params) {
        return {
            type: 'PUSH',
            payload: {
                name,
                params
            }
        };
    },
    pop (ref) {
        var count = ref === void 0 ? 1 : ref;
        return {
            type: 'POP',
            payload: {
                count
            }
        };
    },
    popToTop () {
        return {
            type: 'POP_TO_TOP'
        };
    },
    popTo (name, params, merge) {
        return {
            type: 'POP_TO',
            payload: {
                name,
                params,
                merge
            }
        };
    }
};
function StackRouter(options) {
    var router = _object_spread_props._(_object_spread._({}, _BaseRouter.BaseRouter), {
        type: 'stack',
        getInitialState (ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
            return {
                stale: false,
                type: 'stack',
                key: `stack-${(0, _nonSecure.nanoid)()}`,
                index: 0,
                routeNames,
                preloadedRoutes: [],
                routes: [
                    {
                        key: `${initialRouteName}-${(0, _nonSecure.nanoid)()}`,
                        name: initialRouteName,
                        params: routeParamList[initialRouteName]
                    }
                ]
            };
        },
        getRehydratedState (partialState, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var _state_preloadedRoutes;
            var state = partialState;
            if (state.stale === false) {
                return state;
            }
            var routes = state.routes.filter((route)=>routeNames.includes(route.name)).map((route)=>_object_spread_props._(_object_spread._({}, route), {
                    key: route.key || `${route.name}-${(0, _nonSecure.nanoid)()}`,
                    params: routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], route.params) : route.params
                }));
            var preloadedRoutes = ((_state_preloadedRoutes = state.preloadedRoutes) === null || _state_preloadedRoutes === void 0 ? void 0 : _state_preloadedRoutes.filter((route)=>routeNames.includes(route.name)).map((route)=>_object_spread_props._(_object_spread._({}, route), {
                    key: route.key || `${route.name}-${(0, _nonSecure.nanoid)()}`,
                    params: routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], route.params) : route.params
                }))) ?? [];
            if (routes.length === 0) {
                var initialRouteName = options.initialRouteName !== undefined ? options.initialRouteName : routeNames[0];
                routes.push({
                    key: `${initialRouteName}-${(0, _nonSecure.nanoid)()}`,
                    name: initialRouteName,
                    params: routeParamList[initialRouteName]
                });
            }
            return {
                stale: false,
                type: 'stack',
                key: `stack-${(0, _nonSecure.nanoid)()}`,
                index: routes.length - 1,
                routeNames,
                routes,
                preloadedRoutes
            };
        },
        getStateForRouteNamesChange (state, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeKeyChanges = ref.routeKeyChanges;
            var routes = state.routes.filter((route)=>routeNames.includes(route.name) && !routeKeyChanges.includes(route.name));
            if (routes.length === 0) {
                var initialRouteName = options.initialRouteName !== undefined && routeNames.includes(options.initialRouteName) ? options.initialRouteName : routeNames[0];
                routes.push({
                    key: `${initialRouteName}-${(0, _nonSecure.nanoid)()}`,
                    name: initialRouteName,
                    params: routeParamList[initialRouteName]
                });
            }
            return _object_spread_props._(_object_spread._({}, state), {
                routeNames,
                routes,
                index: Math.min(state.index, routes.length - 1)
            });
        },
        getStateForRouteFocus (state, key) {
            var index = state.routes.findIndex((r)=>r.key === key);
            if (index === -1 || index === state.index) {
                return state;
            }
            return _object_spread_props._(_object_spread._({}, state), {
                index,
                routes: state.routes.slice(0, index + 1)
            });
        },
        getStateForAction (state, action, options) {
            var routeParamList = options.routeParamList;
            switch(action.type){
                case 'REPLACE':
                    {
                        var index = action.target === state.key && action.source ? state.routes.findIndex((r)=>r.key === action.source) : state.index;
                        if (index === -1) {
                            return null;
                        }
                        var _action_payload = action.payload, name = _action_payload.name, params = _action_payload.params;
                        if (!state.routeNames.includes(name)) {
                            return null;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            routes: state.routes.map((route, i)=>i === index ? {
                                    key: `${name}-${(0, _nonSecure.nanoid)()}`,
                                    name,
                                    params: routeParamList[name] !== undefined ? _object_spread._({}, routeParamList[name], params) : params
                                } : route)
                        });
                    }
                case 'PUSH':
                case 'NAVIGATE':
                    {
                        if (!state.routeNames.includes(action.payload.name)) {
                            return null;
                        }
                        var getId = options.routeGetIdList[action.payload.name];
                        var id = getId === null || getId === void 0 ? void 0 : getId({
                            params: action.payload.params
                        });
                        var route;
                        if (id !== undefined) {
                            route = state.routes.find((route)=>route.name === action.payload.name && id === (getId === null || getId === void 0 ? void 0 : getId({
                                    params: route.params
                                })));
                        } else {
                            var currentRoute = state.routes[state.index];
                            // If the route matches the current one, then navigate to it
                            if (action.type === 'NAVIGATE' && action.payload.name === currentRoute.name) {
                                route = currentRoute;
                            }
                        }
                        if (!route) {
                            route = state.preloadedRoutes.find((route)=>route.name === action.payload.name && id === (getId === null || getId === void 0 ? void 0 : getId({
                                    params: route.params
                                })));
                        }
                        var params1;
                        if (action.type === 'NAVIGATE' && action.payload.merge && route) {
                            params1 = action.payload.params !== undefined || routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], route.params, action.payload.params) : route.params;
                        } else {
                            params1 = routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params;
                        }
                        var routes;
                        if (route) {
                            var routeKey = route.key;
                            routes = state.routes.filter((r)=>r.key !== routeKey);
                            routes.push(_object_spread_props._(_object_spread._({}, route), {
                                path: action.type === 'NAVIGATE' && action.payload.path !== undefined ? action.payload.path : route.path,
                                params: params1
                            }));
                        } else {
                            routes = _to_consumable_array._(state.routes).concat([
                                {
                                    key: `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                                    name: action.payload.name,
                                    path: action.type === 'NAVIGATE' ? action.payload.path : undefined,
                                    params: params1
                                }
                            ]);
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            index: routes.length - 1,
                            preloadedRoutes: state.preloadedRoutes.filter((route)=>routes[routes.length - 1].key !== route.key),
                            routes
                        });
                    }
                case 'NAVIGATE_DEPRECATED':
                    {
                        if (state.preloadedRoutes.find((route)=>route.name === action.payload.name && id1 === (getId1 === null || getId1 === void 0 ? void 0 : getId1({
                                params: route.params
                            })))) {
                            return null;
                        }
                        if (!state.routeNames.includes(action.payload.name)) {
                            return null;
                        }
                        // If the route already exists, navigate to that
                        var index1 = -1;
                        var getId1 = options.routeGetIdList[action.payload.name];
                        var id1 = getId1 === null || getId1 === void 0 ? void 0 : getId1({
                            params: action.payload.params
                        });
                        if (id1) {
                            index1 = state.routes.findIndex((route)=>route.name === action.payload.name && id1 === (getId1 === null || getId1 === void 0 ? void 0 : getId1({
                                    params: route.params
                                })));
                        } else if (state.routes[state.index].name === action.payload.name) {
                            index1 = state.index;
                        } else {
                            for(var i = state.routes.length - 1; i >= 0; i--){
                                if (state.routes[i].name === action.payload.name) {
                                    index1 = i;
                                    break;
                                }
                            }
                        }
                        if (index1 === -1) {
                            var routes1 = _to_consumable_array._(state.routes).concat([
                                {
                                    key: `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                                    name: action.payload.name,
                                    params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                }
                            ]);
                            return _object_spread_props._(_object_spread._({}, state), {
                                routes: routes1,
                                index: routes1.length - 1
                            });
                        }
                        var route1 = state.routes[index1];
                        var params2;
                        if (action.payload.merge) {
                            params2 = action.payload.params !== undefined || routeParamList[route1.name] !== undefined ? _object_spread._({}, routeParamList[route1.name], route1.params, action.payload.params) : route1.params;
                        } else {
                            params2 = routeParamList[route1.name] !== undefined ? _object_spread._({}, routeParamList[route1.name], action.payload.params) : action.payload.params;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            index: index1,
                            routes: _to_consumable_array._(state.routes.slice(0, index1)).concat([
                                params2 !== route1.params ? _object_spread_props._(_object_spread._({}, route1), {
                                    params: params2
                                }) : state.routes[index1]
                            ])
                        });
                    }
                case 'POP':
                    {
                        var index2 = action.target === state.key && action.source ? state.routes.findIndex((r)=>r.key === action.source) : state.index;
                        if (index2 > 0) {
                            var count = Math.max(index2 - action.payload.count + 1, 1);
                            var routes2 = state.routes.slice(0, count).concat(state.routes.slice(index2 + 1));
                            return _object_spread_props._(_object_spread._({}, state), {
                                index: routes2.length - 1,
                                routes: routes2
                            });
                        }
                        return null;
                    }
                case 'POP_TO_TOP':
                    return router.getStateForAction(state, {
                        type: 'POP',
                        payload: {
                            count: state.routes.length - 1
                        }
                    }, options);
                case 'POP_TO':
                    {
                        if (!state.routeNames.includes(action.payload.name)) {
                            return null;
                        }
                        // If the route already exists, navigate to that
                        var index3 = -1;
                        var getId2 = options.routeGetIdList[action.payload.name];
                        var id2 = getId2 === null || getId2 === void 0 ? void 0 : getId2({
                            params: action.payload.params
                        });
                        if (id2) {
                            index3 = state.routes.findIndex((route)=>route.name === action.payload.name && id2 === (getId2 === null || getId2 === void 0 ? void 0 : getId2({
                                    params: route.params
                                })));
                        } else if (state.routes[state.index].name === action.payload.name) {
                            index3 = state.index;
                        } else {
                            for(var i1 = state.routes.length - 1; i1 >= 0; i1--){
                                if (state.routes[i1].name === action.payload.name) {
                                    index3 = i1;
                                    break;
                                }
                            }
                        }
                        // If the route doesn't exist, remove the current route and add the new one
                        if (index3 === -1) {
                            var routes3 = _to_consumable_array._(state.routes.slice(0, -1)).concat([
                                {
                                    key: `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                                    name: action.payload.name,
                                    params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                }
                            ]);
                            return _object_spread_props._(_object_spread._({}, state), {
                                routes: routes3,
                                index: routes3.length - 1
                            });
                        }
                        var route2 = state.routes[index3];
                        var params3;
                        if (action.payload.merge) {
                            params3 = action.payload.params !== undefined || routeParamList[route2.name] !== undefined ? _object_spread._({}, routeParamList[route2.name], route2.params, action.payload.params) : route2.params;
                        } else {
                            params3 = routeParamList[route2.name] !== undefined ? _object_spread._({}, routeParamList[route2.name], action.payload.params) : action.payload.params;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            index: index3,
                            routes: _to_consumable_array._(state.routes.slice(0, index3)).concat([
                                params3 !== route2.params ? _object_spread_props._(_object_spread._({}, route2), {
                                    params: params3
                                }) : state.routes[index3]
                            ])
                        });
                    }
                case 'GO_BACK':
                    if (state.index > 0) {
                        return router.getStateForAction(state, {
                            type: 'POP',
                            payload: {
                                count: 1
                            },
                            target: action.target,
                            source: action.source
                        }, options);
                    }
                    return null;
                case 'PRELOAD':
                    {
                        var getId3 = options.routeGetIdList[action.payload.name];
                        var id3 = getId3 === null || getId3 === void 0 ? void 0 : getId3({
                            params: action.payload.params
                        });
                        var route3;
                        if (id3 !== undefined) {
                            route3 = state.routes.find((route)=>route.name === action.payload.name && id3 === (getId3 === null || getId3 === void 0 ? void 0 : getId3({
                                    params: route.params
                                })));
                        }
                        if (route3) {
                            return _object_spread_props._(_object_spread._({}, state), {
                                routes: state.routes.map((r)=>{
                                    if (r.key !== (route3 === null || route3 === void 0 ? void 0 : route3.key)) {
                                        return r;
                                    }
                                    return _object_spread_props._(_object_spread._({}, r), {
                                        params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                    });
                                })
                            });
                        } else {
                            return _object_spread_props._(_object_spread._({}, state), {
                                preloadedRoutes: state.preloadedRoutes.filter((r)=>r.name !== action.payload.name || id3 !== (getId3 === null || getId3 === void 0 ? void 0 : getId3({
                                        params: r.params
                                    }))).concat({
                                    key: `${action.payload.name}-${(0, _nonSecure.nanoid)()}`,
                                    name: action.payload.name,
                                    params: routeParamList[action.payload.name] !== undefined ? _object_spread._({}, routeParamList[action.payload.name], action.payload.params) : action.payload.params
                                })
                            });
                        }
                    }
                default:
                    return _BaseRouter.BaseRouter.getStateForAction(state, action);
            }
        },
        actionCreators: StackActions
    });
    return router;
} //# sourceMappingURL=StackRouter.js.map


}),
53218: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(41112);
var _object_spread_props = __webpack_require__(2898);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.TabActions = void 0;
exports.TabRouter = TabRouter;
var _nonSecure = __webpack_require__(78803);
var _BaseRouter = __webpack_require__(10369);
var TYPE_ROUTE = 'route';
var TabActions = exports.TabActions = {
    jumpTo (name, params) {
        return {
            type: 'JUMP_TO',
            payload: {
                name,
                params
            }
        };
    }
};
var getRouteHistory = (routes, index, backBehavior, initialRouteName)=>{
    var history = [
        {
            type: TYPE_ROUTE,
            key: routes[index].key
        }
    ];
    var initialRouteIndex;
    switch(backBehavior){
        case 'order':
            for(var i = index; i > 0; i--){
                history.unshift({
                    type: TYPE_ROUTE,
                    key: routes[i - 1].key
                });
            }
            break;
        case 'firstRoute':
            if (index !== 0) {
                history.unshift({
                    type: TYPE_ROUTE,
                    key: routes[0].key
                });
            }
            break;
        case 'initialRoute':
            initialRouteIndex = routes.findIndex((route)=>route.name === initialRouteName);
            initialRouteIndex = initialRouteIndex === -1 ? 0 : initialRouteIndex;
            if (index !== initialRouteIndex) {
                history.unshift({
                    type: TYPE_ROUTE,
                    key: routes[initialRouteIndex].key
                });
            }
            break;
        case 'history':
            break;
    }
    return history;
};
var changeIndex = (state, index, backBehavior, initialRouteName)=>{
    var history;
    if (backBehavior === 'history') {
        var currentKey = state.routes[index].key;
        history = state.history.filter((it)=>it.type === 'route' ? it.key !== currentKey : false).concat({
            type: TYPE_ROUTE,
            key: currentKey
        });
    } else {
        history = getRouteHistory(state.routes, index, backBehavior, initialRouteName);
    }
    return _object_spread_props._(_object_spread._({}, state), {
        index,
        history
    });
};
function TabRouter(ref) {
    var initialRouteName = ref.initialRouteName, _ref_backBehavior = ref.backBehavior, backBehavior = _ref_backBehavior === void 0 ? 'firstRoute' : _ref_backBehavior;
    var router = _object_spread_props._(_object_spread._({}, _BaseRouter.BaseRouter), {
        type: 'tab',
        getInitialState (ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var index = initialRouteName !== undefined && routeNames.includes(initialRouteName) ? routeNames.indexOf(initialRouteName) : 0;
            var routes = routeNames.map((name)=>({
                    name,
                    key: `${name}-${(0, _nonSecure.nanoid)()}`,
                    params: routeParamList[name]
                }));
            var history = getRouteHistory(routes, index, backBehavior, initialRouteName);
            return {
                stale: false,
                type: 'tab',
                key: `tab-${(0, _nonSecure.nanoid)()}`,
                index,
                routeNames,
                history,
                routes,
                preloadedRouteKeys: []
            };
        },
        getRehydratedState (partialState, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList;
            var _state_routes_, _state_history, _state_preloadedRouteKeys;
            var state = partialState;
            if (state.stale === false) {
                return state;
            }
            var routes = routeNames.map((name)=>{
                var route = state.routes.find((r)=>r.name === name);
                return _object_spread_props._(_object_spread._({}, route), {
                    name,
                    key: route && route.name === name && route.key ? route.key : `${name}-${(0, _nonSecure.nanoid)()}`,
                    params: routeParamList[name] !== undefined ? _object_spread._({}, routeParamList[name], route ? route.params : undefined) : route ? route.params : undefined
                });
            });
            var index = Math.min(Math.max(routeNames.indexOf((_state_routes_ = state.routes[(state === null || state === void 0 ? void 0 : state.index) ?? 0]) === null || _state_routes_ === void 0 ? void 0 : _state_routes_.name), 0), routes.length - 1);
            var routeKeys = routes.map((route)=>route.key);
            var history = ((_state_history = state.history) === null || _state_history === void 0 ? void 0 : _state_history.filter((it)=>routeKeys.includes(it.key))) ?? [];
            return changeIndex({
                stale: false,
                type: 'tab',
                key: `tab-${(0, _nonSecure.nanoid)()}`,
                index,
                routeNames,
                history,
                routes,
                preloadedRouteKeys: ((_state_preloadedRouteKeys = state.preloadedRouteKeys) === null || _state_preloadedRouteKeys === void 0 ? void 0 : _state_preloadedRouteKeys.filter((key)=>routeKeys.includes(key))) ?? []
            }, index, backBehavior, initialRouteName);
        },
        getStateForRouteNamesChange (state, ref) {
            var routeNames = ref.routeNames, routeParamList = ref.routeParamList, routeKeyChanges = ref.routeKeyChanges;
            var routes = routeNames.map((name)=>state.routes.find((r)=>r.name === name && !routeKeyChanges.includes(r.name)) || {
                    name,
                    key: `${name}-${(0, _nonSecure.nanoid)()}`,
                    params: routeParamList[name]
                });
            var index = Math.max(0, routeNames.indexOf(state.routes[state.index].name));
            var history = state.history.filter(// Type will always be 'route' for tabs, but could be different in a router extending this (e.g. drawer)
            (it)=>it.type !== 'route' || routes.find((r)=>r.key === it.key));
            if (!history.length) {
                history = getRouteHistory(routes, index, backBehavior, initialRouteName);
            }
            return _object_spread_props._(_object_spread._({}, state), {
                history,
                routeNames,
                routes,
                index
            });
        },
        getStateForRouteFocus (state, key) {
            var index = state.routes.findIndex((r)=>r.key === key);
            if (index === -1 || index === state.index) {
                return state;
            }
            return changeIndex(state, index, backBehavior, initialRouteName);
        },
        getStateForAction (state, action, ref) {
            var routeParamList = ref.routeParamList, routeGetIdList = ref.routeGetIdList;
            switch(action.type){
                case 'JUMP_TO':
                case 'NAVIGATE':
                case 'NAVIGATE_DEPRECATED':
                    {
                        var index = state.routes.findIndex((route)=>route.name === action.payload.name);
                        if (index === -1) {
                            return null;
                        }
                        var updatedState = changeIndex(_object_spread_props._(_object_spread._({}, state), {
                            routes: state.routes.map((route)=>{
                                if (route.name !== action.payload.name) {
                                    return route;
                                }
                                var getId = routeGetIdList[route.name];
                                var currentId = getId === null || getId === void 0 ? void 0 : getId({
                                    params: route.params
                                });
                                var nextId = getId === null || getId === void 0 ? void 0 : getId({
                                    params: action.payload.params
                                });
                                var key = currentId === nextId ? route.key : `${route.name}-${(0, _nonSecure.nanoid)()}`;
                                var params;
                                if ((action.type === 'NAVIGATE' || action.type === 'NAVIGATE_DEPRECATED') && action.payload.merge && currentId === nextId) {
                                    params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], route.params, action.payload.params) : route.params;
                                } else {
                                    params = routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], action.payload.params) : action.payload.params;
                                }
                                var path = action.type === 'NAVIGATE' && action.payload.path != null ? action.payload.path : route.path;
                                return params !== route.params || path !== route.path ? _object_spread_props._(_object_spread._({}, route), {
                                    key,
                                    path,
                                    params
                                }) : route;
                            })
                        }), index, backBehavior, initialRouteName);
                        return _object_spread_props._(_object_spread._({}, updatedState), {
                            preloadedRouteKeys: updatedState.preloadedRouteKeys.filter((key)=>key !== state.routes[updatedState.index].key)
                        });
                    }
                case 'GO_BACK':
                    {
                        var _state_history_;
                        if (state.history.length === 1) {
                            return null;
                        }
                        var previousKey = (_state_history_ = state.history[state.history.length - 2]) === null || _state_history_ === void 0 ? void 0 : _state_history_.key;
                        var index1 = state.routes.findIndex((route)=>route.key === previousKey);
                        if (index1 === -1) {
                            return null;
                        }
                        return _object_spread_props._(_object_spread._({}, state), {
                            preloadedRouteKeys: state.preloadedRouteKeys.filter((key)=>key !== state.routes[index1].key),
                            history: state.history.slice(0, -1),
                            index: index1
                        });
                    }
                case 'PRELOAD':
                    {
                        var routeIndex = state.routes.findIndex((route)=>route.name === action.payload.name);
                        if (routeIndex === -1) {
                            return null;
                        }
                        var route = state.routes[routeIndex];
                        var getId = routeGetIdList[route.name];
                        var currentId = getId === null || getId === void 0 ? void 0 : getId({
                            params: route.params
                        });
                        var nextId = getId === null || getId === void 0 ? void 0 : getId({
                            params: action.payload.params
                        });
                        var key = currentId === nextId ? route.key : `${route.name}-${(0, _nonSecure.nanoid)()}`;
                        var params = action.payload.params !== undefined || routeParamList[route.name] !== undefined ? _object_spread._({}, routeParamList[route.name], action.payload.params) : undefined;
                        var newRoute = params !== route.params ? _object_spread_props._(_object_spread._({}, route), {
                            key,
                            params
                        }) : route;
                        return _object_spread_props._(_object_spread._({}, state), {
                            preloadedRouteKeys: state.preloadedRouteKeys.filter((key)=>key !== route.key).concat(newRoute.key),
                            routes: state.routes.map((route, index)=>index === routeIndex ? newRoute : route),
                            history: key === route.key ? state.history : state.history.filter((record)=>record.key !== route.key)
                        });
                    }
                default:
                    return _BaseRouter.BaseRouter.getStateForAction(state, action);
            }
        },
        actionCreators: TabActions
    });
    return router;
} //# sourceMappingURL=TabRouter.js.map


}),
38686: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _exportNames = {
    CommonActions: true,
    BaseRouter: true,
    DrawerActions: true,
    DrawerRouter: true,
    StackActions: true,
    StackRouter: true,
    TabActions: true,
    TabRouter: true
};
Object.defineProperty(exports, "BaseRouter", ({
    enumerable: true,
    get: function() {
        return _BaseRouter.BaseRouter;
    }
}));
exports.CommonActions = void 0;
Object.defineProperty(exports, "DrawerActions", ({
    enumerable: true,
    get: function() {
        return _DrawerRouter.DrawerActions;
    }
}));
Object.defineProperty(exports, "DrawerRouter", ({
    enumerable: true,
    get: function() {
        return _DrawerRouter.DrawerRouter;
    }
}));
Object.defineProperty(exports, "StackActions", ({
    enumerable: true,
    get: function() {
        return _StackRouter.StackActions;
    }
}));
Object.defineProperty(exports, "StackRouter", ({
    enumerable: true,
    get: function() {
        return _StackRouter.StackRouter;
    }
}));
Object.defineProperty(exports, "TabActions", ({
    enumerable: true,
    get: function() {
        return _TabRouter.TabActions;
    }
}));
Object.defineProperty(exports, "TabRouter", ({
    enumerable: true,
    get: function() {
        return _TabRouter.TabRouter;
    }
}));
var CommonActions = _interopRequireWildcard(__webpack_require__(64563));
exports.CommonActions = CommonActions;
var _BaseRouter = __webpack_require__(10369);
var _DrawerRouter = __webpack_require__(81490);
var _StackRouter = __webpack_require__(14247);
var _TabRouter = __webpack_require__(53218);
var _types = __webpack_require__(14935);
Object.keys(_types).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _types[key];
        }
    });
});
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
} //# sourceMappingURL=index.js.map


}),
14935: (function (__unused_webpack_module, exports) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
})); //# sourceMappingURL=types.js.map


}),
42397: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _type_of = __webpack_require__(81250);
function _to_primitive(input, hint) {
    if (_type_of._(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_type_of._(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
exports._ = _to_primitive;


}),
21903: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

var _to_primitive = __webpack_require__(42397);
var _type_of = __webpack_require__(81250);
function _to_property_key(arg) {
    var key = _to_primitive._(arg, "string");
    return _type_of._(key) === "symbol" ? key : String(key);
}
exports._ = _to_property_key;


}),
79467: (function (module) {
"use strict";

var token = '%[a-f0-9]{2}';
var singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');
var multiMatcher = new RegExp('(' + token + ')+', 'gi');
function decodeComponents(components, split) {
    try {
        // Try to decode the entire string first
        return [
            decodeURIComponent(components.join(''))
        ];
    } catch (err) {
    // Do nothing
    }
    if (components.length === 1) {
        return components;
    }
    split = split || 1;
    // Split the array in 2 parts
    var left = components.slice(0, split);
    var right = components.slice(split);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
    try {
        return decodeURIComponent(input);
    } catch (err) {
        var tokens = input.match(singleMatcher) || [];
        for(var i = 1; i < tokens.length; i++){
            input = decodeComponents(tokens, i).join('');
            tokens = input.match(singleMatcher) || [];
        }
        return input;
    }
}
function customDecodeURIComponent(input) {
    // Keep track of all the replacements and prefill the map with the `BOM`
    var replaceMap = {
        '%FE%FF': '\uFFFD\uFFFD',
        '%FF%FE': '\uFFFD\uFFFD'
    };
    var match = multiMatcher.exec(input);
    while(match){
        try {
            // Decode as big chunks as possible
            replaceMap[match[0]] = decodeURIComponent(match[0]);
        } catch (err) {
            var result = decode(match[0]);
            if (result !== match[0]) {
                replaceMap[match[0]] = result;
            }
        }
        match = multiMatcher.exec(input);
    }
    // Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else
    replaceMap['%C2'] = '\uFFFD';
    var entries = Object.keys(replaceMap);
    for(var i = 0; i < entries.length; i++){
        // Replace all decoded components
        var key = entries[i];
        input = input.replace(new RegExp(key, 'g'), replaceMap[key]);
    }
    return input;
}
module.exports = function(encodedURI) {
    if (typeof encodedURI !== 'string') {
        throw new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');
    }
    try {
        encodedURI = encodedURI.replace(/\+/g, ' ');
        // Try the built in decoder first
        return decodeURIComponent(encodedURI);
    } catch (err) {
        // Fallback to a more advanced decoder
        return customDecodeURIComponent(encodedURI);
    }
};


}),
82063: (function (module) {
"use strict";

module.exports = (string)=>{
    if (typeof string !== 'string') {
        throw new TypeError('Expected a string');
    }
    // Escape characters with special meaning either inside or outside character sets.
    // Use a simple backslash escape when its always valid, and a \unnnn escape when the simpler form would be disallowed by Unicode patterns stricter grammar.
    return string.replace(/[|\\{}()[\]^$+*?.]/g, '\\$&').replace(/-/g, '\\x2d');
};


}),
18620: (function (module) {
"use strict";

module.exports = function(obj, predicate) {
    var ret = {};
    var keys = Object.keys(obj);
    var isArr = Array.isArray(predicate);
    for(var i = 0; i < keys.length; i++){
        var key = keys[i];
        var val = obj[key];
        if (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {
            ret[key] = val;
        }
    }
    return ret;
};


}),
78803: (function (__unused_webpack_module, exports) {
// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// References to the same file (works both for gzip and brotli):
// `'use`, `andom`, and `rict'`
// References to the brotli default dictionary:
// `-26T`, `1983`, `40px`, `75px`, `bush`, `jack`, `mind`, `very`, and `wolf`
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    customAlphabet: function() {
        return customAlphabet;
    },
    nanoid: function() {
        return nanoid;
    }
});
var urlAlphabet = 'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict';
var customAlphabet = (alphabet, ref)=>{
    var defaultSize = ref === void 0 ? 21 : ref;
    return (ref)=>{
        var size = ref === void 0 ? defaultSize : ref;
        var id = '';
        // A compact alternative for `for (var i = 0; i < step; i++)`.
        var i = size | 0;
        while(i--){
            // `| 0` is more compact and faster than `Math.floor()`.
            id += alphabet[Math.random() * alphabet.length | 0];
        }
        return id;
    };
};
var nanoid = (ref)=>{
    var size = ref === void 0 ? 21 : ref;
    var id = '';
    // A compact alternative for `for (var i = 0; i < step; i++)`.
    var i = size | 0;
    while(i--){
        // `| 0` is more compact and faster than `Math.floor()`.
        id += urlAlphabet[Math.random() * 64 | 0];
    }
    return id;
};


}),
85507: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(17738);
var _to_consumable_array = __webpack_require__(58678);
var strictUriEncode = __webpack_require__(3223);
var decodeComponent = __webpack_require__(79467);
var splitOnFirst = __webpack_require__(37025);
var filterObject = __webpack_require__(18620);
var isNullOrUndefined = (value)=>value === null || value === undefined;
var encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');
function encoderForArrayFormat(options) {
    switch(options.arrayFormat){
        case 'index':
            return (key)=>(result, value)=>{
                    var index = result.length;
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            [
                                encode(key, options),
                                '[',
                                index,
                                ']'
                            ].join('')
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            '[',
                            encode(index, options),
                            ']=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
        case 'bracket':
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            [
                                encode(key, options),
                                '[]'
                            ].join('')
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            '[]=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
        case 'colon-list-separator':
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            [
                                encode(key, options),
                                ':list='
                            ].join('')
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            ':list=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
        case 'comma':
        case 'separator':
        case 'bracket-separator':
            {
                var keyValueSep = options.arrayFormat === 'bracket-separator' ? '[]=' : '=';
                return (key)=>(result, value)=>{
                        if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                            return result;
                        }
                        // Translate null to an empty string so that it doesn't serialize as 'null'
                        value = value === null ? '' : value;
                        if (result.length === 0) {
                            return [
                                [
                                    encode(key, options),
                                    keyValueSep,
                                    encode(value, options)
                                ].join('')
                            ];
                        }
                        return [
                            [
                                result,
                                encode(value, options)
                            ].join(options.arrayFormatSeparator)
                        ];
                    };
            }
        default:
            return (key)=>(result, value)=>{
                    if (value === undefined || options.skipNull && value === null || options.skipEmptyString && value === '') {
                        return result;
                    }
                    if (value === null) {
                        return _to_consumable_array._(result).concat([
                            encode(key, options)
                        ]);
                    }
                    return _to_consumable_array._(result).concat([
                        [
                            encode(key, options),
                            '=',
                            encode(value, options)
                        ].join('')
                    ]);
                };
    }
}
function parserForArrayFormat(options) {
    var result;
    switch(options.arrayFormat){
        case 'index':
            return (key, value, accumulator)=>{
                result = /\[(\d*)\]$/.exec(key);
                key = key.replace(/\[\d*\]$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = {};
                }
                accumulator[key][result[1]] = value;
            };
        case 'bracket':
            return (key, value, accumulator)=>{
                result = /(\[\])$/.exec(key);
                key = key.replace(/\[\]$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = [
                        value
                    ];
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
        case 'colon-list-separator':
            return (key, value, accumulator)=>{
                result = /(:list)$/.exec(key);
                key = key.replace(/:list$/, '');
                if (!result) {
                    accumulator[key] = value;
                    return;
                }
                if (accumulator[key] === undefined) {
                    accumulator[key] = [
                        value
                    ];
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
        case 'comma':
        case 'separator':
            return (key, value, accumulator)=>{
                var isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);
                var isEncodedArray = typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator);
                value = isEncodedArray ? decode(value, options) : value;
                var newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map((item)=>decode(item, options)) : value === null ? value : decode(value, options);
                accumulator[key] = newValue;
            };
        case 'bracket-separator':
            return (key, value, accumulator)=>{
                var isArray = /(\[\])$/.test(key);
                key = key.replace(/\[\]$/, '');
                if (!isArray) {
                    accumulator[key] = value ? decode(value, options) : value;
                    return;
                }
                var arrayValue = value === null ? [] : value.split(options.arrayFormatSeparator).map((item)=>decode(item, options));
                if (accumulator[key] === undefined) {
                    accumulator[key] = arrayValue;
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], arrayValue);
            };
        default:
            return (key, value, accumulator)=>{
                if (accumulator[key] === undefined) {
                    accumulator[key] = value;
                    return;
                }
                accumulator[key] = [].concat(accumulator[key], value);
            };
    }
}
function validateArrayFormatSeparator(value) {
    if (typeof value !== 'string' || value.length !== 1) {
        throw new TypeError('arrayFormatSeparator must be single character string');
    }
}
function encode(value, options) {
    if (options.encode) {
        return options.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
    return value;
}
function decode(value, options) {
    if (options.decode) {
        return decodeComponent(value);
    }
    return value;
}
function keysSorter(input) {
    if (Array.isArray(input)) {
        return input.sort();
    }
    if (typeof input === 'object') {
        return keysSorter(Object.keys(input)).sort((a, b)=>Number(a) - Number(b)).map((key)=>input[key]);
    }
    return input;
}
function removeHash(input) {
    var hashStart = input.indexOf('#');
    if (hashStart !== -1) {
        input = input.slice(0, hashStart);
    }
    return input;
}
function getHash(url) {
    var hash = '';
    var hashStart = url.indexOf('#');
    if (hashStart !== -1) {
        hash = url.slice(hashStart);
    }
    return hash;
}
function extract(input) {
    input = removeHash(input);
    var queryStart = input.indexOf('?');
    if (queryStart === -1) {
        return '';
    }
    return input.slice(queryStart + 1);
}
function parseValue(value, options) {
    if (options.parseNumbers && !Number.isNaN(Number(value)) && typeof value === 'string' && value.trim() !== '') {
        value = Number(value);
    } else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {
        value = value.toLowerCase() === 'true';
    }
    return value;
}
function parse(query, options) {
    options = Object.assign({
        decode: true,
        sort: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ',',
        parseNumbers: false,
        parseBooleans: false
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    var formatter = parserForArrayFormat(options);
    // Create an object with no prototype
    var ret = Object.create(null);
    if (typeof query !== 'string') {
        return ret;
    }
    query = query.trim().replace(/^[?#&]/, '');
    if (!query) {
        return ret;
    }
    for (var param of query.split('&')){
        if (param === '') {
            continue;
        }
        var _splitOnFirst = _sliced_to_array._(splitOnFirst(options.decode ? param.replace(/\+/g, ' ') : param, '='), 2), key = _splitOnFirst[0], value = _splitOnFirst[1];
        // Missing `=` should be `null`:
        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
        value = value === undefined ? null : [
            'comma',
            'separator',
            'bracket-separator'
        ].includes(options.arrayFormat) ? value : decode(value, options);
        formatter(decode(key, options), value, ret);
    }
    for (var key1 of Object.keys(ret)){
        var value1 = ret[key1];
        if (typeof value1 === 'object' && value1 !== null) {
            for (var k of Object.keys(value1)){
                value1[k] = parseValue(value1[k], options);
            }
        } else {
            ret[key1] = parseValue(value1, options);
        }
    }
    if (options.sort === false) {
        return ret;
    }
    return (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key)=>{
        var value = ret[key];
        if (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {
            // Sort object keys, not values
            result[key] = keysSorter(value);
        } else {
            result[key] = value;
        }
        return result;
    }, Object.create(null));
}
exports.extract = extract;
exports.parse = parse;
exports.stringify = (object, options)=>{
    if (!object) {
        return '';
    }
    options = Object.assign({
        encode: true,
        strict: true,
        arrayFormat: 'none',
        arrayFormatSeparator: ','
    }, options);
    validateArrayFormatSeparator(options.arrayFormatSeparator);
    var shouldFilter = (key)=>options.skipNull && isNullOrUndefined(object[key]) || options.skipEmptyString && object[key] === '';
    var formatter = encoderForArrayFormat(options);
    var objectCopy = {};
    for (var key of Object.keys(object)){
        if (!shouldFilter(key)) {
            objectCopy[key] = object[key];
        }
    }
    var keys = Object.keys(objectCopy);
    if (options.sort !== false) {
        keys.sort(options.sort);
    }
    return keys.map((key)=>{
        var value = object[key];
        if (value === undefined) {
            return '';
        }
        if (value === null) {
            return encode(key, options);
        }
        if (Array.isArray(value)) {
            if (value.length === 0 && options.arrayFormat === 'bracket-separator') {
                return encode(key, options) + '[]';
            }
            return value.reduce(formatter(key), []).join('&');
        }
        return encode(key, options) + '=' + encode(value, options);
    }).filter((x)=>x.length > 0).join('&');
};
exports.parseUrl = (url, options)=>{
    options = Object.assign({
        decode: true
    }, options);
    var _splitOnFirst = _sliced_to_array._(splitOnFirst(url, '#'), 2), url_ = _splitOnFirst[0], hash = _splitOnFirst[1];
    return Object.assign({
        url: url_.split('?')[0] || '',
        query: parse(extract(url), options)
    }, options && options.parseFragmentIdentifier && hash ? {
        fragmentIdentifier: decode(hash, options)
    } : {});
};
exports.stringifyUrl = (object, options)=>{
    options = Object.assign({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
    }, options);
    var url = removeHash(object.url).split('?')[0] || '';
    var queryFromUrl = exports.extract(object.url);
    var parsedQueryFromUrl = exports.parse(queryFromUrl, {
        sort: false
    });
    var query = Object.assign(parsedQueryFromUrl, object.query);
    var queryString = exports.stringify(query, options);
    if (queryString) {
        queryString = `?${queryString}`;
    }
    var hash = getHash(object.url);
    if (object.fragmentIdentifier) {
        hash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;
    }
    return `${url}${queryString}${hash}`;
};
exports.pick = (input, filter, options)=>{
    options = Object.assign({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
    }, options);
    var _exports_parseUrl = exports.parseUrl(input, options), url = _exports_parseUrl.url, query = _exports_parseUrl.query, fragmentIdentifier = _exports_parseUrl.fragmentIdentifier;
    return exports.stringifyUrl({
        url,
        query: filterObject(query, filter),
        fragmentIdentifier
    }, options);
};
exports.exclude = (input, filter, options)=>{
    var exclusionFilter = Array.isArray(filter) ? (key)=>!filter.includes(key) : (key, value)=>!filter(key, value);
    return exports.pick(input, exclusionFilter, options);
};


}),
50631: (function (__unused_webpack_module, exports) {
"use strict";
/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var b = Symbol.for("react.element"), c = Symbol.for("react.portal"), d = Symbol.for("react.fragment"), e = Symbol.for("react.strict_mode"), f = Symbol.for("react.profiler"), g = Symbol.for("react.provider"), h = Symbol.for("react.context"), k = Symbol.for("react.server_context"), l = Symbol.for("react.forward_ref"), m = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), q = Symbol.for("react.lazy"), t = Symbol.for("react.offscreen"), u;
u = Symbol.for("react.module.reference");
function v(a) {
    if ("object" === typeof a && null !== a) {
        var r = a.$$typeof;
        switch(r){
            case b:
                switch(a = a.type, a){
                    case d:
                    case f:
                    case e:
                    case m:
                    case n:
                        return a;
                    default:
                        switch(a = a && a.$$typeof, a){
                            case k:
                            case h:
                            case l:
                            case q:
                            case p:
                            case g:
                                return a;
                            default:
                                return r;
                        }
                }
            case c:
                return r;
        }
    }
}
exports.ContextConsumer = h;
exports.ContextProvider = g;
exports.Element = b;
exports.ForwardRef = l;
exports.Fragment = d;
exports.Lazy = q;
exports.Memo = p;
exports.Portal = c;
exports.Profiler = f;
exports.StrictMode = e;
exports.Suspense = m;
exports.SuspenseList = n;
exports.isAsyncMode = function() {
    return !1;
};
exports.isConcurrentMode = function() {
    return !1;
};
exports.isContextConsumer = function(a) {
    return v(a) === h;
};
exports.isContextProvider = function(a) {
    return v(a) === g;
};
exports.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === b;
};
exports.isForwardRef = function(a) {
    return v(a) === l;
};
exports.isFragment = function(a) {
    return v(a) === d;
};
exports.isLazy = function(a) {
    return v(a) === q;
};
exports.isMemo = function(a) {
    return v(a) === p;
};
exports.isPortal = function(a) {
    return v(a) === c;
};
exports.isProfiler = function(a) {
    return v(a) === f;
};
exports.isStrictMode = function(a) {
    return v(a) === e;
};
exports.isSuspense = function(a) {
    return v(a) === m;
};
exports.isSuspenseList = function(a) {
    return v(a) === n;
};
exports.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === d || a === f || a === e || a === m || a === n || a === t || "object" === typeof a && null !== a && (a.$$typeof === q || a.$$typeof === p || a.$$typeof === g || a.$$typeof === h || a.$$typeof === l || a.$$typeof === u || void 0 !== a.getModuleId) ? !0 : !1;
};
exports.typeOf = v;


}),
55526: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";

if (true) {
    module.exports = __webpack_require__(50631);
} else {}


}),
37025: (function (module) {
"use strict";

module.exports = (string, separator)=>{
    if (!(typeof string === 'string' && typeof separator === 'string')) {
        throw new TypeError('Expected the arguments to be of type `string`');
    }
    if (separator === '') {
        return [
            string
        ];
    }
    var separatorIndex = string.indexOf(separator);
    if (separatorIndex === -1) {
        return [
            string
        ];
    }
    return [
        string.slice(0, separatorIndex),
        string.slice(separatorIndex + separator.length)
    ];
};


}),
3223: (function (module) {
"use strict";

module.exports = (str)=>encodeURIComponent(str).replace(/[!'()*]/g, (x)=>`%${x.charCodeAt(0).toString(16).toUpperCase()}`);


}),
34467: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";

var React = __webpack_require__(92888);
var useIsomorphicLayoutEffect_1 = __webpack_require__(38299);
/**
 * React hook which returns the latest callback without changing the reference.
 */ // eslint-disable-next-line @typescript-eslint/ban-types
function useLatestCallback(callback) {
    var ref = React.useRef(callback);
    var latestCallback = React.useRef(function latestCallback() {
        var args = [];
        for(var _i = 0; _i < arguments.length; _i++){
            args[_i] = arguments[_i];
        }
        return ref.current.apply(this, args);
    }).current;
    (0, useIsomorphicLayoutEffect_1.default)(function() {
        ref.current = callback;
    });
    return latestCallback;
}
module.exports = useLatestCallback;


}),
38299: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var react_1 = __webpack_require__(92888);
exports["default"] = react_1.useLayoutEffect;


}),
80447: (function (__unused_webpack_module, exports, __webpack_require__) {
"use strict";
/**
 * @license React
 * use-sync-external-store-with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 
var React = __webpack_require__(92888);
function is(x, y) {
    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
}
var objectIs = "function" === typeof Object.is ? Object.is : is, useSyncExternalStore = React.useSyncExternalStore, useRef = React.useRef, useEffect = React.useEffect, useMemo = React.useMemo, useDebugValue = React.useDebugValue;
exports.useSyncExternalStoreWithSelector = function(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
    var instRef = useRef(null);
    if (null === instRef.current) {
        var inst = {
            hasValue: !1,
            value: null
        };
        instRef.current = inst;
    } else inst = instRef.current;
    instRef = useMemo(function() {
        function memoizedSelector(nextSnapshot) {
            if (!hasMemo) {
                hasMemo = !0;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual && inst.hasValue) {
                    var currentSelection = inst.value;
                    if (isEqual(currentSelection, nextSnapshot)) return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
            }
            currentSelection = memoizedSelection;
            if (objectIs(memoizedSnapshot, nextSnapshot)) return currentSelection;
            var nextSelection = selector(nextSnapshot);
            if (void 0 !== isEqual && isEqual(currentSelection, nextSelection)) return memoizedSnapshot = nextSnapshot, currentSelection;
            memoizedSnapshot = nextSnapshot;
            return memoizedSelection = nextSelection;
        }
        var hasMemo = !1, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
        return [
            function() {
                return memoizedSelector(getSnapshot());
            },
            null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
            }
        ];
    }, [
        getSnapshot,
        getServerSnapshot,
        selector,
        isEqual
    ]);
    var value = useSyncExternalStore(subscribe, instRef[0], instRef[1]);
    useEffect(function() {
        inst.hasValue = !0;
        inst.value = value;
    }, [
        value
    ]);
    useDebugValue(value);
    return value;
};


}),
65632: (function (module, __unused_webpack_exports, __webpack_require__) {
"use strict";

if (true) {
    module.exports = __webpack_require__(80447);
} else {}


}),

}]);//# sourceMappingURL=vendors-node_modules_pnpm_react-navigation_native_7_0_14_react-native_0_78_2__babel_core_7_26-91cf7e.chunk.bundle.map?platform=android