"use strict";
(self["webpackChunkclaim"] = self["webpackChunkclaim"] || []).push([["vendors-node_modules_react-navigation_native-stack_lib_commonjs_index_js"], {
27750: (function (__unused_webpack_module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "NativeStackView", ({
    enumerable: true,
    get: function() {
        return _NativeStackView.NativeStackView;
    }
}));
Object.defineProperty(exports, "createNativeStackNavigator", ({
    enumerable: true,
    get: function() {
        return _createNativeStackNavigator.createNativeStackNavigator;
    }
}));
Object.defineProperty(exports, "useAnimatedHeaderHeight", ({
    enumerable: true,
    get: function() {
        return _useAnimatedHeaderHeight.useAnimatedHeaderHeight;
    }
}));
var _createNativeStackNavigator = __webpack_require__(37295);
var _NativeStackView = __webpack_require__(89476);
var _useAnimatedHeaderHeight = __webpack_require__(25205); //# sourceMappingURL=index.js.map


}),
37295: (function (__unused_webpack_module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _object_without_properties = __webpack_require__(86136);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createNativeStackNavigator = createNativeStackNavigator;
var _native = __webpack_require__(57102);
var React = _interopRequireWildcard(__webpack_require__(43348));
var _NativeStackView = __webpack_require__(89476);
var _jsxRuntime = __webpack_require__(70095);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function NativeStackNavigator(_param) {
    var id = _param.id, initialRouteName = _param.initialRouteName, children = _param.children, layout = _param.layout, screenListeners = _param.screenListeners, screenOptions = _param.screenOptions, screenLayout = _param.screenLayout, UNSTABLE_getStateForRouteNamesChange = _param.UNSTABLE_getStateForRouteNamesChange, rest = _object_without_properties._(_param, [
        "id",
        "initialRouteName",
        "children",
        "layout",
        "screenListeners",
        "screenOptions",
        "screenLayout",
        "UNSTABLE_getStateForRouteNamesChange"
    ]);
    var _ref = (0, _native.useNavigationBuilder)(_native.StackRouter, {
        id,
        initialRouteName,
        children,
        layout,
        screenListeners,
        screenOptions,
        screenLayout,
        UNSTABLE_getStateForRouteNamesChange
    }), state = _ref.state, describe = _ref.describe, descriptors = _ref.descriptors, navigation = _ref.navigation, NavigationContent = _ref.NavigationContent;
    React.useEffect(()=>{
        var // @ts-expect-error: there may not be a tab navigator in parent
        _navigation_addListener;
        return navigation === null || navigation === void 0 ? void 0 : (_navigation_addListener = navigation.addListener) === null || _navigation_addListener === void 0 ? void 0 : _navigation_addListener.call(navigation, 'tabPress', (e)=>{
            var isFocused = navigation.isFocused();
            // Run the operation in the next frame so we're sure all listeners have been run
            // This is necessary to know if preventDefault() has been called
            requestAnimationFrame(()=>{
                if (state.index > 0 && isFocused && !e.defaultPrevented) {
                    // When user taps on already focused tab and we're inside the tab,
                    // reset the stack to replicate native behaviour
                    navigation.dispatch(_object_spread_props._(_object_spread._({}, _native.StackActions.popToTop()), {
                        target: state.key
                    }));
                }
            });
        });
    }, [
        navigation,
        state.index,
        state.key
    ]);
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(NavigationContent, {
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_NativeStackView.NativeStackView, _object_spread_props._(_object_spread._({}, rest), {
            state: state,
            navigation: navigation,
            descriptors: descriptors,
            describe: describe
        }))
    });
}
function createNativeStackNavigator(config) {
    return (0, _native.createNavigatorFactory)(NativeStackNavigator)(config);
} //# sourceMappingURL=createNativeStackNavigator.js.map


}),
23876: (function (__unused_webpack_module, exports) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.debounce = debounce;
function debounce(func, duration) {
    var timeout;
    return function(...args) {
        clearTimeout(timeout);
        timeout = setTimeout(()=>{
            func.apply(this, args);
        }, duration);
    };
} //# sourceMappingURL=debounce.js.map


}),
95223: (function (__unused_webpack_module, exports) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getModalRouteKeys = void 0;
var getModalRouteKeys = (routes, descriptors)=>routes.reduce((acc, route)=>{
        var _descriptors_route_key;
        var presentation = (((_descriptors_route_key = descriptors[route.key]) === null || _descriptors_route_key === void 0 ? void 0 : _descriptors_route_key.options) ?? {}).presentation;
        if (acc.length && !presentation || presentation === 'modal' || presentation === 'transparentModal') {
            acc.push(route.key);
        }
        return acc;
    }, []);
exports.getModalRouteKeys = getModalRouteKeys; //# sourceMappingURL=getModalRoutesKeys.js.map


}),
25205: (function (__unused_webpack_module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AnimatedHeaderHeightContext = void 0;
exports.useAnimatedHeaderHeight = useAnimatedHeaderHeight;
var React = _interopRequireWildcard(__webpack_require__(43348));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var AnimatedHeaderHeightContext = exports.AnimatedHeaderHeightContext = /*#__PURE__*/ React.createContext(undefined);
function useAnimatedHeaderHeight() {
    var animatedValue = React.useContext(AnimatedHeaderHeightContext);
    if (animatedValue === undefined) {
        throw new Error("Couldn't find the header height. Are you inside a screen in a native stack navigator?");
    }
    return animatedValue;
} //# sourceMappingURL=useAnimatedHeaderHeight.js.map


}),
37369: (function (__unused_webpack_module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _sliced_to_array = __webpack_require__(78474);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useDismissedRouteError = useDismissedRouteError;
var React = _interopRequireWildcard(__webpack_require__(43348));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useDismissedRouteError(state) {
    var _state_routes_find;
    var _React_useState = _sliced_to_array._(React.useState(null), 2), nextDismissedKey = _React_useState[0], setNextDismissedKey = _React_useState[1];
    var dismissedRouteName = nextDismissedKey ? (_state_routes_find = state.routes.find((route)=>route.key === nextDismissedKey)) === null || _state_routes_find === void 0 ? void 0 : _state_routes_find.name : null;
    React.useEffect(()=>{
        if (dismissedRouteName) {
            var message = `The screen '${dismissedRouteName}' was removed natively but didn't get removed from JS state. ` + `This can happen if the action was prevented in a 'beforeRemove' listener, which is not fully supported in native-stack.\n\n` + `Consider using a 'usePreventRemove' hook with 'headerBackButtonMenuEnabled: false' to prevent users from natively going back multiple screens.`;
            console.error(message);
        }
    }, [
        dismissedRouteName
    ]);
    return {
        setNextDismissedKey
    };
} //# sourceMappingURL=useDismissedRouteError.js.map


}),
67333: (function (__unused_webpack_module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useInvalidPreventRemoveError = useInvalidPreventRemoveError;
var _native = __webpack_require__(57102);
var React = _interopRequireWildcard(__webpack_require__(43348));
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
function useInvalidPreventRemoveError(descriptors) {
    var _preventedDescriptor_options, _preventedDescriptor_route;
    var preventedRoutes = (0, _native.usePreventRemoveContext)().preventedRoutes;
    var preventedRouteKey = Object.keys(preventedRoutes)[0];
    var preventedDescriptor = descriptors[preventedRouteKey];
    var isHeaderBackButtonMenuEnabledOnPreventedScreen = preventedDescriptor === null || preventedDescriptor === void 0 ? void 0 : (_preventedDescriptor_options = preventedDescriptor.options) === null || _preventedDescriptor_options === void 0 ? void 0 : _preventedDescriptor_options.headerBackButtonMenuEnabled;
    var preventedRouteName = preventedDescriptor === null || preventedDescriptor === void 0 ? void 0 : (_preventedDescriptor_route = preventedDescriptor.route) === null || _preventedDescriptor_route === void 0 ? void 0 : _preventedDescriptor_route.name;
    React.useEffect(()=>{
        if (preventedRouteKey != null && isHeaderBackButtonMenuEnabledOnPreventedScreen) {
            var message = `The screen ${preventedRouteName} uses 'usePreventRemove' hook alongside 'headerBackButtonMenuEnabled: true', which is not supported. \n\n` + `Consider removing 'headerBackButtonMenuEnabled: true' from ${preventedRouteName} screen to get rid of this error.`;
            console.error(message);
        }
    }, [
        preventedRouteKey,
        isHeaderBackButtonMenuEnabledOnPreventedScreen,
        preventedRouteName
    ]);
} //# sourceMappingURL=useInvalidPreventRemoveError.js.map


}),
76974: (function (__unused_webpack_module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.processFonts = processFonts;
var _ReactNativeStyleAttributes = _interopRequireDefault(__webpack_require__(38959));
function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
        default: e
    };
}
// @ts-expect-error importing private module
function processFonts(fontFamilies) {
    var _ReactNativeStyleAttributes_default_fontFamily;
    var fontFamilyProcessor = (_ReactNativeStyleAttributes_default_fontFamily = _ReactNativeStyleAttributes.default.fontFamily) === null || _ReactNativeStyleAttributes_default_fontFamily === void 0 ? void 0 : _ReactNativeStyleAttributes_default_fontFamily.process;
    if (typeof fontFamilyProcessor === 'function') {
        return fontFamilies.map(fontFamilyProcessor);
    }
    return fontFamilies;
} //# sourceMappingURL=FontProcessor.native.js.map


}),
89476: (function (__unused_webpack_module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(36192);
var _object_spread_props = __webpack_require__(83590);
var _sliced_to_array = __webpack_require__(78474);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NativeStackView = NativeStackView;
var _elements = __webpack_require__(69372);
var _native = __webpack_require__(57102);
var React = _interopRequireWildcard(__webpack_require__(43348));
var _reactNative = __webpack_require__(56300);
var _reactNativeSafeAreaContext = __webpack_require__(33481);
var _reactNativeScreens = __webpack_require__(47743);
var _debounce = __webpack_require__(23876);
var _getModalRoutesKeys = __webpack_require__(95223);
var _useAnimatedHeaderHeight = __webpack_require__(25205);
var _useDismissedRouteError = __webpack_require__(37369);
var _useInvalidPreventRemoveError = __webpack_require__(67333);
var _useHeaderConfigProps = __webpack_require__(27840);
var _jsxRuntime = __webpack_require__(70095);
function _getRequireWildcardCache(e) {
    if ("function" != typeof WeakMap) return null;
    var r = new WeakMap(), t = new WeakMap();
    return (_getRequireWildcardCache = function(e) {
        return e ? t : r;
    })(e);
}
function _interopRequireWildcard(e, r) {
    if (!r && e && e.__esModule) return e;
    if (null === e || "object" != typeof e && "function" != typeof e) return {
        default: e
    };
    var t = _getRequireWildcardCache(r);
    if (t && t.has(e)) return t.get(e);
    var n = {
        __proto__: null
    }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var u in e)if ("default" !== u && ({}).hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
    }
    return n.default = e, t && t.set(e, n), n;
}
var ANDROID_DEFAULT_HEADER_HEIGHT = 56;
function isFabric() {
    return 'nativeFabricUIManager' in __webpack_require__.g;
}
var useNativeDriver = _reactNative.Platform.OS !== 'web';
var SceneView = (ref)=>{
    var index = ref.index, focused = ref.focused, shouldFreeze = ref.shouldFreeze, descriptor = ref.descriptor, previousDescriptor = ref.previousDescriptor, nextDescriptor = ref.nextDescriptor, isPresentationModal = ref.isPresentationModal, isPreloaded = ref.isPreloaded, onWillDisappear = ref.onWillDisappear, onWillAppear = ref.onWillAppear, onAppear = ref.onAppear, onDisappear = ref.onDisappear, onDismissed = ref.onDismissed, onHeaderBackButtonClicked = ref.onHeaderBackButtonClicked, onNativeDismissCancelled = ref.onNativeDismissCancelled, onGestureCancel = ref.onGestureCancel, onSheetDetentChanged = ref.onSheetDetentChanged;
    var _preventedRoutes_route_key;
    var route = descriptor.route, navigation = descriptor.navigation, options = descriptor.options, render = descriptor.render;
    var animation = options.animation, animationMatchesGesture = options.animationMatchesGesture, _options_presentation = options.presentation, presentation = _options_presentation === void 0 ? isPresentationModal ? 'modal' : 'card' : _options_presentation, fullScreenGestureEnabled = options.fullScreenGestureEnabled;
    var animationDuration = options.animationDuration, _options_animationTypeForReplace = options.animationTypeForReplace, animationTypeForReplace = _options_animationTypeForReplace === void 0 ? 'push' : _options_animationTypeForReplace, _options_fullScreenGestureShadowEnabled = options.fullScreenGestureShadowEnabled, fullScreenGestureShadowEnabled = _options_fullScreenGestureShadowEnabled === void 0 ? true : _options_fullScreenGestureShadowEnabled, gestureEnabled = options.gestureEnabled, _options_gestureDirection = options.gestureDirection, gestureDirection = _options_gestureDirection === void 0 ? presentation === 'card' ? 'horizontal' : 'vertical' : _options_gestureDirection, gestureResponseDistance = options.gestureResponseDistance, header = options.header, headerBackButtonMenuEnabled = options.headerBackButtonMenuEnabled, headerShown = options.headerShown, headerBackground = options.headerBackground, headerTransparent = options.headerTransparent, autoHideHomeIndicator = options.autoHideHomeIndicator, keyboardHandlingEnabled = options.keyboardHandlingEnabled, navigationBarColor = options.navigationBarColor, navigationBarTranslucent = options.navigationBarTranslucent, navigationBarHidden = options.navigationBarHidden, orientation = options.orientation, _options_sheetAllowedDetents = options.sheetAllowedDetents, sheetAllowedDetents = _options_sheetAllowedDetents === void 0 ? [
        1.0
    ] : _options_sheetAllowedDetents, _options_sheetLargestUndimmedDetentIndex = options.sheetLargestUndimmedDetentIndex, sheetLargestUndimmedDetentIndex = _options_sheetLargestUndimmedDetentIndex === void 0 ? -1 : _options_sheetLargestUndimmedDetentIndex, _options_sheetGrabberVisible = options.sheetGrabberVisible, sheetGrabberVisible = _options_sheetGrabberVisible === void 0 ? false : _options_sheetGrabberVisible, _options_sheetCornerRadius = options.sheetCornerRadius, sheetCornerRadius = _options_sheetCornerRadius === void 0 ? -1.0 : _options_sheetCornerRadius, _options_sheetElevation = options.sheetElevation, sheetElevation = _options_sheetElevation === void 0 ? 24 : _options_sheetElevation, _options_sheetExpandsWhenScrolledToEdge = options.sheetExpandsWhenScrolledToEdge, sheetExpandsWhenScrolledToEdge = _options_sheetExpandsWhenScrolledToEdge === void 0 ? true : _options_sheetExpandsWhenScrolledToEdge, _options_sheetInitialDetentIndex = options.sheetInitialDetentIndex, sheetInitialDetentIndex = _options_sheetInitialDetentIndex === void 0 ? 0 : _options_sheetInitialDetentIndex, statusBarAnimation = options.statusBarAnimation, statusBarHidden = options.statusBarHidden, statusBarStyle = options.statusBarStyle, statusBarTranslucent = options.statusBarTranslucent, statusBarBackgroundColor = options.statusBarBackgroundColor, unstable_sheetFooter = options.unstable_sheetFooter, freezeOnBlur = options.freezeOnBlur, contentStyle = options.contentStyle;
    if (gestureDirection === 'vertical' && _reactNative.Platform.OS === 'ios') {
        // for `vertical` direction to work, we need to set `fullScreenGestureEnabled` to `true`
        // so the screen can be dismissed from any point on screen.
        // `animationMatchesGesture` needs to be set to `true` so the `animation` set by user can be used,
        // otherwise `simple_push` will be used.
        // Also, the default animation for this direction seems to be `slide_from_bottom`.
        if (fullScreenGestureEnabled === undefined) {
            fullScreenGestureEnabled = true;
        }
        if (animationMatchesGesture === undefined) {
            animationMatchesGesture = true;
        }
        if (animation === undefined) {
            animation = 'slide_from_bottom';
        }
    }
    // workaround for rn-screens where gestureDirection has to be set on both
    // current and previous screen - software-mansion/react-native-screens/pull/1509
    var nextGestureDirection = nextDescriptor === null || nextDescriptor === void 0 ? void 0 : nextDescriptor.options.gestureDirection;
    var gestureDirectionOverride = nextGestureDirection != null ? nextGestureDirection : gestureDirection;
    if (index === 0) {
        // first screen should always be treated as `card`, it resolves problems with no header animation
        // for navigator with first screen as `modal` and the next as `card`
        presentation = 'card';
    }
    var colors = (0, _native.useTheme)().colors;
    var insets = (0, _reactNativeSafeAreaContext.useSafeAreaInsets)();
    var frame = (0, _reactNativeSafeAreaContext.useSafeAreaFrame)();
    // `modal` and `formSheet` presentations do not take whole screen, so should not take the inset.
    var isModal = presentation === 'modal' || presentation === 'formSheet';
    // Modals are fullscreen in landscape only on iPhone
    var isIPhone = _reactNative.Platform.OS === 'ios' && !(_reactNative.Platform.isPad || _reactNative.Platform.isTV);
    var isLandscape = frame.width > frame.height;
    var isParentHeaderShown = React.useContext(_elements.HeaderShownContext);
    var parentHeaderHeight = React.useContext(_elements.HeaderHeightContext);
    var parentHeaderBack = React.useContext(_elements.HeaderBackContext);
    var topInset = isParentHeaderShown || _reactNative.Platform.OS === 'ios' && isModal || isIPhone && isLandscape ? 0 : insets.top;
    var preventedRoutes = (0, _native.usePreventRemoveContext)().preventedRoutes;
    var defaultHeaderHeight = _reactNative.Platform.select({
        // FIXME: Currently screens isn't using Material 3
        // So our `getDefaultHeaderHeight` doesn't return the correct value
        // So we hardcode the value here for now until screens is updated
        android: ANDROID_DEFAULT_HEADER_HEIGHT + topInset,
        default: (0, _elements.getDefaultHeaderHeight)(frame, isModal, topInset)
    });
    var _React_useState = _sliced_to_array._(React.useState(defaultHeaderHeight), 2), headerHeight = _React_useState[0], setHeaderHeight = _React_useState[1];
    // eslint-disable-next-line react-hooks/exhaustive-deps
    var setHeaderHeightDebounced = React.useCallback(// Debounce the header height updates to avoid excessive re-renders
    (0, _debounce.debounce)(setHeaderHeight, 100), []);
    var hasCustomHeader = header !== undefined;
    var headerHeightCorrectionOffset = 0;
    if (_reactNative.Platform.OS === 'android' && !hasCustomHeader) {
        var statusBarHeight = _reactNative.StatusBar.currentHeight ?? 0;
        // FIXME: On Android, the native header height is not correctly calculated
        // It includes status bar height even if statusbar is not translucent
        // And the statusbar value itself doesn't match the actual status bar height
        // So we subtract the bogus status bar height and add the actual top inset
        headerHeightCorrectionOffset = -statusBarHeight + topInset;
    }
    var rawAnimatedHeaderHeight = (0, _reactNative.useAnimatedValue)(defaultHeaderHeight);
    var animatedHeaderHeight = React.useMemo(()=>_reactNative.Animated.add(rawAnimatedHeaderHeight, headerHeightCorrectionOffset), [
        headerHeightCorrectionOffset,
        rawAnimatedHeaderHeight
    ]);
    // During the very first render topInset is > 0 when running
    // in non edge-to-edge mode on Android, while on every consecutive render
    // topInset === 0, causing header content to jump, as we add padding on the first frame,
    // just to remove it in next one. To prevent this, when statusBarTranslucent is set,
    // we apply additional padding in header only if its true.
    // For more details see: https://github.com/react-navigation/react-navigation/pull/12014
    var headerTopInsetEnabled = typeof statusBarTranslucent === 'boolean' ? statusBarTranslucent : topInset !== 0;
    var canGoBack = previousDescriptor != null || parentHeaderBack != null;
    var backTitle = previousDescriptor ? (0, _elements.getHeaderTitle)(previousDescriptor.options, previousDescriptor.route.name) : parentHeaderBack === null || parentHeaderBack === void 0 ? void 0 : parentHeaderBack.title;
    var headerBack = React.useMemo(()=>{
        if (canGoBack) {
            return {
                href: undefined,
                // No href needed for native
                title: backTitle
            };
        }
        return undefined;
    }, [
        canGoBack,
        backTitle
    ]);
    var isRemovePrevented = (_preventedRoutes_route_key = preventedRoutes[route.key]) === null || _preventedRoutes_route_key === void 0 ? void 0 : _preventedRoutes_route_key.preventRemove;
    var headerConfig = (0, _useHeaderConfigProps.useHeaderConfigProps)(_object_spread_props._(_object_spread._({}, options), {
        route,
        headerBackButtonMenuEnabled: isRemovePrevented !== undefined ? !isRemovePrevented : headerBackButtonMenuEnabled,
        headerBackTitle: options.headerBackTitle !== undefined ? options.headerBackTitle : undefined,
        headerHeight,
        headerShown: header !== undefined ? false : headerShown,
        headerTopInsetEnabled,
        headerBack
    }));
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_native.NavigationContext.Provider, {
        value: navigation,
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_native.NavigationRouteContext.Provider, {
            value: route,
            children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNativeScreens.ScreenStackItem, {
                screenId: route.key,
                activityState: isPreloaded ? 0 : 2,
                style: _reactNative.StyleSheet.absoluteFill,
                accessibilityElementsHidden: !focused,
                importantForAccessibility: focused ? 'auto' : 'no-hide-descendants',
                customAnimationOnSwipe: animationMatchesGesture,
                fullScreenSwipeEnabled: fullScreenGestureEnabled,
                fullScreenSwipeShadowEnabled: fullScreenGestureShadowEnabled,
                freezeOnBlur: freezeOnBlur,
                gestureEnabled: _reactNative.Platform.OS === 'android' ? // This prop enables handling of system back gestures on Android
                // Since we handle them in JS side, we disable this
                false : gestureEnabled,
                homeIndicatorHidden: autoHideHomeIndicator,
                hideKeyboardOnSwipe: keyboardHandlingEnabled,
                navigationBarColor: navigationBarColor,
                navigationBarTranslucent: navigationBarTranslucent,
                navigationBarHidden: navigationBarHidden,
                replaceAnimation: animationTypeForReplace,
                stackPresentation: presentation === 'card' ? 'push' : presentation,
                stackAnimation: animation,
                screenOrientation: orientation,
                sheetAllowedDetents: sheetAllowedDetents,
                sheetLargestUndimmedDetentIndex: sheetLargestUndimmedDetentIndex,
                sheetGrabberVisible: sheetGrabberVisible,
                sheetInitialDetentIndex: sheetInitialDetentIndex,
                sheetCornerRadius: sheetCornerRadius,
                sheetElevation: sheetElevation,
                sheetExpandsWhenScrolledToEdge: sheetExpandsWhenScrolledToEdge,
                statusBarAnimation: statusBarAnimation,
                statusBarHidden: statusBarHidden,
                statusBarStyle: statusBarStyle,
                statusBarColor: statusBarBackgroundColor,
                statusBarTranslucent: statusBarTranslucent,
                swipeDirection: gestureDirectionOverride,
                transitionDuration: animationDuration,
                onWillAppear: onWillAppear,
                onWillDisappear: onWillDisappear,
                onAppear: onAppear,
                onDisappear: onDisappear,
                onDismissed: onDismissed,
                onGestureCancel: onGestureCancel,
                onSheetDetentChanged: onSheetDetentChanged,
                gestureResponseDistance: gestureResponseDistance,
                nativeBackButtonDismissalEnabled: false // on Android
                ,
                onHeaderBackButtonClicked: onHeaderBackButtonClicked,
                preventNativeDismiss: isRemovePrevented // on iOS
                ,
                onNativeDismissCancelled: onNativeDismissCancelled,
                onHeaderHeightChange: _reactNative.Animated.event([
                    {
                        nativeEvent: {
                            headerHeight: rawAnimatedHeaderHeight
                        }
                    }
                ], {
                    useNativeDriver,
                    listener: (e)=>{
                        if (_reactNative.Platform.OS === 'android' && (options.headerBackground != null || options.headerTransparent)) {
                            // FIXME: On Android, we get 0 if the header is translucent
                            // So we set a default height in that case
                            setHeaderHeight(ANDROID_DEFAULT_HEADER_HEIGHT + topInset);
                            return;
                        }
                        if (e.nativeEvent && typeof e.nativeEvent === 'object' && 'headerHeight' in e.nativeEvent && typeof e.nativeEvent.headerHeight === 'number') {
                            var headerHeight = e.nativeEvent.headerHeight + headerHeightCorrectionOffset;
                            // Only debounce if header has large title or search bar
                            // As it's the only case where the header height can change frequently
                            var doesHeaderAnimate = _reactNative.Platform.OS === 'ios' && (options.headerLargeTitle || options.headerSearchBarOptions);
                            if (doesHeaderAnimate) {
                                setHeaderHeightDebounced(headerHeight);
                            } else {
                                setHeaderHeight(headerHeight);
                            }
                        }
                    }
                }),
                contentStyle: [
                    presentation !== 'transparentModal' && presentation !== 'containedTransparentModal' && {
                        backgroundColor: colors.background
                    },
                    contentStyle
                ],
                headerConfig: headerConfig,
                unstable_sheetFooter: unstable_sheetFooter,
                shouldFreeze: shouldFreeze,
                children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_useAnimatedHeaderHeight.AnimatedHeaderHeightContext.Provider, {
                    value: animatedHeaderHeight,
                    children: /*#__PURE__*/ (0, _jsxRuntime.jsxs)(_elements.HeaderHeightContext.Provider, {
                        value: headerShown !== false ? headerHeight : parentHeaderHeight ?? 0,
                        children: [
                            headerBackground != null ? /*#__PURE__*/ /**
             * To show a custom header background, we render it at the top of the screen below the header
             * The header also needs to be positioned absolutely (with `translucent` style)
             */ (0, _jsxRuntime.jsx)(_reactNative.View, {
                                style: [
                                    styles.background,
                                    headerTransparent ? styles.translucent : null,
                                    {
                                        height: headerHeight
                                    }
                                ],
                                children: headerBackground()
                            }) : null,
                            header !== undefined && headerShown !== false ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNative.View, {
                                onLayout: (e)=>{
                                    var headerHeight = e.nativeEvent.layout.height;
                                    setHeaderHeight(headerHeight);
                                    rawAnimatedHeaderHeight.setValue(headerHeight);
                                },
                                style: [
                                    styles.header,
                                    headerTransparent ? styles.absolute : null
                                ],
                                children: header({
                                    back: headerBack,
                                    options,
                                    route,
                                    navigation
                                })
                            }) : null,
                            /*#__PURE__*/ (0, _jsxRuntime.jsx)(_elements.HeaderShownContext.Provider, {
                                value: isParentHeaderShown || headerShown !== false,
                                children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_elements.HeaderBackContext.Provider, {
                                    value: headerBack,
                                    children: render()
                                })
                            })
                        ]
                    })
                })
            }, route.key)
        })
    });
};
function NativeStackView(ref) {
    var state = ref.state, navigation = ref.navigation, descriptors = ref.descriptors, describe = ref.describe;
    var setNextDismissedKey = (0, _useDismissedRouteError.useDismissedRouteError)(state).setNextDismissedKey;
    (0, _useInvalidPreventRemoveError.useInvalidPreventRemoveError)(descriptors);
    var modalRouteKeys = (0, _getModalRoutesKeys.getModalRouteKeys)(state.routes, descriptors);
    var preloadedDescriptors = state.preloadedRoutes.reduce((acc, route)=>{
        acc[route.key] = acc[route.key] || describe(route, true);
        return acc;
    }, {});
    return /*#__PURE__*/ (0, _jsxRuntime.jsx)(_elements.SafeAreaProviderCompat, {
        children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNativeScreens.ScreenStack, {
            style: styles.container,
            children: state.routes.concat(state.preloadedRoutes).map((route, index)=>{
                var _state_routes_, _state_routes_1;
                var descriptor = descriptors[route.key] ?? preloadedDescriptors[route.key];
                var isFocused = state.index === index;
                var isBelowFocused = state.index - 1 === index;
                var previousKey = (_state_routes_ = state.routes[index - 1]) === null || _state_routes_ === void 0 ? void 0 : _state_routes_.key;
                var nextKey = (_state_routes_1 = state.routes[index + 1]) === null || _state_routes_1 === void 0 ? void 0 : _state_routes_1.key;
                var previousDescriptor = previousKey ? descriptors[previousKey] : undefined;
                var nextDescriptor = nextKey ? descriptors[nextKey] : undefined;
                var isModal = modalRouteKeys.includes(route.key);
                var isPreloaded = preloadedDescriptors[route.key] !== undefined && descriptors[route.key] === undefined;
                // On Fabric, when screen is frozen, animated and reanimated values are not updated
                // due to component being unmounted. To avoid this, we don't freeze the previous screen there
                var shouldFreeze = isFabric() ? !isPreloaded && !isFocused && !isBelowFocused : !isPreloaded && !isFocused;
                return /*#__PURE__*/ (0, _jsxRuntime.jsx)(SceneView, {
                    index: index,
                    focused: isFocused,
                    shouldFreeze: shouldFreeze,
                    descriptor: descriptor,
                    previousDescriptor: previousDescriptor,
                    nextDescriptor: nextDescriptor,
                    isPresentationModal: isModal,
                    isPreloaded: isPreloaded,
                    onWillDisappear: ()=>{
                        navigation.emit({
                            type: 'transitionStart',
                            data: {
                                closing: true
                            },
                            target: route.key
                        });
                    },
                    onWillAppear: ()=>{
                        navigation.emit({
                            type: 'transitionStart',
                            data: {
                                closing: false
                            },
                            target: route.key
                        });
                    },
                    onAppear: ()=>{
                        navigation.emit({
                            type: 'transitionEnd',
                            data: {
                                closing: false
                            },
                            target: route.key
                        });
                    },
                    onDisappear: ()=>{
                        navigation.emit({
                            type: 'transitionEnd',
                            data: {
                                closing: true
                            },
                            target: route.key
                        });
                    },
                    onDismissed: (event)=>{
                        navigation.dispatch(_object_spread_props._(_object_spread._({}, _native.StackActions.pop(event.nativeEvent.dismissCount)), {
                            source: route.key,
                            target: state.key
                        }));
                        setNextDismissedKey(route.key);
                    },
                    onHeaderBackButtonClicked: ()=>{
                        navigation.dispatch(_object_spread_props._(_object_spread._({}, _native.StackActions.pop()), {
                            source: route.key,
                            target: state.key
                        }));
                    },
                    onNativeDismissCancelled: (event)=>{
                        navigation.dispatch(_object_spread_props._(_object_spread._({}, _native.StackActions.pop(event.nativeEvent.dismissCount)), {
                            source: route.key,
                            target: state.key
                        }));
                    },
                    onGestureCancel: ()=>{
                        navigation.emit({
                            type: 'gestureCancel',
                            target: route.key
                        });
                    },
                    onSheetDetentChanged: (event)=>{
                        navigation.emit({
                            type: 'sheetDetentChange',
                            target: route.key,
                            data: {
                                index: event.nativeEvent.index,
                                stable: event.nativeEvent.isStable
                            }
                        });
                    }
                }, route.key);
            })
        })
    });
}
var styles = _reactNative.StyleSheet.create({
    container: {
        flex: 1
    },
    header: {
        zIndex: 1
    },
    absolute: {
        position: 'absolute',
        top: 0,
        start: 0,
        end: 0
    },
    translucent: {
        position: 'absolute',
        top: 0,
        start: 0,
        end: 0,
        zIndex: 1,
        elevation: 1
    },
    background: {
        overflow: 'hidden'
    }
}); //# sourceMappingURL=NativeStackView.native.js.map


}),
27840: (function (__unused_webpack_module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _object_spread = __webpack_require__(36192);
var _sliced_to_array = __webpack_require__(78474);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.useHeaderConfigProps = useHeaderConfigProps;
var _elements = __webpack_require__(69372);
var _native = __webpack_require__(57102);
var _reactNative = __webpack_require__(56300);
var _reactNativeScreens = __webpack_require__(47743);
var _FontProcessor = __webpack_require__(76974);
var _jsxRuntime = __webpack_require__(70095);
function useHeaderConfigProps(ref) {
    var headerBackImageSource = ref.headerBackImageSource, headerBackButtonDisplayMode = ref.headerBackButtonDisplayMode, headerBackButtonMenuEnabled = ref.headerBackButtonMenuEnabled, headerBackTitle = ref.headerBackTitle, headerBackTitleStyle = ref.headerBackTitleStyle, headerBackVisible = ref.headerBackVisible, headerShadowVisible = ref.headerShadowVisible, headerLargeStyle = ref.headerLargeStyle, headerLargeTitle = ref.headerLargeTitle, headerLargeTitleShadowVisible = ref.headerLargeTitleShadowVisible, headerLargeTitleStyle = ref.headerLargeTitleStyle, headerBackground = ref.headerBackground, headerLeft = ref.headerLeft, headerRight = ref.headerRight, headerShown = ref.headerShown, headerStyle = ref.headerStyle, headerBlurEffect = ref.headerBlurEffect, headerTintColor = ref.headerTintColor, headerTitle = ref.headerTitle, headerTitleAlign = ref.headerTitleAlign, headerTitleStyle = ref.headerTitleStyle, headerTransparent = ref.headerTransparent, headerSearchBarOptions = ref.headerSearchBarOptions, headerTopInsetEnabled = ref.headerTopInsetEnabled, headerBack = ref.headerBack, route = ref.route, title = ref.title;
    var direction = (0, _native.useLocale)().direction;
    var _ref = (0, _native.useTheme)(), colors = _ref.colors, fonts = _ref.fonts;
    var tintColor = headerTintColor ?? (_reactNative.Platform.OS === 'ios' ? colors.primary : colors.text);
    var headerBackTitleStyleFlattened = _reactNative.StyleSheet.flatten([
        fonts.regular,
        headerBackTitleStyle
    ]) || {};
    var headerLargeTitleStyleFlattened = _reactNative.StyleSheet.flatten([
        _reactNative.Platform.select({
            ios: fonts.heavy,
            default: fonts.medium
        }),
        headerLargeTitleStyle
    ]) || {};
    var headerTitleStyleFlattened = _reactNative.StyleSheet.flatten([
        _reactNative.Platform.select({
            ios: fonts.bold,
            default: fonts.medium
        }),
        headerTitleStyle
    ]) || {};
    var headerStyleFlattened = _reactNative.StyleSheet.flatten(headerStyle) || {};
    var headerLargeStyleFlattened = _reactNative.StyleSheet.flatten(headerLargeStyle) || {};
    var _ref1 = _sliced_to_array._((0, _FontProcessor.processFonts)([
        headerBackTitleStyleFlattened.fontFamily,
        headerLargeTitleStyleFlattened.fontFamily,
        headerTitleStyleFlattened.fontFamily
    ]), 3), backTitleFontFamily = _ref1[0], largeTitleFontFamily = _ref1[1], titleFontFamily = _ref1[2];
    var backTitleFontSize = 'fontSize' in headerBackTitleStyleFlattened ? headerBackTitleStyleFlattened.fontSize : undefined;
    var titleText = (0, _elements.getHeaderTitle)({
        title,
        headerTitle
    }, route.name);
    var titleColor = 'color' in headerTitleStyleFlattened ? headerTitleStyleFlattened.color : headerTintColor ?? colors.text;
    var titleFontSize = 'fontSize' in headerTitleStyleFlattened ? headerTitleStyleFlattened.fontSize : undefined;
    var titleFontWeight = headerTitleStyleFlattened.fontWeight;
    var largeTitleBackgroundColor = headerLargeStyleFlattened.backgroundColor;
    var largeTitleColor = 'color' in headerLargeTitleStyleFlattened ? headerLargeTitleStyleFlattened.color : undefined;
    var largeTitleFontSize = 'fontSize' in headerLargeTitleStyleFlattened ? headerLargeTitleStyleFlattened.fontSize : undefined;
    var largeTitleFontWeight = headerLargeTitleStyleFlattened.fontWeight;
    var headerTitleStyleSupported = {
        color: titleColor
    };
    if (headerTitleStyleFlattened.fontFamily != null) {
        headerTitleStyleSupported.fontFamily = headerTitleStyleFlattened.fontFamily;
    }
    if (titleFontSize != null) {
        headerTitleStyleSupported.fontSize = titleFontSize;
    }
    if (titleFontWeight != null) {
        headerTitleStyleSupported.fontWeight = titleFontWeight;
    }
    var headerBackgroundColor = headerStyleFlattened.backgroundColor ?? (headerBackground != null || headerTransparent ? 'transparent' : colors.card);
    var canGoBack = headerBack != null;
    var headerLeftElement = headerLeft === null || headerLeft === void 0 ? void 0 : headerLeft({
        tintColor,
        canGoBack,
        label: headerBackTitle ?? (headerBack === null || headerBack === void 0 ? void 0 : headerBack.title),
        // `href` is only applicable to web
        href: undefined
    });
    var headerRightElement = headerRight === null || headerRight === void 0 ? void 0 : headerRight({
        tintColor,
        canGoBack
    });
    var headerTitleElement = typeof headerTitle === 'function' ? headerTitle({
        tintColor,
        children: titleText
    }) : null;
    var supportsHeaderSearchBar = typeof _reactNativeScreens.isSearchBarAvailableForCurrentPlatform === 'boolean' ? _reactNativeScreens.isSearchBarAvailableForCurrentPlatform : // Fallback for older versions of react-native-screens
    _reactNative.Platform.OS === 'ios' && _reactNativeScreens.SearchBar != null;
    var hasHeaderSearchBar = supportsHeaderSearchBar && headerSearchBarOptions != null;
    if (headerSearchBarOptions != null && !supportsHeaderSearchBar) {
        throw new Error(`The current version of 'react-native-screens' doesn't support SearchBar in the header. Please update to the latest version to use this option.`);
    }
    /**
   * We need to set this in if:
   * - Back button should stay visible when `headerLeft` is specified
   * - If `headerTitle` for Android is specified, so we only need to remove the title and keep the back button
   */ var backButtonInCustomView = headerBackVisible || _reactNative.Platform.OS === 'android' && headerTitleElement != null && headerLeftElement == null;
    var translucent = headerBackground != null || headerTransparent || // When using a SearchBar or large title, the header needs to be translucent for it to work on iOS
    (hasHeaderSearchBar || headerLargeTitle) && _reactNative.Platform.OS === 'ios' && headerTransparent !== false;
    var isBackButtonDisplayModeAvailable = // On iOS 14+
    _reactNative.Platform.OS === 'ios' && parseInt(_reactNative.Platform.Version, 10) >= 14 && // Doesn't have custom back title
    headerBackTitle == null && // Doesn't have custom styling
    backTitleFontFamily == null && backTitleFontSize == null && // Back button menu is not disabled
    headerBackButtonMenuEnabled !== false;
    var isCenterViewRenderedAndroid = headerTitleAlign === 'center';
    var children = /*#__PURE__*/ (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
        children: [
            _reactNative.Platform.OS === 'ios' ? /*#__PURE__*/ (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
                children: [
                    headerLeftElement != null ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNativeScreens.ScreenStackHeaderLeftView, {
                        children: headerLeftElement
                    }) : null,
                    headerTitleElement != null ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNativeScreens.ScreenStackHeaderCenterView, {
                        children: headerTitleElement
                    }) : null
                ]
            }) : /*#__PURE__*/ (0, _jsxRuntime.jsxs)(_jsxRuntime.Fragment, {
                children: [
                    headerLeftElement != null || typeof headerTitle === 'function' ? /*#__PURE__*/ // The style passed to header left, together with title element being wrapped
                    // in flex view is reqruied for proper header layout, in particular,
                    // for the text truncation to work.
                    (0, _jsxRuntime.jsxs)(_reactNativeScreens.ScreenStackHeaderLeftView, {
                        style: !isCenterViewRenderedAndroid ? {
                            flex: 1
                        } : null,
                        children: [
                            headerLeftElement,
                            headerTitleAlign !== 'center' ? typeof headerTitle === 'function' ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNative.View, {
                                style: {
                                    flex: 1
                                },
                                children: headerTitleElement
                            }) : /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNative.View, {
                                style: {
                                    flex: 1
                                },
                                children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_elements.HeaderTitle, {
                                    tintColor: tintColor,
                                    style: headerTitleStyleSupported,
                                    children: titleText
                                })
                            }) : null
                        ]
                    }) : null,
                    isCenterViewRenderedAndroid ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNativeScreens.ScreenStackHeaderCenterView, {
                        children: typeof headerTitle === 'function' ? headerTitleElement : /*#__PURE__*/ (0, _jsxRuntime.jsx)(_elements.HeaderTitle, {
                            tintColor: tintColor,
                            style: headerTitleStyleSupported,
                            children: titleText
                        })
                    }) : null
                ]
            }),
            headerBackImageSource !== undefined ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNativeScreens.ScreenStackHeaderBackButtonImage, {
                source: headerBackImageSource
            }) : null,
            headerRightElement != null ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNativeScreens.ScreenStackHeaderRightView, {
                children: headerRightElement
            }) : null,
            hasHeaderSearchBar ? /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNativeScreens.ScreenStackHeaderSearchBarView, {
                children: /*#__PURE__*/ (0, _jsxRuntime.jsx)(_reactNativeScreens.SearchBar, _object_spread._({}, headerSearchBarOptions))
            }) : null
        ]
    });
    return {
        backButtonInCustomView,
        backgroundColor: headerBackgroundColor,
        backTitle: headerBackTitle,
        backTitleVisible: isBackButtonDisplayModeAvailable ? undefined : headerBackButtonDisplayMode !== 'minimal',
        backButtonDisplayMode: isBackButtonDisplayModeAvailable ? headerBackButtonDisplayMode : undefined,
        backTitleFontFamily,
        backTitleFontSize,
        blurEffect: headerBlurEffect,
        color: tintColor,
        direction,
        disableBackButtonMenu: headerBackButtonMenuEnabled === false,
        hidden: headerShown === false,
        hideBackButton: headerBackVisible === false,
        hideShadow: headerShadowVisible === false || headerBackground != null || headerTransparent && headerShadowVisible !== true,
        largeTitle: headerLargeTitle,
        largeTitleBackgroundColor,
        largeTitleColor,
        largeTitleFontFamily,
        largeTitleFontSize,
        largeTitleFontWeight,
        largeTitleHideShadow: headerLargeTitleShadowVisible === false,
        title: titleText,
        titleColor,
        titleFontFamily,
        titleFontSize,
        titleFontWeight: String(titleFontWeight),
        topInsetEnabled: headerTopInsetEnabled,
        translucent: translucent === true,
        children
    };
} //# sourceMappingURL=useHeaderConfigProps.js.map


}),

}]);//# sourceMappingURL=vendors-node_modules_react-navigation_native-stack_lib_commonjs_index_js.chunk.bundle.map?platform=android