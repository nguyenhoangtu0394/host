{"version":3,"file":"vendors-node_modules_react-navigation_native_src_index_tsx.chunk.bundle","sources":["webpack://claim/./node_modules/@swc/helpers/cjs/_to_primitive.cjs","webpack://claim/./node_modules/@swc/helpers/cjs/_to_property_key.cjs","webpack://claim/./node_modules/decode-uri-component/index.js","webpack://claim/./node_modules/escape-string-regexp/index.js","webpack://claim/./node_modules/filter-obj/index.js","webpack://claim/./node_modules/nanoid/non-secure/index.js","webpack://claim/./node_modules/query-string/index.js","webpack://claim/./node_modules/react-is/cjs/react-is.development.js","webpack://claim/./node_modules/react-is/index.js","webpack://claim/./node_modules/split-on-first/index.js","webpack://claim/./node_modules/strict-uri-encode/index.js","webpack://claim/./node_modules/use-latest-callback/lib/src/index.js","webpack://claim/./node_modules/use-latest-callback/lib/src/useIsomorphicLayoutEffect.native.js","webpack://claim/./node_modules/@react-navigation/core/src/BaseNavigationContainer.tsx","webpack://claim/./node_modules/@react-navigation/core/src/CurrentRenderContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/EnsureSingleNavigator.tsx","webpack://claim/./node_modules/@react-navigation/core/src/Group.tsx","webpack://claim/./node_modules/@react-navigation/core/src/NavigationBuilderContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/NavigationContainerRefContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/NavigationContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/NavigationHelpersContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/NavigationRouteContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/NavigationStateContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/PreventRemoveContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/PreventRemoveProvider.tsx","webpack://claim/./node_modules/@react-navigation/core/src/SceneView.tsx","webpack://claim/./node_modules/@react-navigation/core/src/Screen.tsx","webpack://claim/./node_modules/@react-navigation/core/src/StaticContainer.tsx","webpack://claim/./node_modules/@react-navigation/core/src/UnhandledActionContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/checkDuplicateRouteNames.tsx","webpack://claim/./node_modules/@react-navigation/core/src/checkSerializable.tsx","webpack://claim/./node_modules/@react-navigation/core/src/createNavigationContainerRef.tsx","webpack://claim/./node_modules/@react-navigation/core/src/createNavigatorFactory.tsx","webpack://claim/./node_modules/@react-navigation/core/src/findFocusedRoute.tsx","webpack://claim/./node_modules/@react-navigation/core/src/fromEntries.tsx","webpack://claim/./node_modules/@react-navigation/core/src/getActionFromState.tsx","webpack://claim/./node_modules/@react-navigation/core/src/getFocusedRouteNameFromRoute.tsx","webpack://claim/./node_modules/@react-navigation/core/src/getPathFromState.tsx","webpack://claim/./node_modules/@react-navigation/core/src/getStateFromPath.tsx","webpack://claim/./node_modules/@react-navigation/core/src/index.tsx","webpack://claim/./node_modules/@react-navigation/core/src/isArrayEqual.tsx","webpack://claim/./node_modules/@react-navigation/core/src/isRecordEqual.tsx","webpack://claim/./node_modules/@react-navigation/core/src/types.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useChildListeners.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useComponent.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useCurrentRender.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useDescriptors.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useEventEmitter.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useFocusEffect.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useFocusEvents.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useFocusedListenersChildrenAdapter.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useIsFocused.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useKeyedChildListeners.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useNavigation.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useNavigationBuilder.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useNavigationCache.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useNavigationContainerRef.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useNavigationHelpers.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useNavigationState.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useOnAction.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useOnGetState.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useOnPreventRemove.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useOnRouteFocus.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useOptionsGetters.tsx","webpack://claim/./node_modules/@react-navigation/core/src/usePreventRemove.tsx","webpack://claim/./node_modules/@react-navigation/core/src/usePreventRemoveContext.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useRegisterNavigator.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useRoute.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useRouteCache.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useScheduleUpdate.tsx","webpack://claim/./node_modules/@react-navigation/core/src/useSyncState.tsx","webpack://claim/./node_modules/@react-navigation/core/src/validatePathConfig.tsx","webpack://claim/./node_modules/@react-navigation/native/src/Link.tsx","webpack://claim/./node_modules/@react-navigation/native/src/LinkingContext.tsx","webpack://claim/./node_modules/@react-navigation/native/src/NavigationContainer.tsx","webpack://claim/./node_modules/@react-navigation/native/src/ServerContainer.tsx","webpack://claim/./node_modules/@react-navigation/native/src/ServerContext.tsx","webpack://claim/./node_modules/@react-navigation/native/src/extractPathFromURL.tsx","webpack://claim/./node_modules/@react-navigation/native/src/index.tsx","webpack://claim/./node_modules/@react-navigation/native/src/theming/DarkTheme.tsx","webpack://claim/./node_modules/@react-navigation/native/src/theming/DefaultTheme.tsx","webpack://claim/./node_modules/@react-navigation/native/src/theming/ThemeContext.tsx","webpack://claim/./node_modules/@react-navigation/native/src/theming/ThemeProvider.tsx","webpack://claim/./node_modules/@react-navigation/native/src/theming/useTheme.tsx","webpack://claim/./node_modules/@react-navigation/native/src/useBackButton.native.tsx","webpack://claim/./node_modules/@react-navigation/native/src/useDocumentTitle.native.tsx","webpack://claim/./node_modules/@react-navigation/native/src/useLinkBuilder.tsx","webpack://claim/./node_modules/@react-navigation/native/src/useLinkProps.tsx","webpack://claim/./node_modules/@react-navigation/native/src/useLinkTo.tsx","webpack://claim/./node_modules/@react-navigation/native/src/useLinking.native.tsx","webpack://claim/./node_modules/@react-navigation/native/src/useScrollToTop.tsx","webpack://claim/./node_modules/@react-navigation/native/src/useThenable.tsx","webpack://claim/./node_modules/@react-navigation/routers/src/BaseRouter.tsx","webpack://claim/./node_modules/@react-navigation/routers/src/CommonActions.tsx","webpack://claim/./node_modules/@react-navigation/routers/src/DrawerRouter.tsx","webpack://claim/./node_modules/@react-navigation/routers/src/StackRouter.tsx","webpack://claim/./node_modules/@react-navigation/routers/src/TabRouter.tsx","webpack://claim/./node_modules/@react-navigation/routers/src/index.tsx"],"sourcesContent":["\"use strict\";\n\nvar _type_of = require(\"./_type_of.cjs\");\n\nfunction _to_primitive(input, hint) {\n    if (_type_of._(input) !== \"object\" || input === null) return input;\n\n    var prim = input[Symbol.toPrimitive];\n\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (_type_of._(res) !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n\n    return (hint === \"string\" ? String : Number)(input);\n}\nexports._ = _to_primitive;\n","\"use strict\";\n\nvar _to_primitive = require(\"./_to_primitive.cjs\");\nvar _type_of = require(\"./_type_of.cjs\");\n\nfunction _to_property_key(arg) {\n    var key = _to_primitive._(arg, \"string\");\n\n    return _type_of._(key) === \"symbol\" ? key : String(key);\n}\nexports._ = _to_property_key;\n","'use strict';\nvar token = '%[a-f0-9]{2}';\nvar singleMatcher = new RegExp('(' + token + ')|([^%]+?)', 'gi');\nvar multiMatcher = new RegExp('(' + token + ')+', 'gi');\n\nfunction decodeComponents(components, split) {\n\ttry {\n\t\t// Try to decode the entire string first\n\t\treturn [decodeURIComponent(components.join(''))];\n\t} catch (err) {\n\t\t// Do nothing\n\t}\n\n\tif (components.length === 1) {\n\t\treturn components;\n\t}\n\n\tsplit = split || 1;\n\n\t// Split the array in 2 parts\n\tvar left = components.slice(0, split);\n\tvar right = components.slice(split);\n\n\treturn Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));\n}\n\nfunction decode(input) {\n\ttry {\n\t\treturn decodeURIComponent(input);\n\t} catch (err) {\n\t\tvar tokens = input.match(singleMatcher) || [];\n\n\t\tfor (var i = 1; i < tokens.length; i++) {\n\t\t\tinput = decodeComponents(tokens, i).join('');\n\n\t\t\ttokens = input.match(singleMatcher) || [];\n\t\t}\n\n\t\treturn input;\n\t}\n}\n\nfunction customDecodeURIComponent(input) {\n\t// Keep track of all the replacements and prefill the map with the `BOM`\n\tvar replaceMap = {\n\t\t'%FE%FF': '\\uFFFD\\uFFFD',\n\t\t'%FF%FE': '\\uFFFD\\uFFFD'\n\t};\n\n\tvar match = multiMatcher.exec(input);\n\twhile (match) {\n\t\ttry {\n\t\t\t// Decode as big chunks as possible\n\t\t\treplaceMap[match[0]] = decodeURIComponent(match[0]);\n\t\t} catch (err) {\n\t\t\tvar result = decode(match[0]);\n\n\t\t\tif (result !== match[0]) {\n\t\t\t\treplaceMap[match[0]] = result;\n\t\t\t}\n\t\t}\n\n\t\tmatch = multiMatcher.exec(input);\n\t}\n\n\t// Add `%C2` at the end of the map to make sure it does not replace the combinator before everything else\n\treplaceMap['%C2'] = '\\uFFFD';\n\n\tvar entries = Object.keys(replaceMap);\n\n\tfor (var i = 0; i < entries.length; i++) {\n\t\t// Replace all decoded components\n\t\tvar key = entries[i];\n\t\tinput = input.replace(new RegExp(key, 'g'), replaceMap[key]);\n\t}\n\n\treturn input;\n}\n\nmodule.exports = function (encodedURI) {\n\tif (typeof encodedURI !== 'string') {\n\t\tthrow new TypeError('Expected `encodedURI` to be of type `string`, got `' + typeof encodedURI + '`');\n\t}\n\n\ttry {\n\t\tencodedURI = encodedURI.replace(/\\+/g, ' ');\n\n\t\t// Try the built in decoder first\n\t\treturn decodeURIComponent(encodedURI);\n\t} catch (err) {\n\t\t// Fallback to a more advanced decoder\n\t\treturn customDecodeURIComponent(encodedURI);\n\t}\n};\n","'use strict';\n\nmodule.exports = string => {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\t// Escape characters with special meaning either inside or outside character sets.\n\t// Use a simple backslash escape when it’s always valid, and a \\unnnn escape when the simpler form would be disallowed by Unicode patterns’ stricter grammar.\n\treturn string\n\t\t.replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&')\n\t\t.replace(/-/g, '\\\\x2d');\n};\n","'use strict';\nmodule.exports = function (obj, predicate) {\n\tvar ret = {};\n\tvar keys = Object.keys(obj);\n\tvar isArr = Array.isArray(predicate);\n\n\tfor (var i = 0; i < keys.length; i++) {\n\t\tvar key = keys[i];\n\t\tvar val = obj[key];\n\n\t\tif (isArr ? predicate.indexOf(key) !== -1 : predicate(key, val, obj)) {\n\t\t\tret[key] = val;\n\t\t}\n\t}\n\n\treturn ret;\n};\n","let urlAlphabet =\n  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'\nlet customAlphabet = (alphabet, defaultSize = 21) => {\n  return (size = defaultSize) => {\n    let id = ''\n    let i = size | 0\n    while (i--) {\n      id += alphabet[(Math.random() * alphabet.length) | 0]\n    }\n    return id\n  }\n}\nlet nanoid = (size = 21) => {\n  let id = ''\n  let i = size | 0\n  while (i--) {\n    id += urlAlphabet[(Math.random() * 64) | 0]\n  }\n  return id\n}\nexport { nanoid, customAlphabet }\n","'use strict';\nconst strictUriEncode = require('strict-uri-encode');\nconst decodeComponent = require('decode-uri-component');\nconst splitOnFirst = require('split-on-first');\nconst filterObject = require('filter-obj');\n\nconst isNullOrUndefined = value => value === null || value === undefined;\n\nconst encodeFragmentIdentifier = Symbol('encodeFragmentIdentifier');\n\nfunction encoderForArrayFormat(options) {\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tconst index = result.length;\n\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[', index, ']'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [\n\t\t\t\t\t...result,\n\t\t\t\t\t[encode(key, options), '[', encode(index, options), ']=', encode(value, options)].join('')\n\t\t\t\t];\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), '[]'].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '[]=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'colon-list-separator':\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, [encode(key, options), ':list='].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), ':list=', encode(value, options)].join('')];\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\tcase 'bracket-separator': {\n\t\t\tconst keyValueSep = options.arrayFormat === 'bracket-separator' ?\n\t\t\t\t'[]=' :\n\t\t\t\t'=';\n\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\t// Translate null to an empty string so that it doesn't serialize as 'null'\n\t\t\t\tvalue = value === null ? '' : value;\n\n\t\t\t\tif (result.length === 0) {\n\t\t\t\t\treturn [[encode(key, options), keyValueSep, encode(value, options)].join('')];\n\t\t\t\t}\n\n\t\t\t\treturn [[result, encode(value, options)].join(options.arrayFormatSeparator)];\n\t\t\t};\n\t\t}\n\n\t\tdefault:\n\t\t\treturn key => (result, value) => {\n\t\t\t\tif (\n\t\t\t\t\tvalue === undefined ||\n\t\t\t\t\t(options.skipNull && value === null) ||\n\t\t\t\t\t(options.skipEmptyString && value === '')\n\t\t\t\t) {\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\n\t\t\t\tif (value === null) {\n\t\t\t\t\treturn [...result, encode(key, options)];\n\t\t\t\t}\n\n\t\t\t\treturn [...result, [encode(key, options), '=', encode(value, options)].join('')];\n\t\t\t};\n\t}\n}\n\nfunction parserForArrayFormat(options) {\n\tlet result;\n\n\tswitch (options.arrayFormat) {\n\t\tcase 'index':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /\\[(\\d*)\\]$/.exec(key);\n\n\t\t\t\tkey = key.replace(/\\[\\d*\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = {};\n\t\t\t\t}\n\n\t\t\t\taccumulator[key][result[1]] = value;\n\t\t\t};\n\n\t\tcase 'bracket':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(\\[\\])$/.exec(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'colon-list-separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tresult = /(:list)$/.exec(key);\n\t\t\t\tkey = key.replace(/:list$/, '');\n\n\t\t\t\tif (!result) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = [value];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\n\t\tcase 'comma':\n\t\tcase 'separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = typeof value === 'string' && value.includes(options.arrayFormatSeparator);\n\t\t\t\tconst isEncodedArray = (typeof value === 'string' && !isArray && decode(value, options).includes(options.arrayFormatSeparator));\n\t\t\t\tvalue = isEncodedArray ? decode(value, options) : value;\n\t\t\t\tconst newValue = isArray || isEncodedArray ? value.split(options.arrayFormatSeparator).map(item => decode(item, options)) : value === null ? value : decode(value, options);\n\t\t\t\taccumulator[key] = newValue;\n\t\t\t};\n\n\t\tcase 'bracket-separator':\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tconst isArray = /(\\[\\])$/.test(key);\n\t\t\t\tkey = key.replace(/\\[\\]$/, '');\n\n\t\t\t\tif (!isArray) {\n\t\t\t\t\taccumulator[key] = value ? decode(value, options) : value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst arrayValue = value === null ?\n\t\t\t\t\t[] :\n\t\t\t\t\tvalue.split(options.arrayFormatSeparator).map(item => decode(item, options));\n\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = arrayValue;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], arrayValue);\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn (key, value, accumulator) => {\n\t\t\t\tif (accumulator[key] === undefined) {\n\t\t\t\t\taccumulator[key] = value;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\taccumulator[key] = [].concat(accumulator[key], value);\n\t\t\t};\n\t}\n}\n\nfunction validateArrayFormatSeparator(value) {\n\tif (typeof value !== 'string' || value.length !== 1) {\n\t\tthrow new TypeError('arrayFormatSeparator must be single character string');\n\t}\n}\n\nfunction encode(value, options) {\n\tif (options.encode) {\n\t\treturn options.strict ? strictUriEncode(value) : encodeURIComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction decode(value, options) {\n\tif (options.decode) {\n\t\treturn decodeComponent(value);\n\t}\n\n\treturn value;\n}\n\nfunction keysSorter(input) {\n\tif (Array.isArray(input)) {\n\t\treturn input.sort();\n\t}\n\n\tif (typeof input === 'object') {\n\t\treturn keysSorter(Object.keys(input))\n\t\t\t.sort((a, b) => Number(a) - Number(b))\n\t\t\t.map(key => input[key]);\n\t}\n\n\treturn input;\n}\n\nfunction removeHash(input) {\n\tconst hashStart = input.indexOf('#');\n\tif (hashStart !== -1) {\n\t\tinput = input.slice(0, hashStart);\n\t}\n\n\treturn input;\n}\n\nfunction getHash(url) {\n\tlet hash = '';\n\tconst hashStart = url.indexOf('#');\n\tif (hashStart !== -1) {\n\t\thash = url.slice(hashStart);\n\t}\n\n\treturn hash;\n}\n\nfunction extract(input) {\n\tinput = removeHash(input);\n\tconst queryStart = input.indexOf('?');\n\tif (queryStart === -1) {\n\t\treturn '';\n\t}\n\n\treturn input.slice(queryStart + 1);\n}\n\nfunction parseValue(value, options) {\n\tif (options.parseNumbers && !Number.isNaN(Number(value)) && (typeof value === 'string' && value.trim() !== '')) {\n\t\tvalue = Number(value);\n\t} else if (options.parseBooleans && value !== null && (value.toLowerCase() === 'true' || value.toLowerCase() === 'false')) {\n\t\tvalue = value.toLowerCase() === 'true';\n\t}\n\n\treturn value;\n}\n\nfunction parse(query, options) {\n\toptions = Object.assign({\n\t\tdecode: true,\n\t\tsort: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ',',\n\t\tparseNumbers: false,\n\t\tparseBooleans: false\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst formatter = parserForArrayFormat(options);\n\n\t// Create an object with no prototype\n\tconst ret = Object.create(null);\n\n\tif (typeof query !== 'string') {\n\t\treturn ret;\n\t}\n\n\tquery = query.trim().replace(/^[?#&]/, '');\n\n\tif (!query) {\n\t\treturn ret;\n\t}\n\n\tfor (const param of query.split('&')) {\n\t\tif (param === '') {\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet [key, value] = splitOnFirst(options.decode ? param.replace(/\\+/g, ' ') : param, '=');\n\n\t\t// Missing `=` should be `null`:\n\t\t// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\n\t\tvalue = value === undefined ? null : ['comma', 'separator', 'bracket-separator'].includes(options.arrayFormat) ? value : decode(value, options);\n\t\tformatter(decode(key, options), value, ret);\n\t}\n\n\tfor (const key of Object.keys(ret)) {\n\t\tconst value = ret[key];\n\t\tif (typeof value === 'object' && value !== null) {\n\t\t\tfor (const k of Object.keys(value)) {\n\t\t\t\tvalue[k] = parseValue(value[k], options);\n\t\t\t}\n\t\t} else {\n\t\t\tret[key] = parseValue(value, options);\n\t\t}\n\t}\n\n\tif (options.sort === false) {\n\t\treturn ret;\n\t}\n\n\treturn (options.sort === true ? Object.keys(ret).sort() : Object.keys(ret).sort(options.sort)).reduce((result, key) => {\n\t\tconst value = ret[key];\n\t\tif (Boolean(value) && typeof value === 'object' && !Array.isArray(value)) {\n\t\t\t// Sort object keys, not values\n\t\t\tresult[key] = keysSorter(value);\n\t\t} else {\n\t\t\tresult[key] = value;\n\t\t}\n\n\t\treturn result;\n\t}, Object.create(null));\n}\n\nexports.extract = extract;\nexports.parse = parse;\n\nexports.stringify = (object, options) => {\n\tif (!object) {\n\t\treturn '';\n\t}\n\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\tarrayFormat: 'none',\n\t\tarrayFormatSeparator: ','\n\t}, options);\n\n\tvalidateArrayFormatSeparator(options.arrayFormatSeparator);\n\n\tconst shouldFilter = key => (\n\t\t(options.skipNull && isNullOrUndefined(object[key])) ||\n\t\t(options.skipEmptyString && object[key] === '')\n\t);\n\n\tconst formatter = encoderForArrayFormat(options);\n\n\tconst objectCopy = {};\n\n\tfor (const key of Object.keys(object)) {\n\t\tif (!shouldFilter(key)) {\n\t\t\tobjectCopy[key] = object[key];\n\t\t}\n\t}\n\n\tconst keys = Object.keys(objectCopy);\n\n\tif (options.sort !== false) {\n\t\tkeys.sort(options.sort);\n\t}\n\n\treturn keys.map(key => {\n\t\tconst value = object[key];\n\n\t\tif (value === undefined) {\n\t\t\treturn '';\n\t\t}\n\n\t\tif (value === null) {\n\t\t\treturn encode(key, options);\n\t\t}\n\n\t\tif (Array.isArray(value)) {\n\t\t\tif (value.length === 0 && options.arrayFormat === 'bracket-separator') {\n\t\t\t\treturn encode(key, options) + '[]';\n\t\t\t}\n\n\t\t\treturn value\n\t\t\t\t.reduce(formatter(key), [])\n\t\t\t\t.join('&');\n\t\t}\n\n\t\treturn encode(key, options) + '=' + encode(value, options);\n\t}).filter(x => x.length > 0).join('&');\n};\n\nexports.parseUrl = (url, options) => {\n\toptions = Object.assign({\n\t\tdecode: true\n\t}, options);\n\n\tconst [url_, hash] = splitOnFirst(url, '#');\n\n\treturn Object.assign(\n\t\t{\n\t\t\turl: url_.split('?')[0] || '',\n\t\t\tquery: parse(extract(url), options)\n\t\t},\n\t\toptions && options.parseFragmentIdentifier && hash ? {fragmentIdentifier: decode(hash, options)} : {}\n\t);\n};\n\nexports.stringifyUrl = (object, options) => {\n\toptions = Object.assign({\n\t\tencode: true,\n\t\tstrict: true,\n\t\t[encodeFragmentIdentifier]: true\n\t}, options);\n\n\tconst url = removeHash(object.url).split('?')[0] || '';\n\tconst queryFromUrl = exports.extract(object.url);\n\tconst parsedQueryFromUrl = exports.parse(queryFromUrl, {sort: false});\n\n\tconst query = Object.assign(parsedQueryFromUrl, object.query);\n\tlet queryString = exports.stringify(query, options);\n\tif (queryString) {\n\t\tqueryString = `?${queryString}`;\n\t}\n\n\tlet hash = getHash(object.url);\n\tif (object.fragmentIdentifier) {\n\t\thash = `#${options[encodeFragmentIdentifier] ? encode(object.fragmentIdentifier, options) : object.fragmentIdentifier}`;\n\t}\n\n\treturn `${url}${queryString}${hash}`;\n};\n\nexports.pick = (input, filter, options) => {\n\toptions = Object.assign({\n\t\tparseFragmentIdentifier: true,\n\t\t[encodeFragmentIdentifier]: false\n\t}, options);\n\n\tconst {url, query, fragmentIdentifier} = exports.parseUrl(input, options);\n\treturn exports.stringifyUrl({\n\t\turl,\n\t\tquery: filterObject(query, filter),\n\t\tfragmentIdentifier\n\t}, options);\n};\n\nexports.exclude = (input, filter, options) => {\n\tconst exclusionFilter = Array.isArray(filter) ? key => !filter.includes(key) : (key, value) => !filter(key, value);\n\n\treturn exports.pick(input, exclusionFilter, options);\n};\n","/** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar hasSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;\nvar REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;\nvar REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;\nvar REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;\nvar REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;\nvar REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;\nvar REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n// (unstable) APIs that have been removed. Can we remove the symbols?\n\nvar REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;\nvar REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;\nvar REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;\nvar REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;\nvar REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;\nvar REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;\nvar REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;\nvar REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;\nvar REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;\nvar REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;\n\nfunction isValidElementType(type) {\n  return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n  type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n}\n\nfunction typeOf(object) {\n  if (typeof object === 'object' && object !== null) {\n    var $$typeof = object.$$typeof;\n\n    switch ($$typeof) {\n      case REACT_ELEMENT_TYPE:\n        var type = object.type;\n\n        switch (type) {\n          case REACT_ASYNC_MODE_TYPE:\n          case REACT_CONCURRENT_MODE_TYPE:\n          case REACT_FRAGMENT_TYPE:\n          case REACT_PROFILER_TYPE:\n          case REACT_STRICT_MODE_TYPE:\n          case REACT_SUSPENSE_TYPE:\n            return type;\n\n          default:\n            var $$typeofType = type && type.$$typeof;\n\n            switch ($$typeofType) {\n              case REACT_CONTEXT_TYPE:\n              case REACT_FORWARD_REF_TYPE:\n              case REACT_LAZY_TYPE:\n              case REACT_MEMO_TYPE:\n              case REACT_PROVIDER_TYPE:\n                return $$typeofType;\n\n              default:\n                return $$typeof;\n            }\n\n        }\n\n      case REACT_PORTAL_TYPE:\n        return $$typeof;\n    }\n  }\n\n  return undefined;\n} // AsyncMode is deprecated along with isAsyncMode\n\nvar AsyncMode = REACT_ASYNC_MODE_TYPE;\nvar ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\nvar ContextConsumer = REACT_CONTEXT_TYPE;\nvar ContextProvider = REACT_PROVIDER_TYPE;\nvar Element = REACT_ELEMENT_TYPE;\nvar ForwardRef = REACT_FORWARD_REF_TYPE;\nvar Fragment = REACT_FRAGMENT_TYPE;\nvar Lazy = REACT_LAZY_TYPE;\nvar Memo = REACT_MEMO_TYPE;\nvar Portal = REACT_PORTAL_TYPE;\nvar Profiler = REACT_PROFILER_TYPE;\nvar StrictMode = REACT_STRICT_MODE_TYPE;\nvar Suspense = REACT_SUSPENSE_TYPE;\nvar hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n\nfunction isAsyncMode(object) {\n  {\n    if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n      hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n\n      console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');\n    }\n  }\n\n  return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n}\nfunction isConcurrentMode(object) {\n  return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n}\nfunction isContextConsumer(object) {\n  return typeOf(object) === REACT_CONTEXT_TYPE;\n}\nfunction isContextProvider(object) {\n  return typeOf(object) === REACT_PROVIDER_TYPE;\n}\nfunction isElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nfunction isForwardRef(object) {\n  return typeOf(object) === REACT_FORWARD_REF_TYPE;\n}\nfunction isFragment(object) {\n  return typeOf(object) === REACT_FRAGMENT_TYPE;\n}\nfunction isLazy(object) {\n  return typeOf(object) === REACT_LAZY_TYPE;\n}\nfunction isMemo(object) {\n  return typeOf(object) === REACT_MEMO_TYPE;\n}\nfunction isPortal(object) {\n  return typeOf(object) === REACT_PORTAL_TYPE;\n}\nfunction isProfiler(object) {\n  return typeOf(object) === REACT_PROFILER_TYPE;\n}\nfunction isStrictMode(object) {\n  return typeOf(object) === REACT_STRICT_MODE_TYPE;\n}\nfunction isSuspense(object) {\n  return typeOf(object) === REACT_SUSPENSE_TYPE;\n}\n\nexports.AsyncMode = AsyncMode;\nexports.ConcurrentMode = ConcurrentMode;\nexports.ContextConsumer = ContextConsumer;\nexports.ContextProvider = ContextProvider;\nexports.Element = Element;\nexports.ForwardRef = ForwardRef;\nexports.Fragment = Fragment;\nexports.Lazy = Lazy;\nexports.Memo = Memo;\nexports.Portal = Portal;\nexports.Profiler = Profiler;\nexports.StrictMode = StrictMode;\nexports.Suspense = Suspense;\nexports.isAsyncMode = isAsyncMode;\nexports.isConcurrentMode = isConcurrentMode;\nexports.isContextConsumer = isContextConsumer;\nexports.isContextProvider = isContextProvider;\nexports.isElement = isElement;\nexports.isForwardRef = isForwardRef;\nexports.isFragment = isFragment;\nexports.isLazy = isLazy;\nexports.isMemo = isMemo;\nexports.isPortal = isPortal;\nexports.isProfiler = isProfiler;\nexports.isStrictMode = isStrictMode;\nexports.isSuspense = isSuspense;\nexports.isValidElementType = isValidElementType;\nexports.typeOf = typeOf;\n  })();\n}\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-is.production.min.js');\n} else {\n  module.exports = require('./cjs/react-is.development.js');\n}\n","'use strict';\n\nmodule.exports = (string, separator) => {\n\tif (!(typeof string === 'string' && typeof separator === 'string')) {\n\t\tthrow new TypeError('Expected the arguments to be of type `string`');\n\t}\n\n\tif (separator === '') {\n\t\treturn [string];\n\t}\n\n\tconst separatorIndex = string.indexOf(separator);\n\n\tif (separatorIndex === -1) {\n\t\treturn [string];\n\t}\n\n\treturn [\n\t\tstring.slice(0, separatorIndex),\n\t\tstring.slice(separatorIndex + separator.length)\n\t];\n};\n","'use strict';\nmodule.exports = str => encodeURIComponent(str).replace(/[!'()*]/g, x => `%${x.charCodeAt(0).toString(16).toUpperCase()}`);\n","\"use strict\";\nvar React = require(\"react\");\nvar useIsomorphicLayoutEffect_1 = require(\"./useIsomorphicLayoutEffect\");\n/**\n * React hook which returns the latest callback without changing the reference.\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction useLatestCallback(callback) {\n    var ref = React.useRef(callback);\n    var latestCallback = React.useRef(function latestCallback() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return ref.current.apply(this, args);\n    }).current;\n    (0, useIsomorphicLayoutEffect_1.default)(function () {\n        ref.current = callback;\n    });\n    return latestCallback;\n}\nmodule.exports = useLatestCallback;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar react_1 = require(\"react\");\nexports.default = react_1.useLayoutEffect;\n","import {\n  CommonActions,\n  InitialState,\n  NavigationAction,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport checkDuplicateRouteNames from './checkDuplicateRouteNames';\nimport checkSerializable from './checkSerializable';\nimport { NOT_INITIALIZED_ERROR } from './createNavigationContainerRef';\nimport EnsureSingleNavigator from './EnsureSingleNavigator';\nimport findFocusedRoute from './findFocusedRoute';\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport NavigationContainerRefContext from './NavigationContainerRefContext';\nimport NavigationContext from './NavigationContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nimport NavigationStateContext from './NavigationStateContext';\nimport type {\n  NavigationContainerEventMap,\n  NavigationContainerProps,\n  NavigationContainerRef,\n} from './types';\nimport UnhandledActionContext from './UnhandledActionContext';\nimport useChildListeners from './useChildListeners';\nimport useEventEmitter from './useEventEmitter';\nimport useKeyedChildListeners from './useKeyedChildListeners';\nimport useOptionsGetters from './useOptionsGetters';\nimport { ScheduleUpdateContext } from './useScheduleUpdate';\nimport useSyncState from './useSyncState';\n\ntype State = NavigationState | PartialState<NavigationState> | undefined;\n\nconst serializableWarnings: string[] = [];\nconst duplicateNameWarnings: string[] = [];\n\n/**\n * Remove `key` and `routeNames` from the state objects recursively to get partial state.\n *\n * @param state Initial state object.\n */\nconst getPartialState = (\n  state: InitialState | undefined\n): PartialState<NavigationState> | undefined => {\n  if (state === undefined) {\n    return;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const { key, routeNames, ...partialState } = state;\n\n  return {\n    ...partialState,\n    stale: true,\n    routes: state.routes.map((route) => {\n      if (route.state === undefined) {\n        return route as Route<string> & {\n          state?: PartialState<NavigationState>;\n        };\n      }\n\n      return { ...route, state: getPartialState(route.state) };\n    }),\n  };\n};\n\n/**\n * Container component which holds the navigation state.\n * This should be rendered at the root wrapping the whole app.\n *\n * @param props.initialState Initial state object for the navigation tree.\n * @param props.onStateChange Callback which is called with the latest navigation state when it changes.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which refers to the navigation object containing helper methods.\n */\nconst BaseNavigationContainer = React.forwardRef(\n  function BaseNavigationContainer(\n    {\n      initialState,\n      onStateChange,\n      onUnhandledAction,\n      independent,\n      children,\n    }: NavigationContainerProps,\n    ref?: React.Ref<NavigationContainerRef<ParamListBase>>\n  ) {\n    const parent = React.useContext(NavigationStateContext);\n\n    if (!parent.isDefault && !independent) {\n      throw new Error(\n        \"Looks like you have nested a 'NavigationContainer' inside another. Normally you need only one container at the root of the app, so this was probably an error. If this was intentional, pass 'independent={true}' explicitly. Note that this will make the child navigators disconnected from the parent and you won't be able to navigate between them.\"\n      );\n    }\n\n    const [state, getState, setState, scheduleUpdate, flushUpdates] =\n      useSyncState<State>(() =>\n        getPartialState(initialState == null ? undefined : initialState)\n      );\n\n    const isFirstMountRef = React.useRef<boolean>(true);\n\n    const navigatorKeyRef = React.useRef<string | undefined>();\n\n    const getKey = React.useCallback(() => navigatorKeyRef.current, []);\n\n    const setKey = React.useCallback((key: string) => {\n      navigatorKeyRef.current = key;\n    }, []);\n\n    const { listeners, addListener } = useChildListeners();\n\n    const { keyedListeners, addKeyedListener } = useKeyedChildListeners();\n\n    const dispatch = React.useCallback(\n      (\n        action:\n          | NavigationAction\n          | ((state: NavigationState) => NavigationAction)\n      ) => {\n        if (listeners.focus[0] == null) {\n          console.error(NOT_INITIALIZED_ERROR);\n        } else {\n          listeners.focus[0]((navigation) => navigation.dispatch(action));\n        }\n      },\n      [listeners.focus]\n    );\n\n    const canGoBack = React.useCallback(() => {\n      if (listeners.focus[0] == null) {\n        return false;\n      }\n\n      const { result, handled } = listeners.focus[0]((navigation) =>\n        navigation.canGoBack()\n      );\n\n      if (handled) {\n        return result;\n      } else {\n        return false;\n      }\n    }, [listeners.focus]);\n\n    const resetRoot = React.useCallback(\n      (state?: PartialState<NavigationState> | NavigationState) => {\n        const target = state?.key ?? keyedListeners.getState.root?.().key;\n\n        if (target == null) {\n          console.error(NOT_INITIALIZED_ERROR);\n        } else {\n          listeners.focus[0]((navigation) =>\n            navigation.dispatch({\n              ...CommonActions.reset(state),\n              target,\n            })\n          );\n        }\n      },\n      [keyedListeners.getState, listeners.focus]\n    );\n\n    const getRootState = React.useCallback(() => {\n      return keyedListeners.getState.root?.();\n    }, [keyedListeners.getState]);\n\n    const getCurrentRoute = React.useCallback(() => {\n      const state = getRootState();\n\n      if (state == null) {\n        return undefined;\n      }\n\n      const route = findFocusedRoute(state);\n\n      return route as Route<string> | undefined;\n    }, [getRootState]);\n\n    const emitter = useEventEmitter<NavigationContainerEventMap>();\n\n    const { addOptionsGetter, getCurrentOptions } = useOptionsGetters({});\n\n    const navigation: NavigationContainerRef<ParamListBase> = React.useMemo(\n      () => ({\n        ...Object.keys(CommonActions).reduce<any>((acc, name) => {\n          acc[name] = (...args: any[]) =>\n            // @ts-expect-error: this is ok\n            dispatch(CommonActions[name](...args));\n          return acc;\n        }, {}),\n        ...emitter.create('root'),\n        dispatch,\n        resetRoot,\n        isFocused: () => true,\n        canGoBack,\n        getParent: () => undefined,\n        getState: () => stateRef.current,\n        getRootState,\n        getCurrentRoute,\n        getCurrentOptions,\n        isReady: () => listeners.focus[0] != null,\n        setOptions: () => {\n          throw new Error('Cannot call setOptions outside a screen');\n        },\n      }),\n      [\n        canGoBack,\n        dispatch,\n        emitter,\n        getCurrentOptions,\n        getCurrentRoute,\n        getRootState,\n        listeners.focus,\n        resetRoot,\n      ]\n    );\n\n    React.useImperativeHandle(ref, () => navigation, [navigation]);\n\n    const onDispatchAction = React.useCallback(\n      (action: NavigationAction, noop: boolean) => {\n        emitter.emit({\n          type: '__unsafe_action__',\n          data: { action, noop, stack: stackRef.current },\n        });\n      },\n      [emitter]\n    );\n\n    const lastEmittedOptionsRef = React.useRef<object | undefined>();\n\n    const onOptionsChange = React.useCallback(\n      (options: object) => {\n        if (lastEmittedOptionsRef.current === options) {\n          return;\n        }\n\n        lastEmittedOptionsRef.current = options;\n\n        emitter.emit({\n          type: 'options',\n          data: { options },\n        });\n      },\n      [emitter]\n    );\n\n    const stackRef = React.useRef<string | undefined>();\n\n    const builderContext = React.useMemo(\n      () => ({\n        addListener,\n        addKeyedListener,\n        onDispatchAction,\n        onOptionsChange,\n        stackRef,\n      }),\n      [addListener, addKeyedListener, onDispatchAction, onOptionsChange]\n    );\n\n    const scheduleContext = React.useMemo(\n      () => ({ scheduleUpdate, flushUpdates }),\n      [scheduleUpdate, flushUpdates]\n    );\n\n    const isInitialRef = React.useRef(true);\n\n    const getIsInitial = React.useCallback(() => isInitialRef.current, []);\n\n    const context = React.useMemo(\n      () => ({\n        state,\n        getState,\n        setState,\n        getKey,\n        setKey,\n        getIsInitial,\n        addOptionsGetter,\n      }),\n      [\n        state,\n        getState,\n        setState,\n        getKey,\n        setKey,\n        getIsInitial,\n        addOptionsGetter,\n      ]\n    );\n\n    const onStateChangeRef = React.useRef(onStateChange);\n    const stateRef = React.useRef(state);\n\n    React.useEffect(() => {\n      isInitialRef.current = false;\n      onStateChangeRef.current = onStateChange;\n      stateRef.current = state;\n    });\n\n    React.useEffect(() => {\n      const hydratedState = getRootState();\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (hydratedState !== undefined) {\n          const serializableResult = checkSerializable(hydratedState);\n\n          if (!serializableResult.serializable) {\n            const { location, reason } = serializableResult;\n\n            let path = '';\n            let pointer: Record<any, any> = hydratedState;\n            let params = false;\n\n            for (let i = 0; i < location.length; i++) {\n              const curr = location[i];\n              const prev = location[i - 1];\n\n              pointer = pointer[curr];\n\n              if (!params && curr === 'state') {\n                continue;\n              } else if (!params && curr === 'routes') {\n                if (path) {\n                  path += ' > ';\n                }\n              } else if (\n                !params &&\n                typeof curr === 'number' &&\n                prev === 'routes'\n              ) {\n                path += pointer?.name;\n              } else if (!params) {\n                path += ` > ${curr}`;\n                params = true;\n              } else {\n                if (typeof curr === 'number' || /^[0-9]+$/.test(curr)) {\n                  path += `[${curr}]`;\n                } else if (/^[a-z$_]+$/i.test(curr)) {\n                  path += `.${curr}`;\n                } else {\n                  path += `[${JSON.stringify(curr)}]`;\n                }\n              }\n            }\n\n            const message = `Non-serializable values were found in the navigation state. Check:\\n\\n${path} (${reason})\\n\\nThis can break usage such as persisting and restoring state. This might happen if you passed non-serializable values such as function, class instances etc. in params. If you need to use components with callbacks in your options, you can use 'navigation.setOptions' instead. See https://reactnavigation.org/docs/troubleshooting#i-get-the-warning-non-serializable-values-were-found-in-the-navigation-state for more details.`;\n\n            if (!serializableWarnings.includes(message)) {\n              serializableWarnings.push(message);\n              console.warn(message);\n            }\n          }\n\n          const duplicateRouteNamesResult =\n            checkDuplicateRouteNames(hydratedState);\n\n          if (duplicateRouteNamesResult.length) {\n            const message = `Found screens with the same name nested inside one another. Check:\\n${duplicateRouteNamesResult.map(\n              (locations) => `\\n${locations.join(', ')}`\n            )}\\n\\nThis can cause confusing behavior during navigation. Consider using unique names for each screen instead.`;\n\n            if (!duplicateNameWarnings.includes(message)) {\n              duplicateNameWarnings.push(message);\n              console.warn(message);\n            }\n          }\n        }\n      }\n\n      emitter.emit({ type: 'state', data: { state } });\n\n      if (!isFirstMountRef.current && onStateChangeRef.current) {\n        onStateChangeRef.current(hydratedState);\n      }\n\n      isFirstMountRef.current = false;\n    }, [getRootState, emitter, state]);\n\n    const defaultOnUnhandledAction = React.useCallback(\n      (action: NavigationAction) => {\n        if (process.env.NODE_ENV === 'production') {\n          return;\n        }\n\n        const payload: Record<string, any> | undefined = action.payload;\n\n        let message = `The action '${action.type}'${\n          payload ? ` with payload ${JSON.stringify(action.payload)}` : ''\n        } was not handled by any navigator.`;\n\n        switch (action.type) {\n          case 'NAVIGATE':\n          case 'PUSH':\n          case 'REPLACE':\n          case 'JUMP_TO':\n            if (payload?.name) {\n              message += `\\n\\nDo you have a screen named '${payload.name}'?\\n\\nIf you're trying to navigate to a screen in a nested navigator, see https://reactnavigation.org/docs/nesting-navigators#navigating-to-a-screen-in-a-nested-navigator.`;\n            } else {\n              message += `\\n\\nYou need to pass the name of the screen to navigate to.\\n\\nSee https://reactnavigation.org/docs/navigation-actions for usage.`;\n            }\n\n            break;\n          case 'GO_BACK':\n          case 'POP':\n          case 'POP_TO_TOP':\n            message += `\\n\\nIs there any screen to go back to?`;\n            break;\n          case 'OPEN_DRAWER':\n          case 'CLOSE_DRAWER':\n          case 'TOGGLE_DRAWER':\n            message += `\\n\\nIs your screen inside a Drawer navigator?`;\n            break;\n        }\n\n        message += `\\n\\nThis is a development-only warning and won't be shown in production.`;\n\n        console.error(message);\n      },\n      []\n    );\n\n    let element = (\n      <NavigationContainerRefContext.Provider value={navigation}>\n        <ScheduleUpdateContext.Provider value={scheduleContext}>\n          <NavigationBuilderContext.Provider value={builderContext}>\n            <NavigationStateContext.Provider value={context}>\n              <UnhandledActionContext.Provider\n                value={onUnhandledAction ?? defaultOnUnhandledAction}\n              >\n                <EnsureSingleNavigator>{children}</EnsureSingleNavigator>\n              </UnhandledActionContext.Provider>\n            </NavigationStateContext.Provider>\n          </NavigationBuilderContext.Provider>\n        </ScheduleUpdateContext.Provider>\n      </NavigationContainerRefContext.Provider>\n    );\n\n    if (independent) {\n      // We need to clear any existing contexts for nested independent container to work correctly\n      element = (\n        <NavigationRouteContext.Provider value={undefined}>\n          <NavigationContext.Provider value={undefined}>\n            {element}\n          </NavigationContext.Provider>\n        </NavigationRouteContext.Provider>\n      );\n    }\n\n    return element;\n  }\n);\n\nexport default BaseNavigationContainer;\n","import * as React from 'react';\n\n/**\n * Context which holds the values for the current navigation tree.\n * Intended for use in SSR. This is not safe to use on the client.\n */\nconst CurrentRenderContext = React.createContext<\n  { options?: object } | undefined\n>(undefined);\n\nexport default CurrentRenderContext;\n","import * as React from 'react';\n\ntype Props = {\n  children: React.ReactNode;\n};\n\nconst MULTIPLE_NAVIGATOR_ERROR = `Another navigator is already registered for this container. You likely have multiple navigators under a single \"NavigationContainer\" or \"Screen\". Make sure each navigator is under a separate \"Screen\" container. See https://reactnavigation.org/docs/nesting-navigators for a guide on nesting.`;\n\nexport const SingleNavigatorContext = React.createContext<\n  | {\n      register(key: string): void;\n      unregister(key: string): void;\n    }\n  | undefined\n>(undefined);\n\n/**\n * Component which ensures that there's only one navigator nested under it.\n */\nexport default function EnsureSingleNavigator({ children }: Props) {\n  const navigatorKeyRef = React.useRef<string | undefined>();\n\n  const value = React.useMemo(\n    () => ({\n      register(key: string) {\n        const currentKey = navigatorKeyRef.current;\n\n        if (currentKey !== undefined && key !== currentKey) {\n          throw new Error(MULTIPLE_NAVIGATOR_ERROR);\n        }\n\n        navigatorKeyRef.current = key;\n      },\n      unregister(key: string) {\n        const currentKey = navigatorKeyRef.current;\n\n        if (key !== currentKey) {\n          return;\n        }\n\n        navigatorKeyRef.current = undefined;\n      },\n    }),\n    []\n  );\n\n  return (\n    <SingleNavigatorContext.Provider value={value}>\n      {children}\n    </SingleNavigatorContext.Provider>\n  );\n}\n","import type { ParamListBase } from '@react-navigation/routers';\n\nimport type { RouteGroupConfig } from './types';\n\n/**\n * Empty component used for grouping screen configs.\n */\nexport default function Group<\n  ParamList extends ParamListBase,\n  ScreenOptions extends {}\n>(_: RouteGroupConfig<ParamList, ScreenOptions>) {\n  /* istanbul ignore next */\n  return null;\n}\n","import type {\n  NavigationAction,\n  NavigationState,\n  ParamListBase,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport type { NavigationHelpers } from './types';\n\nexport type ListenerMap = {\n  action: ChildActionListener;\n  focus: FocusedNavigationListener;\n};\n\nexport type KeyedListenerMap = {\n  getState: GetStateListener;\n  beforeRemove: ChildBeforeRemoveListener;\n};\n\nexport type AddListener = <T extends keyof ListenerMap>(\n  type: T,\n  listener: ListenerMap[T]\n) => void;\n\nexport type AddKeyedListener = <T extends keyof KeyedListenerMap>(\n  type: T,\n  key: string,\n  listener: KeyedListenerMap[T]\n) => void;\n\nexport type ChildActionListener = (\n  action: NavigationAction,\n  visitedNavigators?: Set<string>\n) => boolean;\n\nexport type FocusedNavigationCallback<T> = (\n  navigation: NavigationHelpers<ParamListBase>\n) => T;\n\nexport type FocusedNavigationListener = <T>(\n  callback: FocusedNavigationCallback<T>\n) => {\n  handled: boolean;\n  result: T;\n};\n\nexport type GetStateListener = () => NavigationState;\n\nexport type ChildBeforeRemoveListener = (action: NavigationAction) => boolean;\n\n/**\n * Context which holds the required helpers needed to build nested navigators.\n */\nconst NavigationBuilderContext = React.createContext<{\n  onAction?: (\n    action: NavigationAction,\n    visitedNavigators?: Set<string>\n  ) => boolean;\n  addListener?: AddListener;\n  addKeyedListener?: AddKeyedListener;\n  onRouteFocus?: (key: string) => void;\n  onDispatchAction: (action: NavigationAction, noop: boolean) => void;\n  onOptionsChange: (options: object) => void;\n  stackRef?: React.MutableRefObject<string | undefined>;\n}>({\n  onDispatchAction: () => undefined,\n  onOptionsChange: () => undefined,\n});\n\nexport default NavigationBuilderContext;\n","import type { ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport type { NavigationContainerRef } from './types';\n\n/**\n * Context which holds the route prop for a screen.\n */\nconst NavigationContainerRefContext = React.createContext<\n  NavigationContainerRef<ParamListBase> | undefined\n>(undefined);\n\nexport default NavigationContainerRefContext;\n","import type { ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport type { NavigationProp } from './types';\n\n/**\n * Context which holds the navigation prop for a screen.\n */\nconst NavigationContext = React.createContext<\n  NavigationProp<ParamListBase> | undefined\n>(undefined);\n\nexport default NavigationContext;\n","import type { ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport type { NavigationHelpers } from './types';\n\n/**\n * Context which holds the navigation helpers of the parent navigator.\n * Navigators should use this context in their view component.\n */\nconst NavigationHelpersContext = React.createContext<\n  NavigationHelpers<ParamListBase> | undefined\n>(undefined);\n\nexport default NavigationHelpersContext;\n","import type { Route } from '@react-navigation/routers';\nimport * as React from 'react';\n\n/**\n * Context which holds the route prop for a screen.\n */\nconst NavigationRouteContext = React.createContext<Route<string> | undefined>(\n  undefined\n);\n\nexport default NavigationRouteContext;\n","import type { NavigationState, PartialState } from '@react-navigation/routers';\nimport * as React from 'react';\n\nconst MISSING_CONTEXT_ERROR =\n  \"Couldn't find a navigation context. Have you wrapped your app with 'NavigationContainer'? See https://reactnavigation.org/docs/getting-started for setup instructions.\";\n\nexport default React.createContext<{\n  isDefault?: true;\n  state?: NavigationState | PartialState<NavigationState>;\n  getKey: () => string | undefined;\n  setKey: (key: string) => void;\n  getState: () => NavigationState | PartialState<NavigationState> | undefined;\n  setState: (\n    state: NavigationState | PartialState<NavigationState> | undefined\n  ) => void;\n  getIsInitial: () => boolean;\n  addOptionsGetter?: (\n    key: string,\n    getter: () => object | undefined | null\n  ) => void;\n}>({\n  isDefault: true,\n\n  get getKey(): any {\n    throw new Error(MISSING_CONTEXT_ERROR);\n  },\n  get setKey(): any {\n    throw new Error(MISSING_CONTEXT_ERROR);\n  },\n  get getState(): any {\n    throw new Error(MISSING_CONTEXT_ERROR);\n  },\n  get setState(): any {\n    throw new Error(MISSING_CONTEXT_ERROR);\n  },\n  get getIsInitial(): any {\n    throw new Error(MISSING_CONTEXT_ERROR);\n  },\n});\n","import * as React from 'react';\n\n/**\n * A type of an object that have a route key as an object key\n * and a value whether to prevent that route.\n */\nexport type PreventedRoutes = Record<string, { preventRemove: boolean }>;\n\nconst PreventRemoveContext = React.createContext<\n  | {\n      preventedRoutes: PreventedRoutes;\n      setPreventRemove: (\n        id: string,\n        routeKey: string,\n        preventRemove: boolean\n      ) => void;\n    }\n  | undefined\n>(undefined);\n\nexport default PreventRemoveContext;\n","import { nanoid } from 'nanoid/non-secure';\nimport * as React from 'react';\nimport useLatestCallback from 'use-latest-callback';\n\nimport NavigationHelpersContext from './NavigationHelpersContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nimport PreventRemoveContext, { PreventedRoutes } from './PreventRemoveContext';\n\ntype Props = {\n  children: React.ReactNode;\n};\n\ntype PreventedRoutesMap = Map<\n  string,\n  {\n    routeKey: string;\n    preventRemove: boolean;\n  }\n>;\n\n/**\n * Util function to transform map of prevented routes to a simpler object.\n */\nconst transformPreventedRoutes = (\n  preventedRoutesMap: PreventedRoutesMap\n): PreventedRoutes => {\n  const preventedRoutesToTransform = [...preventedRoutesMap.values()];\n\n  const preventedRoutes = preventedRoutesToTransform.reduce<PreventedRoutes>(\n    (acc, { routeKey, preventRemove }) => {\n      acc[routeKey] = {\n        preventRemove: acc[routeKey]?.preventRemove || preventRemove,\n      };\n      return acc;\n    },\n    {}\n  );\n\n  return preventedRoutes;\n};\n\n/**\n * Component used for managing which routes have to be prevented from removal in native-stack.\n */\nexport default function PreventRemoveProvider({ children }: Props) {\n  const [parentId] = React.useState(() => nanoid());\n  const [preventedRoutesMap, setPreventedRoutesMap] =\n    React.useState<PreventedRoutesMap>(new Map());\n\n  const navigation = React.useContext(NavigationHelpersContext);\n  const route = React.useContext(NavigationRouteContext);\n\n  const preventRemoveContextValue = React.useContext(PreventRemoveContext);\n  // take `setPreventRemove` from parent context - if exist it means we're in a nested context\n  const setParentPrevented = preventRemoveContextValue?.setPreventRemove;\n\n  const setPreventRemove = useLatestCallback(\n    (id: string, routeKey: string, preventRemove: boolean): void => {\n      if (\n        preventRemove &&\n        (navigation == null ||\n          navigation\n            ?.getState()\n            .routes.every((route) => route.key !== routeKey))\n      ) {\n        throw new Error(\n          `Couldn't find a route with the key ${routeKey}. Is your component inside NavigationContent?`\n        );\n      }\n\n      setPreventedRoutesMap((prevPrevented) => {\n        // values haven't changed - do nothing\n        if (\n          routeKey === prevPrevented.get(id)?.routeKey &&\n          preventRemove === prevPrevented.get(id)?.preventRemove\n        ) {\n          return prevPrevented;\n        }\n\n        const nextPrevented = new Map(prevPrevented);\n\n        if (preventRemove) {\n          nextPrevented.set(id, {\n            routeKey,\n            preventRemove,\n          });\n        } else {\n          nextPrevented.delete(id);\n        }\n\n        return nextPrevented;\n      });\n    }\n  );\n\n  const isPrevented = [...preventedRoutesMap.values()].some(\n    ({ preventRemove }) => preventRemove\n  );\n\n  React.useEffect(() => {\n    if (route?.key !== undefined && setParentPrevented !== undefined) {\n      // when route is defined (and setParentPrevented) it means we're in a nested stack\n      // route.key then will be the route key of parent\n      setParentPrevented(parentId, route.key, isPrevented);\n      return () => {\n        setParentPrevented(parentId, route.key, false);\n      };\n    }\n\n    return;\n  }, [parentId, isPrevented, route?.key, setParentPrevented]);\n\n  const value = React.useMemo(\n    () => ({\n      setPreventRemove,\n      preventedRoutes: transformPreventedRoutes(preventedRoutesMap),\n    }),\n    [setPreventRemove, preventedRoutesMap]\n  );\n\n  return (\n    <PreventRemoveContext.Provider value={value}>\n      {children}\n    </PreventRemoveContext.Provider>\n  );\n}\n","import type {\n  NavigationState,\n  ParamListBase,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport EnsureSingleNavigator from './EnsureSingleNavigator';\nimport NavigationStateContext from './NavigationStateContext';\nimport StaticContainer from './StaticContainer';\nimport type { NavigationProp, RouteConfigComponent } from './types';\nimport useOptionsGetters from './useOptionsGetters';\n\ntype Props<State extends NavigationState, ScreenOptions extends {}> = {\n  screen: RouteConfigComponent<ParamListBase, string> & { name: string };\n  navigation: NavigationProp<\n    ParamListBase,\n    string,\n    string | undefined,\n    State,\n    ScreenOptions\n  >;\n  route: Route<string>;\n  routeState: NavigationState | PartialState<NavigationState> | undefined;\n  getState: () => State;\n  setState: (state: State) => void;\n  options: object;\n  clearOptions: () => void;\n};\n\n/**\n * Component which takes care of rendering the screen for a route.\n * It provides all required contexts and applies optimizations when applicable.\n */\nexport default function SceneView<\n  State extends NavigationState,\n  ScreenOptions extends {}\n>({\n  screen,\n  route,\n  navigation,\n  routeState,\n  getState,\n  setState,\n  options,\n  clearOptions,\n}: Props<State, ScreenOptions>) {\n  const navigatorKeyRef = React.useRef<string | undefined>();\n  const getKey = React.useCallback(() => navigatorKeyRef.current, []);\n\n  const { addOptionsGetter } = useOptionsGetters({\n    key: route.key,\n    options,\n    navigation,\n  });\n\n  const setKey = React.useCallback((key: string) => {\n    navigatorKeyRef.current = key;\n  }, []);\n\n  const getCurrentState = React.useCallback(() => {\n    const state = getState();\n    const currentRoute = state.routes.find((r) => r.key === route.key);\n\n    return currentRoute ? currentRoute.state : undefined;\n  }, [getState, route.key]);\n\n  const setCurrentState = React.useCallback(\n    (child: NavigationState | PartialState<NavigationState> | undefined) => {\n      const state = getState();\n\n      setState({\n        ...state,\n        routes: state.routes.map((r) =>\n          r.key === route.key ? { ...r, state: child } : r\n        ),\n      });\n    },\n    [getState, route.key, setState]\n  );\n\n  const isInitialRef = React.useRef(true);\n\n  React.useEffect(() => {\n    isInitialRef.current = false;\n  });\n\n  // Clear options set by this screen when it is unmounted\n  React.useEffect(() => {\n    return clearOptions;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const getIsInitial = React.useCallback(() => isInitialRef.current, []);\n\n  const context = React.useMemo(\n    () => ({\n      state: routeState,\n      getState: getCurrentState,\n      setState: setCurrentState,\n      getKey,\n      setKey,\n      getIsInitial,\n      addOptionsGetter,\n    }),\n    [\n      routeState,\n      getCurrentState,\n      setCurrentState,\n      getKey,\n      setKey,\n      getIsInitial,\n      addOptionsGetter,\n    ]\n  );\n\n  const ScreenComponent = screen.getComponent\n    ? screen.getComponent()\n    : screen.component;\n\n  return (\n    <NavigationStateContext.Provider value={context}>\n      <EnsureSingleNavigator>\n        <StaticContainer\n          name={screen.name}\n          render={ScreenComponent || screen.children}\n          navigation={navigation}\n          route={route}\n        >\n          {ScreenComponent !== undefined ? (\n            <ScreenComponent navigation={navigation} route={route} />\n          ) : screen.children !== undefined ? (\n            screen.children({ navigation, route })\n          ) : null}\n        </StaticContainer>\n      </EnsureSingleNavigator>\n    </NavigationStateContext.Provider>\n  );\n}\n","import type { NavigationState, ParamListBase } from '@react-navigation/routers';\n\nimport type { EventMapBase, RouteConfig } from './types';\n\n/**\n * Empty component used for specifying route configuration.\n */\nexport default function Screen<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase\n>(_: RouteConfig<ParamList, RouteName, State, ScreenOptions, EventMap>) {\n  /* istanbul ignore next */\n  return null;\n}\n","import * as React from 'react';\n\n/**\n * Component which prevents updates for children if no props changed\n */\nfunction StaticContainer(props: any) {\n  return props.children;\n}\n\nexport default React.memo(StaticContainer, (prevProps: any, nextProps: any) => {\n  const prevPropKeys = Object.keys(prevProps);\n  const nextPropKeys = Object.keys(nextProps);\n\n  if (prevPropKeys.length !== nextPropKeys.length) {\n    return false;\n  }\n\n  for (const key of prevPropKeys) {\n    if (key === 'children') {\n      continue;\n    }\n\n    if (prevProps[key] !== nextProps[key]) {\n      return false;\n    }\n  }\n\n  return true;\n});\n","import type { NavigationAction } from '@react-navigation/routers';\nimport * as React from 'react';\n\nconst UnhandledActionContext = React.createContext<\n  ((action: NavigationAction) => void) | undefined\n>(undefined);\n\nexport default UnhandledActionContext;\n","import type { NavigationState, PartialState } from '@react-navigation/routers';\n\nexport default function checkDuplicateRouteNames(state: NavigationState) {\n  const duplicates: string[][] = [];\n\n  const getRouteNames = (\n    location: string,\n    state: NavigationState | PartialState<NavigationState>\n  ) => {\n    state.routes.forEach((route: (typeof state.routes)[0]) => {\n      const currentLocation = location\n        ? `${location} > ${route.name}`\n        : route.name;\n\n      route.state?.routeNames?.forEach((routeName) => {\n        if (routeName === route.name) {\n          duplicates.push([\n            currentLocation,\n            `${currentLocation} > ${route.name}`,\n          ]);\n        }\n      });\n\n      if (route.state) {\n        getRouteNames(currentLocation, route.state);\n      }\n    });\n  };\n\n  getRouteNames('', state);\n\n  return duplicates;\n}\n","const checkSerializableWithoutCircularReference = (\n  o: { [key: string]: any },\n  seen: Set<any>,\n  location: (string | number)[]\n):\n  | { serializable: true }\n  | {\n      serializable: false;\n      location: (string | number)[];\n      reason: string;\n    } => {\n  if (\n    o === undefined ||\n    o === null ||\n    typeof o === 'boolean' ||\n    typeof o === 'number' ||\n    typeof o === 'string'\n  ) {\n    return { serializable: true };\n  }\n\n  if (\n    Object.prototype.toString.call(o) !== '[object Object]' &&\n    !Array.isArray(o)\n  ) {\n    return {\n      serializable: false,\n      location,\n      reason: typeof o === 'function' ? 'Function' : String(o),\n    };\n  }\n\n  if (seen.has(o)) {\n    return {\n      serializable: false,\n      reason: 'Circular reference',\n      location,\n    };\n  }\n\n  seen.add(o);\n\n  if (Array.isArray(o)) {\n    for (let i = 0; i < o.length; i++) {\n      const childResult = checkSerializableWithoutCircularReference(\n        o[i],\n        new Set<any>(seen),\n        [...location, i]\n      );\n\n      if (!childResult.serializable) {\n        return childResult;\n      }\n    }\n  } else {\n    for (const key in o) {\n      const childResult = checkSerializableWithoutCircularReference(\n        o[key],\n        new Set<any>(seen),\n        [...location, key]\n      );\n\n      if (!childResult.serializable) {\n        return childResult;\n      }\n    }\n  }\n\n  return { serializable: true };\n};\n\nexport default function checkSerializable(o: { [key: string]: any }) {\n  return checkSerializableWithoutCircularReference(o, new Set<any>(), []);\n}\n","import { CommonActions } from '@react-navigation/routers';\n\nimport type {\n  NavigationContainerEventMap,\n  NavigationContainerRef,\n  NavigationContainerRefWithCurrent,\n} from './types';\n\nexport const NOT_INITIALIZED_ERROR =\n  \"The 'navigation' object hasn't been initialized yet. This might happen if you don't have a navigator mounted, or if the navigator hasn't finished mounting. See https://reactnavigation.org/docs/navigating-without-navigation-prop#handling-initialization for more details.\";\n\nexport default function createNavigationContainerRef<\n  ParamList extends {} = ReactNavigation.RootParamList\n>(): NavigationContainerRefWithCurrent<ParamList> {\n  const methods = [\n    ...Object.keys(CommonActions),\n    'addListener',\n    'removeListener',\n    'resetRoot',\n    'dispatch',\n    'isFocused',\n    'canGoBack',\n    'getRootState',\n    'getState',\n    'getParent',\n    'getCurrentRoute',\n    'getCurrentOptions',\n  ] as const;\n\n  const listeners: Record<string, ((...args: any[]) => void)[]> = {};\n\n  const removeListener = (\n    event: string,\n    callback: (...args: any[]) => void\n  ) => {\n    if (listeners[event]) {\n      listeners[event] = listeners[event].filter((cb) => cb !== callback);\n    }\n  };\n\n  let current: NavigationContainerRef<ParamList> | null = null;\n\n  const ref: NavigationContainerRefWithCurrent<ParamList> = {\n    get current() {\n      return current;\n    },\n    set current(value: NavigationContainerRef<ParamList> | null) {\n      current = value;\n\n      if (value != null) {\n        Object.entries(listeners).forEach(([event, callbacks]) => {\n          callbacks.forEach((callback) => {\n            value.addListener(\n              event as keyof NavigationContainerEventMap,\n              callback\n            );\n          });\n        });\n      }\n    },\n    isReady: () => {\n      if (current == null) {\n        return false;\n      }\n\n      return current.isReady();\n    },\n    ...methods.reduce<any>((acc, name) => {\n      acc[name] = (...args: any[]) => {\n        if (current == null) {\n          switch (name) {\n            case 'addListener': {\n              const [event, callback] = args;\n\n              listeners[event] = listeners[event] || [];\n              listeners[event].push(callback);\n\n              return () => removeListener(event, callback);\n            }\n            case 'removeListener': {\n              const [event, callback] = args;\n\n              removeListener(event, callback);\n              break;\n            }\n            default:\n              console.error(NOT_INITIALIZED_ERROR);\n          }\n        } else {\n          // @ts-expect-error: this is ok\n          return current[name](...args);\n        }\n      };\n      return acc;\n    }, {}),\n  };\n\n  return ref;\n}\n","import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport type * as React from 'react';\n\nimport Group from './Group';\nimport Screen from './Screen';\nimport type { EventMapBase, TypedNavigator } from './types';\n\n/**\n * Higher order component to create a `Navigator` and `Screen` pair.\n * Custom navigators should wrap the navigator component in `createNavigator` before exporting.\n *\n * @param Navigator The navigtor component to wrap.\n * @returns Factory method to create a `Navigator` and `Screen` pair.\n */\nexport default function createNavigatorFactory<\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  NavigatorComponent extends React.ComponentType<any>\n>(Navigator: NavigatorComponent) {\n  return function <ParamList extends ParamListBase>(): TypedNavigator<\n    ParamList,\n    State,\n    ScreenOptions,\n    EventMap,\n    typeof Navigator\n  > {\n    if (arguments[0] !== undefined) {\n      throw new Error(\n        \"Creating a navigator doesn't take an argument. Maybe you are trying to use React Navigation 4 API? See https://reactnavigation.org/docs/hello-react-navigation for the latest API and guides.\"\n      );\n    }\n\n    return {\n      Navigator,\n      Group,\n      Screen,\n    };\n  };\n}\n","import type { InitialState } from '@react-navigation/routers';\n\nexport default function findFocusedRoute(state: InitialState) {\n  let current: InitialState | undefined = state;\n\n  while (current?.routes[current.index ?? 0].state != null) {\n    current = current.routes[current.index ?? 0].state;\n  }\n\n  const route = current?.routes[current?.index ?? 0];\n\n  return route;\n}\n","// Object.fromEntries is not available in older iOS versions\nexport default function fromEntries<K extends string, V>(\n  entries: (readonly [K, V])[]\n) {\n  return entries.reduce((acc, [k, v]) => {\n    if (acc.hasOwnProperty(k)) {\n      throw new Error(`A value for key '${k}' already exists in the object.`);\n    }\n\n    acc[k] = v;\n    return acc;\n  }, {} as Record<K, V>);\n}\n","import type {\n  CommonActions,\n  NavigationState,\n  ParamListBase,\n  PartialRoute,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\n\nimport type { NavigatorScreenParams, PathConfig, PathConfigMap } from './types';\n\ntype ConfigItem = {\n  initialRouteName?: string;\n  screens?: Record<string, ConfigItem>;\n};\n\ntype Options = {\n  initialRouteName?: string;\n  screens: PathConfigMap<object>;\n};\n\ntype NavigateAction<State extends NavigationState> = {\n  type: 'NAVIGATE';\n  payload: {\n    name: string;\n    params?: NavigatorScreenParams<State>;\n    path?: string;\n  };\n};\n\nexport default function getActionFromState(\n  state: PartialState<NavigationState>,\n  options?: Options\n): NavigateAction<NavigationState> | CommonActions.Action | undefined {\n  // Create a normalized configs object which will be easier to use\n  const normalizedConfig = options\n    ? createNormalizedConfigItem(options as PathConfig<object> | string)\n    : {};\n\n  const routes =\n    state.index != null ? state.routes.slice(0, state.index + 1) : state.routes;\n\n  if (routes.length === 0) {\n    return undefined;\n  }\n\n  if (\n    !(\n      (routes.length === 1 && routes[0].key === undefined) ||\n      (routes.length === 2 &&\n        routes[0].key === undefined &&\n        routes[0].name === normalizedConfig?.initialRouteName &&\n        routes[1].key === undefined)\n    )\n  ) {\n    return {\n      type: 'RESET',\n      payload: state,\n    };\n  }\n\n  const route = state.routes[state.index ?? state.routes.length - 1];\n\n  let current: PartialState<NavigationState> | undefined = route?.state;\n  let config: ConfigItem | undefined = normalizedConfig?.screens?.[route?.name];\n  let params = { ...route.params } as NavigatorScreenParams<\n    ParamListBase,\n    NavigationState\n  >;\n\n  let payload = route\n    ? { name: route.name, path: route.path, params }\n    : undefined;\n\n  while (current) {\n    if (current.routes.length === 0) {\n      return undefined;\n    }\n\n    const routes =\n      current.index != null\n        ? current.routes.slice(0, current.index + 1)\n        : current.routes;\n\n    const route: Route<string> | PartialRoute<Route<string>> =\n      routes[routes.length - 1];\n\n    // Explicitly set to override existing value when merging params\n    Object.assign(params, {\n      initial: undefined,\n      screen: undefined,\n      params: undefined,\n      state: undefined,\n    });\n\n    if (routes.length === 1 && routes[0].key === undefined) {\n      params.initial = true;\n      params.screen = route.name;\n    } else if (\n      routes.length === 2 &&\n      routes[0].key === undefined &&\n      routes[0].name === config?.initialRouteName &&\n      routes[1].key === undefined\n    ) {\n      params.initial = false;\n      params.screen = route.name;\n    } else {\n      params.state = current;\n      break;\n    }\n\n    if (route.state) {\n      params.params = { ...route.params };\n      params = params.params as NavigatorScreenParams<\n        ParamListBase,\n        NavigationState\n      >;\n    } else {\n      params.path = route.path;\n      params.params = route.params;\n    }\n\n    current = route.state;\n    config = config?.screens?.[route.name];\n  }\n\n  if (!payload) {\n    return;\n  }\n\n  // Try to construct payload for a `NAVIGATE` action from the state\n  // This lets us preserve the navigation state and not lose it\n  return {\n    type: 'NAVIGATE',\n    payload,\n  };\n}\n\nconst createNormalizedConfigItem = (config: PathConfig<object> | string) =>\n  typeof config === 'object' && config != null\n    ? {\n        initialRouteName: config.initialRouteName,\n        screens:\n          config.screens != null\n            ? createNormalizedConfigs(config.screens)\n            : undefined,\n      }\n    : {};\n\nconst createNormalizedConfigs = (options: PathConfigMap<object>) =>\n  Object.entries(options).reduce<Record<string, ConfigItem>>((acc, [k, v]) => {\n    acc[k] = createNormalizedConfigItem(v);\n    return acc;\n  }, {});\n","import type { Route } from '@react-navigation/routers';\n\nimport { CHILD_STATE } from './useRouteCache';\n\nexport default function getFocusedRouteNameFromRoute(\n  route: Partial<Route<string>>\n): string | undefined {\n  // @ts-expect-error: this isn't in type definitions coz we want this private\n  const state = route[CHILD_STATE] ?? route.state;\n  const params = route.params as { screen?: unknown } | undefined;\n\n  const routeName = state\n    ? // Get the currently active route name in the nested navigator\n      state.routes[\n        // If we have a partial state without index, for tab/drawer, first screen will be focused one, and last for stack\n        // The type property will only exist for rehydrated state and not for state from deep link\n        state.index ??\n          (typeof state.type === 'string' && state.type !== 'stack'\n            ? 0\n            : state.routes.length - 1)\n      ].name\n    : // If state doesn't exist, we need to default to `screen` param if available\n    typeof params?.screen === 'string'\n    ? params.screen\n    : undefined;\n\n  return routeName;\n}\n","import type {\n  NavigationState,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport * as queryString from 'query-string';\n\nimport fromEntries from './fromEntries';\nimport type { PathConfig, PathConfigMap } from './types';\nimport validatePathConfig from './validatePathConfig';\n\ntype Options<ParamList extends {}> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  return route;\n};\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState<ParamList extends {}>(\n  state: State,\n  options?: Options<ParamList>\n): string {\n  if (state == null) {\n    throw Error(\n      \"Got 'undefined' for the navigation state. You must pass a valid state object.\"\n    );\n  }\n\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  // Create a normalized configs object which will be easier to use\n  const configs: Record<string, ConfigItem> = options?.screens\n    ? createNormalizedConfigs(options?.screens)\n    : {};\n\n  let path = '/';\n  let current: State | undefined = state;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    let index = typeof current.index === 'number' ? current.index : 0;\n    let route = current.routes[index] as Route<string> & {\n      state?: State;\n    };\n\n    let pattern: string | undefined;\n\n    let focusedParams: Record<string, any> | undefined;\n    let focusedRoute = getActiveRoute(state);\n    let currentOptions = configs;\n\n    // Keep all the route names that appeared during going deeper in config in case the pattern is resolved to undefined\n    let nestedRouteNames = [];\n\n    let hasNext = true;\n\n    while (route.name in currentOptions && hasNext) {\n      pattern = currentOptions[route.name].pattern;\n\n      nestedRouteNames.push(route.name);\n\n      if (route.params) {\n        const stringify = currentOptions[route.name]?.stringify;\n\n        const currentParams = fromEntries(\n          Object.entries(route.params).map(([key, value]) => [\n            key,\n            stringify?.[key] ? stringify[key](value) : String(value),\n          ])\n        );\n\n        if (pattern) {\n          Object.assign(allParams, currentParams);\n        }\n\n        if (focusedRoute === route) {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = { ...currentParams };\n\n          pattern\n            ?.split('/')\n            .filter((p) => p.startsWith(':'))\n            // eslint-disable-next-line no-loop-func\n            .forEach((p) => {\n              const name = getParamName(p);\n\n              // Remove the params present in the pattern since we'll only use the rest for query string\n              if (focusedParams) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete focusedParams[name];\n              }\n            });\n        }\n      }\n\n      // If there is no `screens` property or no nested state, we return pattern\n      if (!currentOptions[route.name].screens || route.state === undefined) {\n        hasNext = false;\n      } else {\n        index =\n          typeof route.state.index === 'number'\n            ? route.state.index\n            : route.state.routes.length - 1;\n\n        const nextRoute = route.state.routes[index];\n        const nestedConfig = currentOptions[route.name].screens;\n\n        // if there is config for next route name, we go deeper\n        if (nestedConfig && nextRoute.name in nestedConfig) {\n          route = nextRoute as Route<string> & { state?: State };\n          currentOptions = nestedConfig;\n        } else {\n          // If not, there is no sense in going deeper in config\n          hasNext = false;\n        }\n      }\n    }\n\n    if (pattern === undefined) {\n      pattern = nestedRouteNames.join('/');\n    }\n\n    if (currentOptions[route.name] !== undefined) {\n      path += pattern\n        .split('/')\n        .map((p) => {\n          const name = getParamName(p);\n\n          // We don't know what to show for wildcard patterns\n          // Showing the route name seems ok, though whatever we show here will be incorrect\n          // Since the page doesn't actually exist\n          if (p === '*') {\n            return route.name;\n          }\n\n          // If the path has a pattern for a param, put the param in the path\n          if (p.startsWith(':')) {\n            const value = allParams[name];\n\n            if (value === undefined && p.endsWith('?')) {\n              // Optional params without value assigned in route.params should be ignored\n              return '';\n            }\n\n            return encodeURIComponent(value);\n          }\n\n          return encodeURIComponent(p);\n        })\n        .join('/');\n    } else {\n      path += encodeURIComponent(route.name);\n    }\n\n    if (!focusedParams) {\n      focusedParams = focusedRoute.params;\n    }\n\n    if (route.state) {\n      path += '/';\n    } else if (focusedParams) {\n      for (let param in focusedParams) {\n        if (focusedParams[param] === 'undefined') {\n          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n          delete focusedParams[param];\n        }\n      }\n\n      const query = queryString.stringify(focusedParams, { sort: false });\n\n      if (query) {\n        path += `?${query}`;\n      }\n    }\n\n    current = route.state;\n  }\n\n  // Remove multiple as well as trailing slashes\n  path = path.replace(/\\/+/g, '/');\n  path = path.length > 1 ? path.replace(/\\/$/, '') : path;\n\n  return path;\n}\n\nconst getParamName = (pattern: string) =>\n  pattern.replace(/^:/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  let pattern: string | undefined;\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  pattern =\n    config.exact !== true\n      ? joinPaths(parentPattern || '', config.path || '')\n      : config.path || '';\n\n  const screens = config.screens\n    ? createNormalizedConfigs(config.screens, pattern)\n    : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  fromEntries(\n    Object.entries(options).map(([name, c]) => {\n      const result = createConfigItem(c, pattern);\n\n      return [name, result];\n    })\n  );\n","import type {\n  InitialState,\n  NavigationState,\n  PartialState,\n} from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\nimport * as queryString from 'query-string';\n\nimport findFocusedRoute from './findFocusedRoute';\nimport type { PathConfigMap } from './types';\nimport validatePathConfig from './validatePathConfig';\n\ntype Options<ParamList extends {}> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\ntype ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, any> | undefined;\n};\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath<ParamList extends {}>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  let initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  const screens = options?.screens;\n\n  let remaining = path\n    .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n    .replace(/^\\//, '') // Remove extra leading slash\n    .replace(/\\?.*$/, ''); // Remove query params which we will handle later\n\n  // Make sure there is a trailing slash\n  remaining = remaining.endsWith('/') ? remaining : `${remaining}/`;\n\n  if (screens === undefined) {\n    // When no config is specified, use the path segments as route names\n    const routes = remaining\n      .split('/')\n      .filter(Boolean)\n      .map((segment) => {\n        const name = decodeURIComponent(segment);\n        return { name };\n      });\n\n    if (routes.length) {\n      return createNestedStateObject(path, routes, initialRoutes);\n    }\n\n    return undefined;\n  }\n\n  // Create a normalized configs array which will be easier to use\n  const configs = ([] as RouteConfig[])\n    .concat(\n      ...Object.keys(screens).map((key) =>\n        createNormalizedConfigs(\n          key,\n          screens as PathConfigMap<object>,\n          [],\n          initialRoutes,\n          []\n        )\n      )\n    )\n    .sort((a, b) => {\n      // Sort config so that:\n      // - the most exhaustive ones are always at the beginning\n      // - patterns with wildcard are always at the end\n\n      // If 2 patterns are same, move the one with less route names up\n      // This is an error state, so it's only useful for consistent error messages\n      if (a.pattern === b.pattern) {\n        return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n      }\n\n      // If one of the patterns starts with the other, it's more exhaustive\n      // So move it up\n      if (a.pattern.startsWith(b.pattern)) {\n        return -1;\n      }\n\n      if (b.pattern.startsWith(a.pattern)) {\n        return 1;\n      }\n\n      const aParts = a.pattern.split('/');\n      const bParts = b.pattern.split('/');\n\n      for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n        // if b is longer, b get higher priority\n        if (aParts[i] == null) {\n          return 1;\n        }\n        // if a is longer, a get higher priority\n        if (bParts[i] == null) {\n          return -1;\n        }\n        const aWildCard = aParts[i] === '*' || aParts[i].startsWith(':');\n        const bWildCard = bParts[i] === '*' || bParts[i].startsWith(':');\n        // if both are wildcard we compare next component\n        if (aWildCard && bWildCard) {\n          continue;\n        }\n        // if only a is wild card, b get higher priority\n        if (aWildCard) {\n          return 1;\n        }\n        // if only b is wild card, a get higher priority\n        if (bWildCard) {\n          return -1;\n        }\n      }\n      return bParts.length - aParts.length;\n    });\n\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    if (acc[config.pattern]) {\n      const a = acc[config.pattern].routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length\n          ? b.every((it, i) => a[i] === it)\n          : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        throw new Error(\n          `Found conflicting screens with the same pattern. The pattern '${\n            config.pattern\n          }' resolves to both '${a.join(' > ')}' and '${b.join(\n            ' > '\n          )}'. Patterns must be unique and cannot resolve to more than one screen.`\n        );\n      }\n    }\n\n    return Object.assign(acc, {\n      [config.pattern]: config,\n    });\n  }, {});\n\n  if (remaining === '/') {\n    // We need to add special handling of empty path so navigation to empty path also works\n    // When handling empty path, we should only look at the root level config\n    const match = configs.find(\n      (config) =>\n        config.path === '' &&\n        config.routeNames.every(\n          // Make sure that none of the parent configs have a non-empty path defined\n          (name) => !configs.find((c) => c.screen === name)?.path\n        )\n    );\n\n    if (match) {\n      return createNestedStateObject(\n        path,\n        match.routeNames.map((name) => ({ name })),\n        initialRoutes,\n        configs\n      );\n    }\n\n    return undefined;\n  }\n\n  let result: PartialState<NavigationState> | undefined;\n  let current: PartialState<NavigationState> | undefined;\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const { routes, remainingPath } = matchAgainstConfigs(\n    remaining,\n    configs.map((c) => ({\n      ...c,\n      // Add `$` to the regex to make sure it matches till end of the path and not just beginning\n      regex: c.regex ? new RegExp(c.regex.source + '$') : undefined,\n    }))\n  );\n\n  if (routes !== undefined) {\n    // This will always be empty if full path matched\n    current = createNestedStateObject(path, routes, initialRoutes, configs);\n    remaining = remainingPath;\n    result = current;\n  }\n\n  if (current == null || result == null) {\n    return undefined;\n  }\n\n  return result;\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst matchAgainstConfigs = (remaining: string, configs: RouteConfig[]) => {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (match) {\n      const matchResult = config.pattern?.split('/').reduce<{\n        pos: number; // Position of the current path param segment in the path (e.g in pattern `a/:b/:c`, `:a` is 0 and `:b` is 1)\n        matchedParams: Record<string, Record<string, string>>; // The extracted params\n      }>(\n        (acc, p, index) => {\n          if (!p.startsWith(':')) {\n            return acc;\n          }\n\n          // Path parameter so increment position for the segment\n          acc.pos += 1;\n\n          const decodedParamSegment = decodeURIComponent(\n            // The param segments appear every second item starting from 2 in the regex match result\n            match![(acc.pos + 1) * 2]\n              // Remove trailing slash\n              .replace(/\\/$/, '')\n          );\n\n          Object.assign(acc.matchedParams, {\n            [p]: Object.assign(acc.matchedParams[p] || {}, {\n              [index]: decodedParamSegment,\n            }),\n          });\n\n          return acc;\n        },\n        { pos: -1, matchedParams: {} }\n      );\n\n      const matchedParams = matchResult.matchedParams || {};\n\n      routes = config.routeNames.map((name) => {\n        const routeConfig = configs.find((c) => {\n          // Check matching name AND pattern in case same screen is used at different levels in config\n          return c.screen === name && config.pattern.startsWith(c.pattern);\n        });\n\n        // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n        const normalizedPath = routeConfig?.path\n          .split('/')\n          .filter(Boolean)\n          .join('/');\n\n        // Get the number of segments in the initial pattern\n        const numInitialSegments = routeConfig?.pattern\n          // Extract the prefix from the pattern by removing the ending path pattern (e.g pattern=`a/b/c/d` and normalizedPath=`c/d` becomes `a/b`)\n          .replace(new RegExp(`${escape(normalizedPath!)}$`), '')\n          ?.split('/').length;\n\n        const params = normalizedPath\n          ?.split('/')\n          .reduce<Record<string, unknown>>((acc, p, index) => {\n            if (!p.startsWith(':')) {\n              return acc;\n            }\n\n            // Get the real index of the path parameter in the matched path\n            // by offsetting by the number of segments in the initial pattern\n            const offset = numInitialSegments ? numInitialSegments - 1 : 0;\n            const value = matchedParams[p]?.[index + offset];\n\n            if (value) {\n              const key = p.replace(/^:/, '').replace(/\\?$/, '');\n              acc[key] = routeConfig?.parse?.[key]\n                ? routeConfig.parse[key](value)\n                : value;\n            }\n\n            return acc;\n          }, {});\n\n        if (params && Object.keys(params).length) {\n          return { name, params };\n        }\n\n        return { name };\n      });\n\n      remainingPath = remainingPath.replace(match[1], '');\n\n      break;\n    }\n  }\n\n  return { routes, remainingPath };\n};\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfigMap<object>,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[],\n  parentScreens: string[],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  // @ts-expect-error: we can't strongly typecheck this for now\n  const config = routeConfig[screen];\n\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n        );\n      }\n\n      pattern =\n        config.exact !== true\n          ? joinPaths(parentPattern || '', config.path || '')\n          : config.path || '';\n\n      configs.push(\n        createConfigItem(\n          screen,\n          routeNames,\n          pattern!,\n          config.path,\n          config.parse\n        )\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfigMap<object>,\n          routeNames,\n          initials,\n          [...parentScreens],\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  parse?: ParseConfig\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(\n        `^(${pattern\n          .split('/')\n          .map((it) => {\n            if (it.startsWith(':')) {\n              return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n            }\n\n            return `${it === '*' ? '.*' : escape(it)}\\\\/`;\n          })\n          .join('')})`\n      )\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  flatConfig: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of flatConfig) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (parentScreens.length === config.parentScreens.length) {\n      let sameParents = true;\n      for (let i = 0; i < parentScreens.length; i++) {\n        if (parentScreens[i].localeCompare(config.parentScreens[i]) !== 0) {\n          sameParents = false;\n          break;\n        }\n      }\n      if (sameParents) {\n        return routeName !== config.initialRouteName\n          ? config.initialRouteName\n          : undefined;\n      }\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  initialRoute: string | undefined,\n  route: ParsedRoute,\n  isEmpty: boolean\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    } else {\n      return {\n        routes: [route],\n      };\n    }\n  } else {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n      };\n    } else {\n      return {\n        routes: [{ ...route, state: { routes: [] } }],\n      };\n    }\n  }\n};\n\nconst createNestedStateObject = (\n  path: string,\n  routes: ParsedRoute[],\n  initialRoutes: InitialRouteConfig[],\n  flatConfig?: RouteConfig[]\n) => {\n  let state: InitialState;\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  state = createStateObject(initialRoute, route, routes.length === 0);\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex =\n        nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        initialRoute,\n        route,\n        routes.length === 0\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex]\n          .state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n  route.path = path;\n\n  const params = parseQueryParams(\n    path,\n    flatConfig ? findParseConfigForRoute(route.name, flatConfig) : undefined\n  );\n\n  if (params) {\n    route.params = { ...route.params, ...params };\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (\n  path: string,\n  parseConfig?: Record<string, (value: string) => any>\n) => {\n  const query = path.split('?')[1];\n  const params = queryString.parse(query);\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (\n        Object.hasOwnProperty.call(parseConfig, name) &&\n        typeof params[name] === 'string'\n      ) {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n","export { default as BaseNavigationContainer } from './BaseNavigationContainer';\nexport { default as createNavigationContainerRef } from './createNavigationContainerRef';\nexport { default as createNavigatorFactory } from './createNavigatorFactory';\nexport { default as CurrentRenderContext } from './CurrentRenderContext';\nexport { default as findFocusedRoute } from './findFocusedRoute';\nexport { default as getActionFromState } from './getActionFromState';\nexport { default as getFocusedRouteNameFromRoute } from './getFocusedRouteNameFromRoute';\nexport { default as getPathFromState } from './getPathFromState';\nexport { default as getStateFromPath } from './getStateFromPath';\nexport { default as NavigationContainerRefContext } from './NavigationContainerRefContext';\nexport { default as NavigationContext } from './NavigationContext';\nexport { default as NavigationHelpersContext } from './NavigationHelpersContext';\nexport { default as NavigationRouteContext } from './NavigationRouteContext';\nexport { default as PreventRemoveContext } from './PreventRemoveContext';\nexport { default as PreventRemoveProvider } from './PreventRemoveProvider';\nexport * from './types';\nexport { default as useFocusEffect } from './useFocusEffect';\nexport { default as useIsFocused } from './useIsFocused';\nexport { default as useNavigation } from './useNavigation';\nexport { default as useNavigationBuilder } from './useNavigationBuilder';\nexport { default as useNavigationContainerRef } from './useNavigationContainerRef';\nexport { default as useNavigationState } from './useNavigationState';\nexport { default as UNSTABLE_usePreventRemove } from './usePreventRemove';\nexport { default as usePreventRemoveContext } from './usePreventRemoveContext';\nexport { default as useRoute } from './useRoute';\nexport { default as validatePathConfig } from './validatePathConfig';\nexport * from '@react-navigation/routers';\n","/**\n * Compare two arrays with primitive values as the content.\n * We need to make sure that both values and order match.\n */\nexport default function isArrayEqual(a: any[], b: any[]) {\n  if (a === b) {\n    return true;\n  }\n\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  return a.every((it, index) => it === b[index]);\n}\n","/**\n * Compare two records with primitive values as the content.\n */\nexport default function isRecordEqual(\n  a: Record<string, any>,\n  b: Record<string, any>\n) {\n  if (a === b) {\n    return true;\n  }\n\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  if (aKeys.length !== bKeys.length) {\n    return false;\n  }\n\n  return aKeys.every((key) => a[key] === b[key]);\n}\n","import type {\n  DefaultRouterOptions,\n  InitialState,\n  NavigationAction,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n  Route,\n} from '@react-navigation/routers';\nimport type * as React from 'react';\n\ndeclare global {\n  // eslint-disable-next-line @typescript-eslint/no-namespace\n  namespace ReactNavigation {\n    // eslint-disable-next-line @typescript-eslint/no-empty-interface\n    interface RootParamList {}\n  }\n}\n\ntype Keyof<T extends {}> = Extract<keyof T, string>;\n\nexport type DefaultNavigatorOptions<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase\n> = DefaultRouterOptions<Keyof<ParamList>> & {\n  /**\n   * Optional ID for the navigator. Can be used with `navigation.getParent(id)` to refer to a parent.\n   */\n  id?: string;\n  /**\n   * Children React Elements to extract the route configuration from.\n   * Only `Screen`, `Group` and `React.Fragment` are supported as children.\n   */\n  children: React.ReactNode;\n  /**\n   * Event listeners for all the screens in the navigator.\n   */\n  screenListeners?:\n    | ScreenListeners<State, EventMap>\n    | ((props: {\n        route: RouteProp<ParamList>;\n        navigation: any;\n      }) => ScreenListeners<State, EventMap>);\n  /**\n   * Default options for all screens under this navigator.\n   */\n  screenOptions?:\n    | ScreenOptions\n    | ((props: {\n        route: RouteProp<ParamList>;\n        navigation: any;\n      }) => ScreenOptions);\n};\n\nexport type EventMapBase = Record<\n  string,\n  { data?: any; canPreventDefault?: boolean }\n>;\n\nexport type EventMapCore<State extends NavigationState> = {\n  focus: { data: undefined };\n  blur: { data: undefined };\n  state: { data: { state: State } };\n  beforeRemove: { data: { action: NavigationAction }; canPreventDefault: true };\n};\n\nexport type EventArg<\n  EventName extends string,\n  CanPreventDefault extends boolean | undefined = false,\n  Data = undefined\n> = {\n  /**\n   * Type of the event (e.g. `focus`, `blur`)\n   */\n  readonly type: EventName;\n  readonly target?: string;\n} & (CanPreventDefault extends true\n  ? {\n      /**\n       * Whether `event.preventDefault()` was called on this event object.\n       */\n      readonly defaultPrevented: boolean;\n      /**\n       * Prevent the default action which happens on this event.\n       */\n      preventDefault(): void;\n    }\n  : {}) &\n  (undefined extends Data\n    ? { readonly data?: Readonly<Data> }\n    : { readonly data: Readonly<Data> });\n\nexport type EventListenerCallback<\n  EventMap extends EventMapBase,\n  EventName extends keyof EventMap\n> = (\n  e: EventArg<\n    Extract<EventName, string>,\n    EventMap[EventName]['canPreventDefault'],\n    EventMap[EventName]['data']\n  >\n) => void;\n\nexport type EventConsumer<EventMap extends EventMapBase> = {\n  /**\n   * Subscribe to events from the parent navigator.\n   *\n   * @param type Type of the event (e.g. `focus`, `blur`)\n   * @param callback Callback listener which is executed upon receiving the event.\n   */\n  addListener<EventName extends Keyof<EventMap>>(\n    type: EventName,\n    callback: EventListenerCallback<EventMap, EventName>\n  ): () => void;\n  removeListener<EventName extends Keyof<EventMap>>(\n    type: EventName,\n    callback: EventListenerCallback<EventMap, EventName>\n  ): void;\n};\n\nexport type EventEmitter<EventMap extends EventMapBase> = {\n  /**\n   * Emit an event to child screens.\n   *\n   * @param options.type Type of the event (e.g. `focus`, `blur`)\n   * @param [options.data] Optional information regarding the event.\n   * @param [options.target] Key of the target route which should receive the event.\n   * If not specified, all routes receive the event.\n   */\n  emit<EventName extends Keyof<EventMap>>(\n    options: {\n      type: EventName;\n      target?: string;\n    } & (EventMap[EventName]['canPreventDefault'] extends true\n      ? { canPreventDefault: true }\n      : {}) &\n      (undefined extends EventMap[EventName]['data']\n        ? { data?: EventMap[EventName]['data'] }\n        : { data: EventMap[EventName]['data'] })\n  ): EventArg<\n    EventName,\n    EventMap[EventName]['canPreventDefault'],\n    EventMap[EventName]['data']\n  >;\n};\n\nexport class PrivateValueStore<T extends [any, any, any]> {\n  /**\n   * UGLY HACK! DO NOT USE THE TYPE!!!\n   *\n   * TypeScript requires a type to be used to be able to infer it.\n   * The type should exist as its own without any operations such as union.\n   * So we need to figure out a way to store this type in a property.\n   * The problem with a normal property is that it shows up in intelliSense.\n   * Adding private keyword works, but the annotation is stripped away in declaration.\n   * Turns out if we use an empty string, it doesn't show up in intelliSense.\n   */\n  protected ''?: T;\n}\n\ntype NavigationHelpersCommon<\n  ParamList extends ParamListBase,\n  State extends NavigationState = NavigationState\n> = {\n  /**\n   * Dispatch an action or an update function to the router.\n   * The update function will receive the current state,\n   *\n   * @param action Action object or update function.\n   */\n  dispatch(\n    action: NavigationAction | ((state: State) => NavigationAction)\n  ): void;\n\n  /**\n   * Navigate to a route in current navigation tree.\n   *\n   * @param name Name of the route to navigate to.\n   * @param [params] Params object for the route.\n   */\n  navigate<RouteName extends keyof ParamList>(\n    ...args: // this first condition allows us to iterate over a union type\n    // This is to avoid getting a union of all the params from `ParamList[RouteName]`,\n    // which will get our types all mixed up if a union RouteName is passed in.\n    RouteName extends unknown\n      ? // This condition checks if the params are optional,\n        // which means it's either undefined or a union with undefined\n        undefined extends ParamList[RouteName]\n        ?\n            | [screen: RouteName] // if the params are optional, we don't have to provide it\n            | [screen: RouteName, params: ParamList[RouteName]]\n        : [screen: RouteName, params: ParamList[RouteName]]\n      : never\n  ): void;\n\n  /**\n   * Navigate to a route in current navigation tree.\n   *\n   * @param route Object with `key` or `name` for the route to navigate to, and a `params` object.\n   */\n  navigate<RouteName extends keyof ParamList>(\n    options: RouteName extends unknown\n      ?\n          | { key: string; params?: ParamList[RouteName]; merge?: boolean }\n          | {\n              name: RouteName;\n              key?: string;\n              params: ParamList[RouteName];\n              merge?: boolean;\n            }\n      : never\n  ): void;\n\n  /**\n   * Reset the navigation state to the provided state.\n   *\n   * @param state Navigation state object.\n   */\n  reset(state: PartialState<State> | State): void;\n\n  /**\n   * Go back to the previous route in history.\n   */\n  goBack(): void;\n\n  /**\n   * Check if the screen is focused. The method returns `true` if focused, `false` otherwise.\n   * Note that this method doesn't re-render screen when the focus changes. So don't use it in `render`.\n   * To get notified of focus changes, use `addListener('focus', cb)` and `addListener('blur', cb)`.\n   * To conditionally render content based on focus state, use the `useIsFocused` hook.\n   */\n  isFocused(): boolean;\n\n  /**\n   * Check if dispatching back action will be handled by navigation.\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\n   */\n  canGoBack(): boolean;\n\n  /**\n   * Returns the name of the navigator specified in the `name` prop.\n   * If no name is specified, returns `undefined`.\n   */\n  getId(): string | undefined;\n\n  /**\n   * Returns the navigation helpers from a parent navigator based on the ID.\n   * If an ID is provided, the navigation helper from the parent navigator with matching ID (including current) will be returned.\n   * If no ID is provided, the navigation helper from the immediate parent navigator will be returned.\n   *\n   * @param id Optional ID of a parent navigator.\n   */\n  getParent<T = NavigationHelpers<ParamListBase> | undefined>(id?: string): T;\n\n  /**\n   * Returns the navigator's state.\n   * Note that this method doesn't re-render screen when the result changes. So don't use it in `render`.\n   */\n  getState(): State;\n} & PrivateValueStore<[ParamList, unknown, unknown]>;\n\nexport type NavigationHelpers<\n  ParamList extends ParamListBase,\n  EventMap extends EventMapBase = {}\n> = NavigationHelpersCommon<ParamList> &\n  EventEmitter<EventMap> & {\n    /**\n     * Update the param object for the route.\n     * The new params will be shallow merged with the old one.\n     *\n     * @param params Params object for the current route.\n     */\n    setParams<RouteName extends keyof ParamList>(\n      params: Partial<ParamList[RouteName]>\n    ): void;\n  };\n\nexport type NavigationContainerProps = {\n  /**\n   * Initial navigation state for the child navigators.\n   */\n  initialState?: InitialState;\n  /**\n   * Callback which is called with the latest navigation state when it changes.\n   */\n  onStateChange?: (state: NavigationState | undefined) => void;\n  /**\n   * Callback which is called when an action is not handled.\n   */\n  onUnhandledAction?: (action: NavigationAction) => void;\n  /**\n   * Whether this navigation container should be independent of parent containers.\n   * If this is not set to `true`, this container cannot be nested inside another container.\n   * Setting it to `true` disconnects any children navigators from parent container.\n   */\n  independent?: boolean;\n  /**\n   * Children elements to render.\n   */\n  children: React.ReactNode;\n};\n\nexport type NavigationProp<\n  ParamList extends {},\n  RouteName extends keyof ParamList = Keyof<ParamList>,\n  NavigatorID extends string | undefined = undefined,\n  State extends NavigationState = NavigationState<ParamList>,\n  ScreenOptions extends {} = {},\n  EventMap extends EventMapBase = {}\n> = Omit<NavigationHelpersCommon<ParamList, State>, 'getParent'> & {\n  /**\n   * Returns the navigation prop from a parent navigator based on the ID.\n   * If an ID is provided, the navigation prop from the parent navigator with matching ID (including current) will be returned.\n   * If no ID is provided, the navigation prop from the immediate parent navigator will be returned.\n   *\n   * @param id Optional ID of a parent navigator.\n   */\n  getParent<T = NavigationProp<ParamListBase> | undefined>(id?: NavigatorID): T;\n\n  /**\n   * Update the param object for the route.\n   * The new params will be shallow merged with the old one.\n   *\n   * @param params Params object for the current route.\n   */\n  setParams(\n    params: ParamList[RouteName] extends undefined\n      ? undefined\n      : Partial<ParamList[RouteName]>\n  ): void;\n\n  /**\n   * Update the options for the route.\n   * The options object will be shallow merged with default options object.\n   *\n   * @param options Options object for the route.\n   */\n  setOptions(options: Partial<ScreenOptions>): void;\n} & EventConsumer<EventMap & EventMapCore<State>> &\n  PrivateValueStore<[ParamList, RouteName, EventMap]>;\n\nexport type RouteProp<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList = Keyof<ParamList>\n> = Route<Extract<RouteName, string>, ParamList[RouteName]>;\n\nexport type CompositeNavigationProp<\n  A extends NavigationProp<ParamListBase, string, any, any, any>,\n  B extends NavigationHelpersCommon<ParamListBase, any>\n> = Omit<A & B, keyof NavigationProp<any>> &\n  NavigationProp<\n    /**\n     * Param list from both navigation objects needs to be combined\n     * For example, we should be able to navigate to screens in both A and B\n     */\n    (A extends NavigationHelpersCommon<infer T> ? T : never) &\n      (B extends NavigationHelpersCommon<infer U> ? U : never),\n    /**\n     * The route name should refer to the route name specified in the first type\n     * Ideally it should work for any of them, but it's not possible to infer that way\n     */\n    A extends NavigationProp<any, infer R> ? R : string,\n    /**\n     * ID from both navigation objects needs to be combined for `getParent`\n     */\n    | (A extends NavigationProp<any, any, infer I> ? I : never)\n    | (B extends NavigationProp<any, any, infer J> ? J : never),\n    /**\n     * The type of state should refer to the state specified in the first type\n     */\n    A extends NavigationProp<any, any, any, infer S> ? S : NavigationState,\n    /**\n     * Screen options from both navigation objects needs to be combined\n     * This allows typechecking `setOptions`\n     */\n    (A extends NavigationProp<any, any, any, any, infer O> ? O : {}) &\n      (B extends NavigationProp<any, any, any, any, infer P> ? P : {}),\n    /**\n     * Event consumer config should refer to the config specified in the first type\n     * This allows typechecking `addListener`/`removeListener`\n     */\n    A extends NavigationProp<any, any, any, any, any, infer E> ? E : {}\n  >;\n\nexport type CompositeScreenProps<\n  A extends {\n    navigation: NavigationProp<\n      ParamListBase,\n      string,\n      string | undefined,\n      any,\n      any,\n      any\n    >;\n    route: RouteProp<ParamListBase>;\n  },\n  B extends {\n    navigation: NavigationHelpersCommon<any, any>;\n  }\n> = {\n  navigation: CompositeNavigationProp<A['navigation'], B['navigation']>;\n  route: A['route'];\n};\n\nexport type Descriptor<\n  ScreenOptions extends {},\n  Navigation extends NavigationProp<any, any, any, any, any, any>,\n  Route extends RouteProp<any, any>\n> = {\n  /**\n   * Render the component associated with this route.\n   */\n  render(): JSX.Element;\n\n  /**\n   * Options for the route.\n   */\n  options: ScreenOptions;\n\n  /**\n   * Route object for the screen\n   */\n  route: Route;\n\n  /**\n   * Navigation object for the screen\n   */\n  navigation: Navigation;\n};\n\nexport type ScreenListeners<\n  State extends NavigationState,\n  EventMap extends EventMapBase\n> = Partial<{\n  [EventName in keyof (EventMap & EventMapCore<State>)]: EventListenerCallback<\n    EventMap & EventMapCore<State>,\n    EventName\n  >;\n}>;\n\ntype ScreenComponentType<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList\n> =\n  | React.ComponentType<{\n      route: RouteProp<ParamList, RouteName>;\n      navigation: any;\n    }>\n  | React.ComponentType<{}>;\n\nexport type RouteConfigComponent<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList\n> =\n  | {\n      /**\n       * React component to render for this screen.\n       */\n      component: ScreenComponentType<ParamList, RouteName>;\n      getComponent?: never;\n      children?: never;\n    }\n  | {\n      /**\n       * Lazily get a React component to render for this screen.\n       */\n      getComponent: () => ScreenComponentType<ParamList, RouteName>;\n      component?: never;\n      children?: never;\n    }\n  | {\n      /**\n       * Render callback to render content of this screen.\n       */\n      children: (props: {\n        route: RouteProp<ParamList, RouteName>;\n        navigation: any;\n      }) => React.ReactNode;\n      component?: never;\n      getComponent?: never;\n    };\n\nexport type RouteConfig<\n  ParamList extends ParamListBase,\n  RouteName extends keyof ParamList,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase\n> = {\n  /**\n   * Optional key for this screen. This doesn't need to be unique.\n   * If the key changes, existing screens with this name will be removed or reset.\n   * Useful when we have some common screens and have conditional rendering.\n   */\n  navigationKey?: string;\n\n  /**\n   * Route name of this screen.\n   */\n  name: RouteName;\n\n  /**\n   * Navigator options for this screen.\n   */\n  options?:\n    | ScreenOptions\n    | ((props: {\n        route: RouteProp<ParamList, RouteName>;\n        navigation: any;\n      }) => ScreenOptions);\n\n  /**\n   * Event listeners for this screen.\n   */\n  listeners?:\n    | ScreenListeners<State, EventMap>\n    | ((props: {\n        route: RouteProp<ParamList, RouteName>;\n        navigation: any;\n      }) => ScreenListeners<State, EventMap>);\n\n  /**\n   * Function to return an unique ID for this screen.\n   * Receives an object with the route params.\n   * For a given screen name, there will always be only one screen corresponding to an ID.\n   * If `undefined` is returned, it acts same as no `getId` being specified.\n   */\n  getId?: ({ params }: { params: ParamList[RouteName] }) => string | undefined;\n\n  /**\n   * Initial params object for the route.\n   */\n  initialParams?: Partial<ParamList[RouteName]>;\n} & RouteConfigComponent<ParamList, RouteName>;\n\nexport type RouteGroupConfig<\n  ParamList extends ParamListBase,\n  ScreenOptions extends {}\n> = {\n  /**\n   * Optional key for the screens in this group.\n   * If the key changes, all existing screens in this group will be removed or reset.\n   */\n  navigationKey?: string;\n\n  /**\n   * Navigator options for this screen.\n   */\n  screenOptions?:\n    | ScreenOptions\n    | ((props: {\n        route: RouteProp<ParamList, keyof ParamList>;\n        navigation: any;\n      }) => ScreenOptions);\n  /**\n   * Children React Elements to extract the route configuration from.\n   * Only `Screen`, `Group` and `React.Fragment` are supported as children.\n   */\n  children: React.ReactNode;\n};\n\nexport type NavigationContainerEventMap = {\n  /**\n   * Event which fires when the navigation state changes.\n   */\n  state: {\n    data: {\n      /**\n       * The updated state object after the state change.\n       */\n      state: NavigationState | PartialState<NavigationState> | undefined;\n    };\n  };\n  /**\n   * Event which fires when current options changes.\n   */\n  options: { data: { options: object } };\n  /**\n   * Event which fires when an action is dispatched.\n   * Only intended for debugging purposes, don't use it for app logic.\n   * This event will be emitted before state changes have been applied.\n   */\n  __unsafe_action__: {\n    data: {\n      /**\n       * The action object which was dispatched.\n       */\n      action: NavigationAction;\n      /**\n       * Whether the action was a no-op, i.e. resulted any state changes.\n       */\n      noop: boolean;\n      /**\n       * Stack trace of the action, this will only be available during development.\n       */\n      stack: string | undefined;\n    };\n  };\n};\n\nexport type NavigationContainerRef<ParamList extends {}> =\n  NavigationHelpers<ParamList> &\n    EventConsumer<NavigationContainerEventMap> & {\n      /**\n       * Reset the navigation state of the root navigator to the provided state.\n       *\n       * @param state Navigation state object.\n       */\n      resetRoot(state?: PartialState<NavigationState> | NavigationState): void;\n      /**\n       * Get the rehydrated navigation state of the navigation tree.\n       */\n      getRootState(): NavigationState;\n      /**\n       * Get the currently focused navigation route.\n       */\n      getCurrentRoute(): Route<string> | undefined;\n      /**\n       * Get the currently focused route's options.\n       */\n      getCurrentOptions(): object | undefined;\n      /**\n       * Whether the navigation container is ready to handle actions.\n       */\n      isReady(): boolean;\n      /**\n       * Stub function for setOptions on navigation object for use with useNavigation.\n       */\n      setOptions(): never;\n      /**\n       * Stub function for getParent on navigation object for use with useNavigation.\n       */\n      getParent(): undefined;\n    };\n\nexport type NavigationContainerRefWithCurrent<ParamList extends {}> =\n  NavigationContainerRef<ParamList> & {\n    current: NavigationContainerRef<ParamList> | null;\n  };\n\nexport type TypedNavigator<\n  ParamList extends ParamListBase,\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase,\n  Navigator extends React.ComponentType<any>\n> = {\n  /**\n   * Navigator component which manages the child screens.\n   */\n  Navigator: React.ComponentType<\n    Omit<\n      React.ComponentProps<Navigator>,\n      keyof DefaultNavigatorOptions<any, any, any, any>\n    > &\n      DefaultNavigatorOptions<ParamList, State, ScreenOptions, EventMap>\n  >;\n  /**\n   * Component used for grouping multiple route configuration.\n   */\n  Group: React.ComponentType<RouteGroupConfig<ParamList, ScreenOptions>>;\n  /**\n   * Component used for specifying route configuration.\n   */\n  Screen: <RouteName extends keyof ParamList>(\n    _: RouteConfig<ParamList, RouteName, State, ScreenOptions, EventMap>\n  ) => null;\n};\n\nexport type NavigatorScreenParams<\n  ParamList,\n  State extends NavigationState = NavigationState\n> =\n  | {\n      screen?: never;\n      params?: never;\n      initial?: never;\n      path?: string;\n      state: PartialState<State> | State | undefined;\n    }\n  | {\n      [RouteName in keyof ParamList]: undefined extends ParamList[RouteName]\n        ? {\n            screen: RouteName;\n            params?: ParamList[RouteName];\n            initial?: boolean;\n            path?: string;\n            state?: never;\n          }\n        : {\n            screen: RouteName;\n            params: ParamList[RouteName];\n            initial?: boolean;\n            path?: string;\n            state?: never;\n          };\n    }[keyof ParamList];\n\nexport type PathConfig<ParamList extends {}> = {\n  path?: string;\n  exact?: boolean;\n  parse?: Record<string, (value: string) => any>;\n  stringify?: Record<string, (value: any) => string>;\n  screens?: PathConfigMap<ParamList>;\n  initialRouteName?: keyof ParamList;\n};\n\nexport type PathConfigMap<ParamList extends {}> = {\n  [RouteName in keyof ParamList]?: NonNullable<\n    ParamList[RouteName]\n  > extends NavigatorScreenParams<infer T extends {}>\n    ? string | PathConfig<T>\n    : string | Omit<PathConfig<{}>, 'screens' | 'initialRouteName'>;\n};\n","import * as React from 'react';\n\nimport type { ListenerMap } from './NavigationBuilderContext';\n\n/**\n * Hook which lets child navigators add action listeners.\n */\nexport default function useChildListeners() {\n  const { current: listeners } = React.useRef<{\n    [K in keyof ListenerMap]: ListenerMap[K][];\n  }>({\n    action: [],\n    focus: [],\n  });\n\n  const addListener = React.useCallback(\n    <T extends keyof ListenerMap>(type: T, listener: ListenerMap[T]) => {\n      listeners[type].push(listener);\n\n      let removed = false;\n      return () => {\n        const index = listeners[type].indexOf(listener);\n\n        if (!removed && index > -1) {\n          removed = true;\n          listeners[type].splice(index, 1);\n        }\n      };\n    },\n    [listeners]\n  );\n\n  return {\n    listeners,\n    addListener,\n  };\n}\n","import * as React from 'react';\n\ntype Render = (children: React.ReactNode) => JSX.Element;\n\ntype Props = {\n  render: Render;\n  children: React.ReactNode;\n};\n\nconst NavigationContent = ({ render, children }: Props) => {\n  return render(children);\n};\n\nexport default function useComponent(render: Render) {\n  const renderRef = React.useRef<Render | null>(render);\n\n  // Normally refs shouldn't be mutated in render\n  // But we return a component which will be rendered\n  // So it's just for immediate consumption\n  renderRef.current = render;\n\n  React.useEffect(() => {\n    renderRef.current = null;\n  });\n\n  return React.useRef(({ children }: { children: React.ReactNode }) => {\n    const render = renderRef.current;\n\n    if (render === null) {\n      throw new Error(\n        'The returned component must be rendered in the same render phase as the hook.'\n      );\n    }\n\n    return <NavigationContent render={render}>{children}</NavigationContent>;\n  }).current;\n}\n","import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport CurrentRenderContext from './CurrentRenderContext';\nimport type {\n  Descriptor,\n  NavigationHelpers,\n  NavigationProp,\n  RouteProp,\n} from './types';\n\ntype Options = {\n  state: NavigationState;\n  navigation: NavigationHelpers<ParamListBase>;\n  descriptors: Record<\n    string,\n    Descriptor<object, NavigationProp<ParamListBase>, RouteProp<ParamListBase>>\n  >;\n};\n\n/**\n * Write the current options, so that server renderer can get current values\n * Mutating values like this is not safe in async mode, but it doesn't apply to SSR\n */\nexport default function useCurrentRender({\n  state,\n  navigation,\n  descriptors,\n}: Options) {\n  const current = React.useContext(CurrentRenderContext);\n\n  if (current && navigation.isFocused()) {\n    current.options = descriptors[state.routes[state.index].key].options;\n  }\n}\n","import type {\n  NavigationAction,\n  NavigationState,\n  ParamListBase,\n  Router,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationBuilderContext, {\n  AddKeyedListener,\n  AddListener,\n} from './NavigationBuilderContext';\nimport NavigationContext from './NavigationContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nimport SceneView from './SceneView';\nimport type {\n  Descriptor,\n  EventMapBase,\n  NavigationHelpers,\n  NavigationProp,\n  RouteConfig,\n  RouteProp,\n} from './types';\nimport type { NavigationEventEmitter } from './useEventEmitter';\nimport useNavigationCache from './useNavigationCache';\nimport useRouteCache from './useRouteCache';\n\nexport type ScreenConfigWithParent<\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase\n> = {\n  keys: (string | undefined)[];\n  options: (ScreenOptionsOrCallback<ScreenOptions> | undefined)[] | undefined;\n  props: RouteConfig<ParamListBase, string, State, ScreenOptions, EventMap>;\n};\n\ntype ScreenOptionsOrCallback<ScreenOptions extends {}> =\n  | ScreenOptions\n  | ((props: {\n      route: RouteProp<ParamListBase, string>;\n      navigation: any;\n    }) => ScreenOptions);\n\ntype Options<\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase\n> = {\n  state: State;\n  screens: Record<\n    string,\n    ScreenConfigWithParent<State, ScreenOptions, EventMap>\n  >;\n  navigation: NavigationHelpers<ParamListBase>;\n  screenOptions?: ScreenOptionsOrCallback<ScreenOptions>;\n  defaultScreenOptions?:\n    | ScreenOptions\n    | ((props: {\n        route: RouteProp<ParamListBase>;\n        navigation: any;\n        options: ScreenOptions;\n      }) => ScreenOptions);\n  onAction: (action: NavigationAction) => boolean;\n  getState: () => State;\n  setState: (state: State) => void;\n  addListener: AddListener;\n  addKeyedListener: AddKeyedListener;\n  onRouteFocus: (key: string) => void;\n  router: Router<State, NavigationAction>;\n  emitter: NavigationEventEmitter<EventMap>;\n};\n\n/**\n * Hook to create descriptor objects for the child routes.\n *\n * A descriptor object provides 3 things:\n * - Helper method to render a screen\n * - Options specified by the screen for the navigator\n * - Navigation object intended for the route\n */\nexport default function useDescriptors<\n  State extends NavigationState,\n  ActionHelpers extends Record<string, () => void>,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase\n>({\n  state,\n  screens,\n  navigation,\n  screenOptions,\n  defaultScreenOptions,\n  onAction,\n  getState,\n  setState,\n  addListener,\n  addKeyedListener,\n  onRouteFocus,\n  router,\n  emitter,\n}: Options<State, ScreenOptions, EventMap>) {\n  const [options, setOptions] = React.useState<Record<string, object>>({});\n  const { onDispatchAction, onOptionsChange, stackRef } = React.useContext(\n    NavigationBuilderContext\n  );\n\n  const context = React.useMemo(\n    () => ({\n      navigation,\n      onAction,\n      addListener,\n      addKeyedListener,\n      onRouteFocus,\n      onDispatchAction,\n      onOptionsChange,\n      stackRef,\n    }),\n    [\n      navigation,\n      onAction,\n      addListener,\n      addKeyedListener,\n      onRouteFocus,\n      onDispatchAction,\n      onOptionsChange,\n      stackRef,\n    ]\n  );\n\n  const navigations = useNavigationCache<State, ScreenOptions, EventMap>({\n    state,\n    getState,\n    navigation,\n    setOptions,\n    router,\n    emitter,\n  });\n\n  const routes = useRouteCache(state.routes);\n\n  return routes.reduce<\n    Record<\n      string,\n      Descriptor<\n        ScreenOptions,\n        NavigationProp<\n          ParamListBase,\n          string,\n          string | undefined,\n          State,\n          ScreenOptions,\n          EventMap\n        > &\n          ActionHelpers,\n        RouteProp<ParamListBase>\n      >\n    >\n  >((acc, route, i) => {\n    const config = screens[route.name];\n    const screen = config.props;\n    const navigation = navigations[route.key];\n\n    const optionsList = [\n      // The default `screenOptions` passed to the navigator\n      screenOptions,\n      // The `screenOptions` props passed to `Group` elements\n      ...((config.options\n        ? config.options.filter(Boolean)\n        : []) as ScreenOptionsOrCallback<ScreenOptions>[]),\n      // The `options` prop passed to `Screen` elements,\n      screen.options,\n      // The options set via `navigation.setOptions`\n      options[route.key],\n    ];\n\n    const customOptions = optionsList.reduce<ScreenOptions>(\n      (acc, curr) =>\n        Object.assign(\n          acc,\n          // @ts-expect-error: we check for function but TS still complains\n          typeof curr !== 'function' ? curr : curr({ route, navigation })\n        ),\n      {} as ScreenOptions\n    );\n\n    const mergedOptions = {\n      ...(typeof defaultScreenOptions === 'function'\n        ? // @ts-expect-error: ts gives incorrect error here\n          defaultScreenOptions({\n            route,\n            navigation,\n            options: customOptions,\n          })\n        : defaultScreenOptions),\n      ...customOptions,\n    };\n\n    const clearOptions = () =>\n      setOptions((o) => {\n        if (route.key in o) {\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          const { [route.key]: _, ...rest } = o;\n          return rest;\n        }\n\n        return o;\n      });\n\n    acc[route.key] = {\n      route,\n      // @ts-expect-error: it's missing action helpers, fix later\n      navigation,\n      render() {\n        return (\n          <NavigationBuilderContext.Provider key={route.key} value={context}>\n            <NavigationContext.Provider value={navigation}>\n              <NavigationRouteContext.Provider value={route}>\n                <SceneView\n                  navigation={navigation}\n                  route={route}\n                  screen={screen}\n                  routeState={state.routes[i].state}\n                  getState={getState}\n                  setState={setState}\n                  options={mergedOptions}\n                  clearOptions={clearOptions}\n                />\n              </NavigationRouteContext.Provider>\n            </NavigationContext.Provider>\n          </NavigationBuilderContext.Provider>\n        );\n      },\n      options: mergedOptions as ScreenOptions,\n    };\n\n    return acc;\n  }, {});\n}\n","import * as React from 'react';\n\nimport type { EventArg, EventConsumer, EventEmitter } from './types';\n\nexport type NavigationEventEmitter<T extends Record<string, any>> =\n  EventEmitter<T> & {\n    create: (target: string) => EventConsumer<T>;\n  };\n\ntype Listeners = ((e: any) => void)[];\n\n/**\n * Hook to manage the event system used by the navigator to notify screens of various events.\n */\nexport default function useEventEmitter<T extends Record<string, any>>(\n  listen?: (e: any) => void\n): NavigationEventEmitter<T> {\n  const listenRef = React.useRef(listen);\n\n  React.useEffect(() => {\n    listenRef.current = listen;\n  });\n\n  const listeners = React.useRef<Record<string, Record<string, Listeners>>>(\n    Object.create(null)\n  );\n\n  const create = React.useCallback((target: string) => {\n    const removeListener = (type: string, callback: (data: any) => void) => {\n      const callbacks = listeners.current[type]\n        ? listeners.current[type][target]\n        : undefined;\n\n      if (!callbacks) {\n        return;\n      }\n\n      const index = callbacks.indexOf(callback);\n\n      if (index > -1) {\n        callbacks.splice(index, 1);\n      }\n    };\n\n    const addListener = (type: string, callback: (data: any) => void) => {\n      listeners.current[type] = listeners.current[type] || {};\n      listeners.current[type][target] = listeners.current[type][target] || [];\n      listeners.current[type][target].push(callback);\n\n      let removed = false;\n      return () => {\n        // Prevent removing other listeners when unsubscribing same listener multiple times\n        if (!removed) {\n          removed = true;\n          removeListener(type, callback);\n        }\n      };\n    };\n\n    return {\n      addListener,\n      removeListener,\n    };\n  }, []);\n\n  const emit = React.useCallback(\n    ({\n      type,\n      data,\n      target,\n      canPreventDefault,\n    }: {\n      type: string;\n      data?: any;\n      target?: string;\n      canPreventDefault?: boolean;\n    }) => {\n      const items = listeners.current[type] || {};\n\n      // Copy the current list of callbacks in case they are mutated during execution\n      const callbacks =\n        target !== undefined\n          ? items[target]?.slice()\n          : ([] as Listeners)\n              .concat(...Object.keys(items).map((t) => items[t]))\n              .filter((cb, i, self) => self.lastIndexOf(cb) === i);\n\n      const event: EventArg<any, any, any> = {\n        get type() {\n          return type;\n        },\n      };\n\n      if (target !== undefined) {\n        Object.defineProperty(event, 'target', {\n          enumerable: true,\n          get() {\n            return target;\n          },\n        });\n      }\n\n      if (data !== undefined) {\n        Object.defineProperty(event, 'data', {\n          enumerable: true,\n          get() {\n            return data;\n          },\n        });\n      }\n\n      if (canPreventDefault) {\n        let defaultPrevented = false;\n\n        Object.defineProperties(event, {\n          defaultPrevented: {\n            enumerable: true,\n            get() {\n              return defaultPrevented;\n            },\n          },\n          preventDefault: {\n            enumerable: true,\n            value() {\n              defaultPrevented = true;\n            },\n          },\n        });\n      }\n\n      listenRef.current?.(event);\n\n      callbacks?.forEach((cb) => cb(event));\n\n      return event as any;\n    },\n    []\n  );\n\n  return React.useMemo(() => ({ create, emit }), [create, emit]);\n}\n","import * as React from 'react';\n\nimport useNavigation from './useNavigation';\n\ntype EffectCallback = () => undefined | void | (() => void);\n\n/**\n * Hook to run an effect in a focused screen, similar to `React.useEffect`.\n * This can be used to perform side-effects such as fetching data or subscribing to events.\n * The passed callback should be wrapped in `React.useCallback` to avoid running the effect too often.\n *\n * @param callback Memoized callback containing the effect, should optionally return a cleanup function.\n */\nexport default function useFocusEffect(effect: EffectCallback) {\n  const navigation = useNavigation();\n\n  if (arguments[1] !== undefined) {\n    const message =\n      \"You passed a second argument to 'useFocusEffect', but it only accepts one argument. \" +\n      \"If you want to pass a dependency array, you can use 'React.useCallback':\\n\\n\" +\n      'useFocusEffect(\\n' +\n      '  React.useCallback(() => {\\n' +\n      '    // Your code here\\n' +\n      '  }, [depA, depB])\\n' +\n      ');\\n\\n' +\n      'See usage guide: https://reactnavigation.org/docs/use-focus-effect';\n\n    console.error(message);\n  }\n\n  React.useEffect(() => {\n    let isFocused = false;\n    let cleanup: undefined | void | (() => void);\n\n    const callback = () => {\n      const destroy = effect();\n\n      if (destroy === undefined || typeof destroy === 'function') {\n        return destroy;\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        let message =\n          'An effect function must not return anything besides a function, which is used for clean-up.';\n\n        if (destroy === null) {\n          message +=\n            \" You returned 'null'. If your effect does not require clean-up, return 'undefined' (or nothing).\";\n        } else if (typeof (destroy as any).then === 'function') {\n          message +=\n            \"\\n\\nIt looks like you wrote 'useFocusEffect(async () => ...)' or returned a Promise. \" +\n            'Instead, write the async function inside your effect ' +\n            'and call it immediately:\\n\\n' +\n            'useFocusEffect(\\n' +\n            '  React.useCallback(() => {\\n' +\n            '    async function fetchData() {\\n' +\n            '      // You can await here\\n' +\n            '      const response = await MyAPI.getData(someId);\\n' +\n            '      // ...\\n' +\n            '    }\\n\\n' +\n            '    fetchData();\\n' +\n            '  }, [someId])\\n' +\n            ');\\n\\n' +\n            'See usage guide: https://reactnavigation.org/docs/use-focus-effect';\n        } else {\n          message += ` You returned '${JSON.stringify(destroy)}'.`;\n        }\n\n        console.error(message);\n      }\n    };\n\n    // We need to run the effect on intial render/dep changes if the screen is focused\n    if (navigation.isFocused()) {\n      cleanup = callback();\n      isFocused = true;\n    }\n\n    const unsubscribeFocus = navigation.addListener('focus', () => {\n      // If callback was already called for focus, avoid calling it again\n      // The focus event may also fire on intial render, so we guard against runing the effect twice\n      if (isFocused) {\n        return;\n      }\n\n      if (cleanup !== undefined) {\n        cleanup();\n      }\n\n      cleanup = callback();\n      isFocused = true;\n    });\n\n    const unsubscribeBlur = navigation.addListener('blur', () => {\n      if (cleanup !== undefined) {\n        cleanup();\n      }\n\n      cleanup = undefined;\n      isFocused = false;\n    });\n\n    return () => {\n      if (cleanup !== undefined) {\n        cleanup();\n      }\n\n      unsubscribeFocus();\n      unsubscribeBlur();\n    };\n  }, [effect, navigation]);\n}\n","import type { NavigationState } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationContext from './NavigationContext';\nimport type { EventMapCore } from './types';\nimport type { NavigationEventEmitter } from './useEventEmitter';\n\ntype Options<State extends NavigationState> = {\n  state: State;\n  emitter: NavigationEventEmitter<EventMapCore<State>>;\n};\n\n/**\n * Hook to take care of emitting `focus` and `blur` events.\n */\nexport default function useFocusEvents<State extends NavigationState>({\n  state,\n  emitter,\n}: Options<State>) {\n  const navigation = React.useContext(NavigationContext);\n  const lastFocusedKeyRef = React.useRef<string | undefined>();\n\n  const currentFocusedKey = state.routes[state.index].key;\n\n  // When the parent screen changes its focus state, we also need to change child's focus\n  // Coz the child screen can't be focused if the parent screen is out of focus\n  React.useEffect(\n    () =>\n      navigation?.addListener('focus', () => {\n        lastFocusedKeyRef.current = currentFocusedKey;\n        emitter.emit({ type: 'focus', target: currentFocusedKey });\n      }),\n    [currentFocusedKey, emitter, navigation]\n  );\n\n  React.useEffect(\n    () =>\n      navigation?.addListener('blur', () => {\n        lastFocusedKeyRef.current = undefined;\n        emitter.emit({ type: 'blur', target: currentFocusedKey });\n      }),\n    [currentFocusedKey, emitter, navigation]\n  );\n\n  React.useEffect(() => {\n    const lastFocusedKey = lastFocusedKeyRef.current;\n\n    lastFocusedKeyRef.current = currentFocusedKey;\n\n    // We wouldn't have `lastFocusedKey` on initial mount\n    // Fire focus event for the current route on mount if there's no parent navigator\n    if (lastFocusedKey === undefined && !navigation) {\n      emitter.emit({ type: 'focus', target: currentFocusedKey });\n    }\n\n    // We should only emit events when the focused key changed and navigator is focused\n    // When navigator is not focused, screens inside shouldn't receive focused status either\n    if (\n      lastFocusedKey === currentFocusedKey ||\n      !(navigation ? navigation.isFocused() : true)\n    ) {\n      return;\n    }\n\n    if (lastFocusedKey === undefined) {\n      // Only fire events after initial mount\n      return;\n    }\n\n    emitter.emit({ type: 'blur', target: lastFocusedKey });\n    emitter.emit({ type: 'focus', target: currentFocusedKey });\n  }, [currentFocusedKey, emitter, navigation]);\n}\n","import type { ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationBuilderContext, {\n  FocusedNavigationCallback,\n  FocusedNavigationListener,\n} from './NavigationBuilderContext';\nimport type { NavigationHelpers } from './types';\n\ntype Options = {\n  navigation: NavigationHelpers<ParamListBase>;\n  focusedListeners: FocusedNavigationListener[];\n};\n\n/**\n * Hook for passing focus callback to children\n */\nexport default function useFocusedListenersChildrenAdapter({\n  navigation,\n  focusedListeners,\n}: Options) {\n  const { addListener } = React.useContext(NavigationBuilderContext);\n\n  const listener = React.useCallback(\n    (callback: FocusedNavigationCallback<any>) => {\n      if (navigation.isFocused()) {\n        for (const listener of focusedListeners) {\n          const { handled, result } = listener(callback);\n\n          if (handled) {\n            return { handled, result };\n          }\n        }\n\n        return { handled: true, result: callback(navigation) };\n      } else {\n        return { handled: false, result: null };\n      }\n    },\n    [focusedListeners, navigation]\n  );\n\n  React.useEffect(\n    () => addListener?.('focus', listener),\n    [addListener, listener]\n  );\n}\n","import * as React from 'react';\nimport { useState } from 'react';\n\nimport useNavigation from './useNavigation';\n\n/**\n * Hook to get the current focus state of the screen. Returns a `true` if screen is focused, otherwise `false`.\n * This can be used if a component needs to render something based on the focus state.\n */\nexport default function useIsFocused(): boolean {\n  const navigation = useNavigation();\n  const [isFocused, setIsFocused] = useState(navigation.isFocused);\n\n  const valueToReturn = navigation.isFocused();\n\n  if (isFocused !== valueToReturn) {\n    // If the value has changed since the last render, we need to update it.\n    // This could happen if we missed an update from the event listeners during re-render.\n    // React will process this update immediately, so the old subscription value won't be committed.\n    // It is still nice to avoid returning a mismatched value though, so let's override the return value.\n    // This is the same logic as in https://github.com/facebook/react/tree/master/packages/use-subscription\n    setIsFocused(valueToReturn);\n  }\n\n  React.useEffect(() => {\n    const unsubscribeFocus = navigation.addListener('focus', () =>\n      setIsFocused(true)\n    );\n\n    const unsubscribeBlur = navigation.addListener('blur', () =>\n      setIsFocused(false)\n    );\n\n    return () => {\n      unsubscribeFocus();\n      unsubscribeBlur();\n    };\n  }, [navigation]);\n\n  React.useDebugValue(valueToReturn);\n\n  return valueToReturn;\n}\n","import * as React from 'react';\n\nimport type { KeyedListenerMap } from './NavigationBuilderContext';\n\n/**\n * Hook which lets child navigators add getters to be called for obtaining rehydrated state.\n */\nexport default function useKeyedChildListeners() {\n  const { current: keyedListeners } = React.useRef<{\n    [K in keyof KeyedListenerMap]: Record<\n      string,\n      KeyedListenerMap[K] | undefined\n    >;\n  }>(\n    Object.assign(Object.create(null), {\n      getState: {},\n      beforeRemove: {},\n    })\n  );\n\n  const addKeyedListener = React.useCallback(\n    <T extends keyof KeyedListenerMap>(\n      type: T,\n      key: string,\n      listener: KeyedListenerMap[T]\n    ) => {\n      // @ts-expect-error: according to ref stated above you can use `key` to index type\n      keyedListeners[type][key] = listener;\n\n      return () => {\n        // @ts-expect-error: according to ref stated above you can use `key` to index type\n        keyedListeners[type][key] = undefined;\n      };\n    },\n    [keyedListeners]\n  );\n\n  return {\n    keyedListeners,\n    addKeyedListener,\n  };\n}\n","import type { NavigationState } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationContainerRefContext from './NavigationContainerRefContext';\nimport NavigationContext from './NavigationContext';\nimport type { NavigationProp } from './types';\n\n/**\n * Hook to access the navigation prop of the parent screen anywhere.\n *\n * @returns Navigation prop of the parent screen.\n */\nexport default function useNavigation<\n  T = Omit<NavigationProp<ReactNavigation.RootParamList>, 'getState'> & {\n    getState(): NavigationState | undefined;\n  }\n>(): T {\n  const root = React.useContext(NavigationContainerRefContext);\n  const navigation = React.useContext(NavigationContext);\n\n  if (navigation === undefined && root === undefined) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  // FIXME: Figure out a better way to do this\n  return (navigation ?? root) as unknown as T;\n}\n","import {\n  CommonActions,\n  DefaultRouterOptions,\n  NavigationAction,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n  Route,\n  Router,\n  RouterConfigOptions,\n  RouterFactory,\n} from '@react-navigation/routers';\nimport * as React from 'react';\nimport { isValidElementType } from 'react-is';\n\nimport Group from './Group';\nimport isArrayEqual from './isArrayEqual';\nimport isRecordEqual from './isRecordEqual';\nimport NavigationHelpersContext from './NavigationHelpersContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nimport NavigationStateContext from './NavigationStateContext';\nimport PreventRemoveProvider from './PreventRemoveProvider';\nimport Screen from './Screen';\nimport {\n  DefaultNavigatorOptions,\n  EventMapBase,\n  EventMapCore,\n  NavigatorScreenParams,\n  PrivateValueStore,\n  RouteConfig,\n  RouteProp,\n} from './types';\nimport useChildListeners from './useChildListeners';\nimport useComponent from './useComponent';\nimport useCurrentRender from './useCurrentRender';\nimport useDescriptors, { ScreenConfigWithParent } from './useDescriptors';\nimport useEventEmitter from './useEventEmitter';\nimport useFocusedListenersChildrenAdapter from './useFocusedListenersChildrenAdapter';\nimport useFocusEvents from './useFocusEvents';\nimport useKeyedChildListeners from './useKeyedChildListeners';\nimport useNavigationHelpers from './useNavigationHelpers';\nimport useOnAction from './useOnAction';\nimport useOnGetState from './useOnGetState';\nimport useOnRouteFocus from './useOnRouteFocus';\nimport useRegisterNavigator from './useRegisterNavigator';\nimport useScheduleUpdate from './useScheduleUpdate';\n\n// This is to make TypeScript compiler happy\n// eslint-disable-next-line babel/no-unused-expressions\nPrivateValueStore;\n\ntype NavigationBuilderOptions<ScreenOptions extends {}> = {\n  /**\n   * Default options specified by the navigator.\n   * It receives the custom options in the arguments if a function is specified.\n   */\n  defaultScreenOptions?:\n    | ScreenOptions\n    | ((props: {\n        route: RouteProp<ParamListBase>;\n        navigation: any;\n        options: ScreenOptions;\n      }) => ScreenOptions);\n};\n\ntype NavigatorRoute<State extends NavigationState> = {\n  key: string;\n  params?: NavigatorScreenParams<ParamListBase, State>;\n};\n\nconst isValidKey = (key: unknown) =>\n  key === undefined || (typeof key === 'string' && key !== '');\n\n/**\n * Extract route config object from React children elements.\n *\n * @param children React Elements to extract the config from.\n */\nconst getRouteConfigsFromChildren = <\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends EventMapBase\n>(\n  children: React.ReactNode,\n  groupKey?: string,\n  groupOptions?: ScreenConfigWithParent<\n    State,\n    ScreenOptions,\n    EventMap\n  >['options']\n) => {\n  const configs = React.Children.toArray(children).reduce<\n    ScreenConfigWithParent<State, ScreenOptions, EventMap>[]\n  >((acc, child) => {\n    if (React.isValidElement(child)) {\n      if (child.type === Screen) {\n        // We can only extract the config from `Screen` elements\n        // If something else was rendered, it's probably a bug\n\n        if (!isValidKey(child.props.navigationKey)) {\n          throw new Error(\n            `Got an invalid 'navigationKey' prop (${JSON.stringify(\n              child.props.navigationKey\n            )}) for the screen '${\n              child.props.name\n            }'. It must be a non-empty string or 'undefined'.`\n          );\n        }\n\n        acc.push({\n          keys: [groupKey, child.props.navigationKey],\n          options: groupOptions,\n          props: child.props as RouteConfig<\n            ParamListBase,\n            string,\n            State,\n            ScreenOptions,\n            EventMap\n          >,\n        });\n        return acc;\n      }\n\n      if (child.type === React.Fragment || child.type === Group) {\n        if (!isValidKey(child.props.navigationKey)) {\n          throw new Error(\n            `Got an invalid 'navigationKey' prop (${JSON.stringify(\n              child.props.navigationKey\n            )}) for the group. It must be a non-empty string or 'undefined'.`\n          );\n        }\n\n        // When we encounter a fragment or group, we need to dive into its children to extract the configs\n        // This is handy to conditionally define a group of screens\n        acc.push(\n          ...getRouteConfigsFromChildren<State, ScreenOptions, EventMap>(\n            child.props.children,\n            child.props.navigationKey,\n            child.type !== Group\n              ? groupOptions\n              : groupOptions != null\n              ? [...groupOptions, child.props.screenOptions]\n              : [child.props.screenOptions]\n          )\n        );\n        return acc;\n      }\n    }\n\n    throw new Error(\n      `A navigator can only contain 'Screen', 'Group' or 'React.Fragment' as its direct children (found ${\n        React.isValidElement(child)\n          ? `'${\n              typeof child.type === 'string' ? child.type : child.type?.name\n            }'${\n              child.props != null &&\n              typeof child.props === 'object' &&\n              'name' in child.props &&\n              child.props?.name\n                ? ` for the screen '${child.props.name}'`\n                : ''\n            }`\n          : typeof child === 'object'\n          ? JSON.stringify(child)\n          : `'${String(child)}'`\n      }). To render this component in the navigator, pass it in the 'component' prop to 'Screen'.`\n    );\n  }, []);\n\n  if (process.env.NODE_ENV !== 'production') {\n    configs.forEach((config) => {\n      const { name, children, component, getComponent } = config.props;\n\n      if (typeof name !== 'string' || !name) {\n        throw new Error(\n          `Got an invalid name (${JSON.stringify(\n            name\n          )}) for the screen. It must be a non-empty string.`\n        );\n      }\n\n      if (\n        children != null ||\n        component !== undefined ||\n        getComponent !== undefined\n      ) {\n        if (children != null && component !== undefined) {\n          throw new Error(\n            `Got both 'component' and 'children' props for the screen '${name}'. You must pass only one of them.`\n          );\n        }\n\n        if (children != null && getComponent !== undefined) {\n          throw new Error(\n            `Got both 'getComponent' and 'children' props for the screen '${name}'. You must pass only one of them.`\n          );\n        }\n\n        if (component !== undefined && getComponent !== undefined) {\n          throw new Error(\n            `Got both 'component' and 'getComponent' props for the screen '${name}'. You must pass only one of them.`\n          );\n        }\n\n        if (children != null && typeof children !== 'function') {\n          throw new Error(\n            `Got an invalid value for 'children' prop for the screen '${name}'. It must be a function returning a React Element.`\n          );\n        }\n\n        if (component !== undefined && !isValidElementType(component)) {\n          throw new Error(\n            `Got an invalid value for 'component' prop for the screen '${name}'. It must be a valid React Component.`\n          );\n        }\n\n        if (getComponent !== undefined && typeof getComponent !== 'function') {\n          throw new Error(\n            `Got an invalid value for 'getComponent' prop for the screen '${name}'. It must be a function returning a React Component.`\n          );\n        }\n\n        if (typeof component === 'function') {\n          if (component.name === 'component') {\n            // Inline anonymous functions passed in the `component` prop will have the name of the prop\n            // It's relatively safe to assume that it's not a component since it should also have PascalCase name\n            // We won't catch all scenarios here, but this should catch a good chunk of incorrect use.\n            console.warn(\n              `Looks like you're passing an inline function for 'component' prop for the screen '${name}' (e.g. component={() => <SomeComponent />}). Passing an inline function will cause the component state to be lost on re-render and cause perf issues since it's re-created every render. You can pass the function as children to 'Screen' instead to achieve the desired behaviour.`\n            );\n          } else if (/^[a-z]/.test(component.name)) {\n            console.warn(\n              `Got a component with the name '${component.name}' for the screen '${name}'. React Components must start with an uppercase letter. If you're passing a regular function and not a component, pass it as children to 'Screen' instead. Otherwise capitalize your component's name.`\n            );\n          }\n        }\n      } else {\n        throw new Error(\n          `Couldn't find a 'component', 'getComponent' or 'children' prop for the screen '${name}'. This can happen if you passed 'undefined'. You likely forgot to export your component from the file it's defined in, or mixed up default import and named import when importing.`\n        );\n      }\n    });\n  }\n\n  return configs;\n};\n\n/**\n * Hook for building navigators.\n *\n * @param createRouter Factory method which returns router object.\n * @param options Options object containing `children` and additional options for the router.\n * @returns An object containing `state`, `navigation`, `descriptors` objects.\n */\nexport default function useNavigationBuilder<\n  State extends NavigationState,\n  RouterOptions extends DefaultRouterOptions,\n  ActionHelpers extends Record<string, () => void>,\n  ScreenOptions extends {},\n  EventMap extends Record<string, any>\n>(\n  createRouter: RouterFactory<State, any, RouterOptions>,\n  options: DefaultNavigatorOptions<\n    ParamListBase,\n    State,\n    ScreenOptions,\n    EventMap\n  > &\n    NavigationBuilderOptions<ScreenOptions> &\n    RouterOptions\n) {\n  const navigatorKey = useRegisterNavigator();\n\n  const route = React.useContext(NavigationRouteContext) as\n    | NavigatorRoute<State>\n    | undefined;\n\n  const { children, screenListeners, ...rest } = options;\n  const { current: router } = React.useRef<Router<State, any>>(\n    createRouter({\n      ...(rest as unknown as RouterOptions),\n      ...(route?.params &&\n      route.params.state == null &&\n      route.params.initial !== false &&\n      typeof route.params.screen === 'string'\n        ? { initialRouteName: route.params.screen }\n        : null),\n    })\n  );\n\n  const routeConfigs = getRouteConfigsFromChildren<\n    State,\n    ScreenOptions,\n    EventMap\n  >(children);\n\n  const screens = routeConfigs.reduce<\n    Record<string, ScreenConfigWithParent<State, ScreenOptions, EventMap>>\n  >((acc, config) => {\n    if (config.props.name in acc) {\n      throw new Error(\n        `A navigator cannot contain multiple 'Screen' components with the same name (found duplicate screen named '${config.props.name}')`\n      );\n    }\n\n    acc[config.props.name] = config;\n    return acc;\n  }, {});\n\n  const routeNames = routeConfigs.map((config) => config.props.name);\n  const routeKeyList = routeNames.reduce<Record<string, React.Key | undefined>>(\n    (acc, curr) => {\n      acc[curr] = screens[curr].keys.map((key) => key ?? '').join(':');\n      return acc;\n    },\n    {}\n  );\n  const routeParamList = routeNames.reduce<Record<string, object | undefined>>(\n    (acc, curr) => {\n      const { initialParams } = screens[curr].props;\n      acc[curr] = initialParams;\n      return acc;\n    },\n    {}\n  );\n  const routeGetIdList = routeNames.reduce<\n    RouterConfigOptions['routeGetIdList']\n  >(\n    (acc, curr) =>\n      Object.assign(acc, {\n        [curr]: screens[curr].props.getId,\n      }),\n    {}\n  );\n\n  if (!routeNames.length) {\n    throw new Error(\n      \"Couldn't find any screens for the navigator. Have you defined any screens as its children?\"\n    );\n  }\n\n  const isStateValid = React.useCallback(\n    (state: NavigationState | PartialState<NavigationState>) =>\n      state.type === undefined || state.type === router.type,\n    [router.type]\n  );\n\n  const isStateInitialized = React.useCallback(\n    (state: NavigationState | PartialState<NavigationState> | undefined) =>\n      state !== undefined && state.stale === false && isStateValid(state),\n    [isStateValid]\n  );\n\n  const {\n    state: currentState,\n    getState: getCurrentState,\n    setState: setCurrentState,\n    setKey,\n    getKey,\n    getIsInitial,\n  } = React.useContext(NavigationStateContext);\n\n  const stateCleanedUp = React.useRef(false);\n\n  const cleanUpState = React.useCallback(() => {\n    setCurrentState(undefined);\n    stateCleanedUp.current = true;\n  }, [setCurrentState]);\n\n  const setState = React.useCallback(\n    (state: NavigationState | PartialState<NavigationState> | undefined) => {\n      if (stateCleanedUp.current) {\n        // State might have been already cleaned up due to unmount\n        // We do not want to expose API allowing to override this\n        // This would lead to old data preservation on main navigator unmount\n        return;\n      }\n      setCurrentState(state);\n    },\n    [setCurrentState]\n  );\n\n  const [initializedState, isFirstStateInitialization] = React.useMemo(() => {\n    const initialRouteParamList = routeNames.reduce<\n      Record<string, object | undefined>\n    >((acc, curr) => {\n      const { initialParams } = screens[curr].props;\n      const initialParamsFromParams =\n        route?.params?.state == null &&\n        route?.params?.initial !== false &&\n        route?.params?.screen === curr\n          ? route.params.params\n          : undefined;\n\n      acc[curr] =\n        initialParams !== undefined || initialParamsFromParams !== undefined\n          ? {\n              ...initialParams,\n              ...initialParamsFromParams,\n            }\n          : undefined;\n\n      return acc;\n    }, {});\n\n    // If the current state isn't initialized on first render, we initialize it\n    // We also need to re-initialize it if the state passed from parent was changed (maybe due to reset)\n    // Otherwise assume that the state was provided as initial state\n    // So we need to rehydrate it to make it usable\n    if (\n      (currentState === undefined || !isStateValid(currentState)) &&\n      route?.params?.state == null\n    ) {\n      return [\n        router.getInitialState({\n          routeNames,\n          routeParamList: initialRouteParamList,\n          routeGetIdList,\n        }),\n        true,\n      ];\n    } else {\n      return [\n        router.getRehydratedState(\n          route?.params?.state ?? (currentState as PartialState<State>),\n          {\n            routeNames,\n            routeParamList: initialRouteParamList,\n            routeGetIdList,\n          }\n        ),\n        false,\n      ];\n    }\n    // We explicitly don't include routeNames, route.params etc. in the dep list\n    // below. We want to avoid forcing a new state to be calculated in those cases\n    // Instead, we handle changes to these in the nextState code below. Note\n    // that some changes to routeConfigs are explicitly ignored, such as changes\n    // to initialParams\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [currentState, router, isStateValid]);\n\n  const previousRouteKeyListRef = React.useRef(routeKeyList);\n\n  React.useEffect(() => {\n    previousRouteKeyListRef.current = routeKeyList;\n  });\n\n  const previousRouteKeyList = previousRouteKeyListRef.current;\n\n  let state =\n    // If the state isn't initialized, or stale, use the state we initialized instead\n    // The state won't update until there's a change needed in the state we have initalized locally\n    // So it'll be `undefined` or stale until the first navigation event happens\n    isStateInitialized(currentState)\n      ? (currentState as State)\n      : (initializedState as State);\n\n  let nextState: State = state;\n\n  if (\n    !isArrayEqual(state.routeNames, routeNames) ||\n    !isRecordEqual(routeKeyList, previousRouteKeyList)\n  ) {\n    // When the list of route names change, the router should handle it to remove invalid routes\n    nextState = router.getStateForRouteNamesChange(state, {\n      routeNames,\n      routeParamList,\n      routeGetIdList,\n      routeKeyChanges: Object.keys(routeKeyList).filter(\n        (name) =>\n          previousRouteKeyList.hasOwnProperty(name) &&\n          routeKeyList[name] !== previousRouteKeyList[name]\n      ),\n    });\n  }\n\n  const previousNestedParamsRef = React.useRef(route?.params);\n\n  React.useEffect(() => {\n    previousNestedParamsRef.current = route?.params;\n  }, [route?.params]);\n\n  if (route?.params) {\n    const previousParams = previousNestedParamsRef.current;\n\n    let action: CommonActions.Action | undefined;\n\n    if (\n      typeof route.params.state === 'object' &&\n      route.params.state != null &&\n      route.params !== previousParams\n    ) {\n      // If the route was updated with new state, we should reset to it\n      action = CommonActions.reset(route.params.state);\n    } else if (\n      typeof route.params.screen === 'string' &&\n      ((route.params.initial === false && isFirstStateInitialization) ||\n        route.params !== previousParams)\n    ) {\n      // If the route was updated with new screen name and/or params, we should navigate there\n      action = CommonActions.navigate({\n        name: route.params.screen,\n        params: route.params.params,\n        path: route.params.path,\n      });\n    }\n\n    // The update should be limited to current navigator only, so we call the router manually\n    const updatedState = action\n      ? router.getStateForAction(nextState, action, {\n          routeNames,\n          routeParamList,\n          routeGetIdList,\n        })\n      : null;\n\n    nextState =\n      updatedState !== null\n        ? router.getRehydratedState(updatedState, {\n            routeNames,\n            routeParamList,\n            routeGetIdList,\n          })\n        : nextState;\n  }\n\n  const shouldUpdate = state !== nextState;\n\n  useScheduleUpdate(() => {\n    if (shouldUpdate) {\n      // If the state needs to be updated, we'll schedule an update\n      setState(nextState);\n    }\n  });\n\n  // The up-to-date state will come in next render, but we don't need to wait for it\n  // We can't use the outdated state since the screens have changed, which will cause error due to mismatched config\n  // So we override the state object we return to use the latest state as soon as possible\n  state = nextState;\n\n  React.useEffect(() => {\n    setKey(navigatorKey);\n\n    if (!getIsInitial()) {\n      // If it's not initial render, we need to update the state\n      // This will make sure that our container gets notifier of state changes due to new mounts\n      // This is necessary for proper screen tracking, URL updates etc.\n      setState(nextState);\n    }\n\n    return () => {\n      // We need to clean up state for this navigator on unmount\n      // We do it in a timeout because we need to detect if another navigator mounted in the meantime\n      // For example, if another navigator has started rendering, we should skip cleanup\n      // Otherwise, our cleanup step will cleanup state for the other navigator and re-initialize it\n      setTimeout(() => {\n        if (getCurrentState() !== undefined && getKey() === navigatorKey) {\n          cleanUpState();\n        }\n      }, 0);\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // We initialize this ref here to avoid a new getState getting initialized\n  // whenever initializedState changes. We want getState to have access to the\n  // latest initializedState, but don't need it to change when that happens\n  const initializedStateRef = React.useRef<State>();\n  initializedStateRef.current = initializedState;\n\n  const getState = React.useCallback((): State => {\n    const currentState = getCurrentState();\n\n    return isStateInitialized(currentState)\n      ? (currentState as State)\n      : (initializedStateRef.current as State);\n  }, [getCurrentState, isStateInitialized]);\n\n  const emitter = useEventEmitter<EventMapCore<State>>((e) => {\n    let routeNames = [];\n\n    let route: Route<string> | undefined;\n\n    if (e.target) {\n      route = state.routes.find((route) => route.key === e.target);\n\n      if (route?.name) {\n        routeNames.push(route.name);\n      }\n    } else {\n      route = state.routes[state.index];\n      routeNames.push(\n        ...Object.keys(screens).filter((name) => route?.name === name)\n      );\n    }\n\n    if (route == null) {\n      return;\n    }\n\n    const navigation = descriptors[route.key].navigation;\n\n    const listeners = ([] as (((e: any) => void) | undefined)[])\n      .concat(\n        // Get an array of listeners for all screens + common listeners on navigator\n        ...[\n          screenListeners,\n          ...routeNames.map((name) => {\n            const { listeners } = screens[name].props;\n            return listeners;\n          }),\n        ].map((listeners) => {\n          const map =\n            typeof listeners === 'function'\n              ? listeners({ route: route as any, navigation })\n              : listeners;\n\n          return map\n            ? Object.keys(map)\n                .filter((type) => type === e.type)\n                .map((type) => map?.[type])\n            : undefined;\n        })\n      )\n      // We don't want same listener to be called multiple times for same event\n      // So we remove any duplicate functions from the array\n      .filter((cb, i, self) => cb && self.lastIndexOf(cb) === i);\n\n    listeners.forEach((listener) => listener?.(e));\n  });\n\n  useFocusEvents({ state, emitter });\n\n  React.useEffect(() => {\n    emitter.emit({ type: 'state', data: { state } });\n  }, [emitter, state]);\n\n  const { listeners: childListeners, addListener } = useChildListeners();\n\n  const { keyedListeners, addKeyedListener } = useKeyedChildListeners();\n\n  const onAction = useOnAction({\n    router,\n    getState,\n    setState,\n    key: route?.key,\n    actionListeners: childListeners.action,\n    beforeRemoveListeners: keyedListeners.beforeRemove,\n    routerConfigOptions: {\n      routeNames,\n      routeParamList,\n      routeGetIdList,\n    },\n    emitter,\n  });\n\n  const onRouteFocus = useOnRouteFocus({\n    router,\n    key: route?.key,\n    getState,\n    setState,\n  });\n\n  const navigation = useNavigationHelpers<\n    State,\n    ActionHelpers,\n    NavigationAction,\n    EventMap\n  >({\n    id: options.id,\n    onAction,\n    getState,\n    emitter,\n    router,\n  });\n\n  useFocusedListenersChildrenAdapter({\n    navigation,\n    focusedListeners: childListeners.focus,\n  });\n\n  useOnGetState({\n    getState,\n    getStateListeners: keyedListeners.getState,\n  });\n\n  const descriptors = useDescriptors<\n    State,\n    ActionHelpers,\n    ScreenOptions,\n    EventMap\n  >({\n    state,\n    screens,\n    navigation,\n    screenOptions: options.screenOptions,\n    defaultScreenOptions: options.defaultScreenOptions,\n    onAction,\n    getState,\n    setState,\n    onRouteFocus,\n    addListener,\n    addKeyedListener,\n    router,\n    // @ts-expect-error: this should have both core and custom events, but too much work right now\n    emitter,\n  });\n\n  useCurrentRender({\n    state,\n    navigation,\n    descriptors,\n  });\n\n  const NavigationContent = useComponent((children: React.ReactNode) => (\n    <NavigationHelpersContext.Provider value={navigation}>\n      <PreventRemoveProvider>{children}</PreventRemoveProvider>\n    </NavigationHelpersContext.Provider>\n  ));\n\n  return {\n    state,\n    navigation,\n    descriptors,\n    NavigationContent,\n  };\n}\n","import {\n  CommonActions,\n  NavigationAction,\n  NavigationState,\n  ParamListBase,\n  Router,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport type { NavigationHelpers, NavigationProp } from './types';\nimport type { NavigationEventEmitter } from './useEventEmitter';\n\ntype Options<\n  State extends NavigationState,\n  EventMap extends Record<string, any>\n> = {\n  state: State;\n  getState: () => State;\n  navigation: NavigationHelpers<ParamListBase> &\n    Partial<NavigationProp<ParamListBase, string, any, any, any>>;\n  setOptions: (\n    cb: (options: Record<string, object>) => Record<string, object>\n  ) => void;\n  router: Router<State, NavigationAction>;\n  emitter: NavigationEventEmitter<EventMap>;\n};\n\ntype NavigationCache<\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends Record<string, any>\n> = Record<\n  string,\n  NavigationProp<\n    ParamListBase,\n    string,\n    string | undefined,\n    State,\n    ScreenOptions,\n    EventMap\n  >\n>;\n\n/**\n * Hook to cache navigation objects for each screen in the navigator.\n * It's important to cache them to make sure navigation objects don't change between renders.\n * This lets us apply optimizations like `React.memo` to minimize re-rendering screens.\n */\nexport default function useNavigationCache<\n  State extends NavigationState,\n  ScreenOptions extends {},\n  EventMap extends Record<string, any>\n>({\n  state,\n  getState,\n  navigation,\n  setOptions,\n  router,\n  emitter,\n}: Options<State, EventMap>) {\n  const { stackRef } = React.useContext(NavigationBuilderContext);\n\n  // Cache object which holds navigation objects for each screen\n  // We use `React.useMemo` instead of `React.useRef` coz we want to invalidate it when deps change\n  // In reality, these deps will rarely change, if ever\n  const cache = React.useMemo(\n    () => ({ current: {} as NavigationCache<State, ScreenOptions, EventMap> }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [getState, navigation, setOptions, router, emitter]\n  );\n\n  const actions = {\n    ...router.actionCreators,\n    ...CommonActions,\n  };\n\n  cache.current = state.routes.reduce<\n    NavigationCache<State, ScreenOptions, EventMap>\n  >((acc, route) => {\n    const previous = cache.current[route.key];\n\n    type Thunk =\n      | NavigationAction\n      | ((state: State) => NavigationAction | null | undefined);\n\n    if (previous) {\n      // If a cached navigation object already exists, reuse it\n      acc[route.key] = previous;\n    } else {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { emit, ...rest } = navigation;\n\n      const dispatch = (thunk: Thunk) => {\n        const action = typeof thunk === 'function' ? thunk(getState()) : thunk;\n\n        if (action != null) {\n          navigation.dispatch({ source: route.key, ...action });\n        }\n      };\n\n      const withStack = (callback: () => void) => {\n        let isStackSet = false;\n\n        try {\n          if (\n            process.env.NODE_ENV !== 'production' &&\n            stackRef &&\n            !stackRef.current\n          ) {\n            // Capture the stack trace for devtools\n            stackRef.current = new Error().stack;\n            isStackSet = true;\n          }\n\n          callback();\n        } finally {\n          if (isStackSet && stackRef) {\n            stackRef.current = undefined;\n          }\n        }\n      };\n\n      const helpers = Object.keys(actions).reduce<Record<string, () => void>>(\n        (acc, name) => {\n          acc[name] = (...args: any) =>\n            withStack(() =>\n              // @ts-expect-error: name is a valid key, but TypeScript is dumb\n              dispatch(actions[name](...args))\n            );\n\n          return acc;\n        },\n        {}\n      );\n\n      acc[route.key] = {\n        ...rest,\n        ...helpers,\n        // FIXME: too much work to fix the types for now\n        ...(emitter.create(route.key) as any),\n        dispatch: (thunk: Thunk) => withStack(() => dispatch(thunk)),\n        getParent: (id?: string) => {\n          if (id !== undefined && id === rest.getId()) {\n            // If the passed id is the same as the current navigation id,\n            // we return the cached navigation object for the relevant route\n            return acc[route.key];\n          }\n\n          return rest.getParent(id);\n        },\n        setOptions: (options: object) =>\n          setOptions((o) => ({\n            ...o,\n            [route.key]: { ...o[route.key], ...options },\n          })),\n        isFocused: () => {\n          const state = getState();\n\n          if (state.routes[state.index].key !== route.key) {\n            return false;\n          }\n\n          // If the current screen is focused, we also need to check if parent navigator is focused\n          // This makes sure that we return the focus state in the whole tree, not just this navigator\n          return navigation ? navigation.isFocused() : true;\n        },\n      };\n    }\n\n    return acc;\n  }, {});\n\n  return cache.current;\n}\n","import * as React from 'react';\n\nimport createNavigationContainerRef from './createNavigationContainerRef';\nimport type { NavigationContainerRefWithCurrent } from './types';\n\nexport default function useNavigationContainerRef<\n  ParamList extends {} = ReactNavigation.RootParamList\n>(): NavigationContainerRefWithCurrent<ParamList> {\n  const navigation =\n    React.useRef<NavigationContainerRefWithCurrent<ParamList> | null>(null);\n\n  if (navigation.current == null) {\n    navigation.current = createNavigationContainerRef<ParamList>();\n  }\n\n  return navigation.current;\n}\n","import {\n  CommonActions,\n  NavigationAction,\n  NavigationState,\n  ParamListBase,\n  Router,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationContext from './NavigationContext';\nimport { NavigationHelpers, PrivateValueStore } from './types';\nimport UnhandledActionContext from './UnhandledActionContext';\nimport type { NavigationEventEmitter } from './useEventEmitter';\n\n// This is to make TypeScript compiler happy\n// eslint-disable-next-line babel/no-unused-expressions\nPrivateValueStore;\n\ntype Options<State extends NavigationState, Action extends NavigationAction> = {\n  id: string | undefined;\n  onAction: (action: NavigationAction) => boolean;\n  getState: () => State;\n  emitter: NavigationEventEmitter<any>;\n  router: Router<State, Action>;\n};\n\n/**\n * Navigation object with helper methods to be used by a navigator.\n * This object includes methods for common actions as well as methods the parent screen's navigation object.\n */\nexport default function useNavigationHelpers<\n  State extends NavigationState,\n  ActionHelpers extends Record<string, () => void>,\n  Action extends NavigationAction,\n  EventMap extends Record<string, any>\n>({\n  id: navigatorId,\n  onAction,\n  getState,\n  emitter,\n  router,\n}: Options<State, Action>) {\n  const onUnhandledAction = React.useContext(UnhandledActionContext);\n  const parentNavigationHelpers = React.useContext(NavigationContext);\n\n  return React.useMemo(() => {\n    const dispatch = (op: Action | ((state: State) => Action)) => {\n      const action = typeof op === 'function' ? op(getState()) : op;\n\n      const handled = onAction(action);\n\n      if (!handled) {\n        onUnhandledAction?.(action);\n      }\n    };\n\n    const actions = {\n      ...router.actionCreators,\n      ...CommonActions,\n    };\n\n    const helpers = Object.keys(actions).reduce((acc, name) => {\n      // @ts-expect-error: name is a valid key, but TypeScript is dumb\n      acc[name] = (...args: any) => dispatch(actions[name](...args));\n      return acc;\n    }, {} as ActionHelpers);\n\n    const navigationHelpers = {\n      ...parentNavigationHelpers,\n      ...helpers,\n      dispatch,\n      emit: emitter.emit,\n      isFocused: parentNavigationHelpers\n        ? parentNavigationHelpers.isFocused\n        : () => true,\n      canGoBack: () => {\n        const state = getState();\n\n        return (\n          router.getStateForAction(state, CommonActions.goBack() as Action, {\n            routeNames: state.routeNames,\n            routeParamList: {},\n            routeGetIdList: {},\n          }) !== null ||\n          parentNavigationHelpers?.canGoBack() ||\n          false\n        );\n      },\n      getId: () => navigatorId,\n      getParent: (id?: string) => {\n        if (id !== undefined) {\n          let current = navigationHelpers;\n\n          while (current && id !== current.getId()) {\n            current = current.getParent();\n          }\n\n          return current;\n        }\n\n        return parentNavigationHelpers;\n      },\n      getState,\n    } as NavigationHelpers<ParamListBase, EventMap> & ActionHelpers;\n\n    return navigationHelpers;\n  }, [\n    navigatorId,\n    emitter.emit,\n    getState,\n    onAction,\n    onUnhandledAction,\n    parentNavigationHelpers,\n    router,\n  ]);\n}\n","import type { NavigationState, ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport type { NavigationProp } from './types';\nimport useNavigation from './useNavigation';\n\ntype Selector<ParamList extends ParamListBase, T> = (\n  state: NavigationState<ParamList>\n) => T;\n\n/**\n * Hook to get a value from the current navigation state using a selector.\n *\n * @param selector Selector function to get a value from the state.\n */\nexport default function useNavigationState<ParamList extends ParamListBase, T>(\n  selector: Selector<ParamList, T>\n): T {\n  const navigation = useNavigation<NavigationProp<ParamList>>();\n\n  // We don't care about the state value, we run the selector again at the end\n  // The state is only to make sure that there's a re-render when we have a new value\n  const [, setResult] = React.useState(() => selector(navigation.getState()));\n\n  // We store the selector in a ref to avoid re-subscribing listeners every render\n  const selectorRef = React.useRef(selector);\n\n  React.useEffect(() => {\n    selectorRef.current = selector;\n  });\n\n  React.useEffect(() => {\n    const unsubscribe = navigation.addListener('state', (e) => {\n      setResult(selectorRef.current(e.data.state));\n    });\n\n    return unsubscribe;\n  }, [navigation]);\n\n  return selector(navigation.getState());\n}\n","import type {\n  NavigationAction,\n  NavigationState,\n  PartialState,\n  Router,\n  RouterConfigOptions,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationBuilderContext, {\n  ChildActionListener,\n  ChildBeforeRemoveListener,\n} from './NavigationBuilderContext';\nimport type { EventMapCore } from './types';\nimport type { NavigationEventEmitter } from './useEventEmitter';\nimport useOnPreventRemove, { shouldPreventRemove } from './useOnPreventRemove';\n\ntype Options = {\n  router: Router<NavigationState, NavigationAction>;\n  key?: string;\n  getState: () => NavigationState;\n  setState: (state: NavigationState | PartialState<NavigationState>) => void;\n  actionListeners: ChildActionListener[];\n  beforeRemoveListeners: Record<string, ChildBeforeRemoveListener | undefined>;\n  routerConfigOptions: RouterConfigOptions;\n  emitter: NavigationEventEmitter<EventMapCore<any>>;\n};\n\n/**\n * Hook to handle actions for a navigator, including state updates and bubbling.\n *\n * Bubbling an action is achieved in 2 ways:\n * 1. To bubble action to parent, we expose the action handler in context and then access the parent context\n * 2. To bubble action to child, child adds event listeners subscribing to actions from parent\n *\n * When the action handler handles as action, it returns `true`, otherwise `false`.\n */\nexport default function useOnAction({\n  router,\n  getState,\n  setState,\n  key,\n  actionListeners,\n  beforeRemoveListeners,\n  routerConfigOptions,\n  emitter,\n}: Options) {\n  const {\n    onAction: onActionParent,\n    onRouteFocus: onRouteFocusParent,\n    addListener: addListenerParent,\n    onDispatchAction,\n  } = React.useContext(NavigationBuilderContext);\n\n  const routerConfigOptionsRef =\n    React.useRef<RouterConfigOptions>(routerConfigOptions);\n\n  React.useEffect(() => {\n    routerConfigOptionsRef.current = routerConfigOptions;\n  });\n\n  const onAction = React.useCallback(\n    (\n      action: NavigationAction,\n      visitedNavigators: Set<string> = new Set<string>()\n    ) => {\n      const state = getState();\n\n      // Since actions can bubble both up and down, they could come to the same navigator again\n      // We keep track of navigators which have already tried to handle the action and return if it's already visited\n      if (visitedNavigators.has(state.key)) {\n        return false;\n      }\n\n      visitedNavigators.add(state.key);\n\n      if (typeof action.target !== 'string' || action.target === state.key) {\n        let result = router.getStateForAction(\n          state,\n          action,\n          routerConfigOptionsRef.current\n        );\n\n        // If a target is specified and set to current navigator, the action shouldn't bubble\n        // So instead of `null`, we use the state object for such cases to signal that action was handled\n        result =\n          result === null && action.target === state.key ? state : result;\n\n        if (result !== null) {\n          onDispatchAction(action, state === result);\n\n          if (state !== result) {\n            const isPrevented = shouldPreventRemove(\n              emitter,\n              beforeRemoveListeners,\n              state.routes,\n              result.routes,\n              action\n            );\n\n            if (isPrevented) {\n              return true;\n            }\n\n            setState(result);\n          }\n\n          if (onRouteFocusParent !== undefined) {\n            // Some actions such as `NAVIGATE` also want to bring the navigated route to focus in the whole tree\n            // This means we need to focus all of the parent navigators of this navigator as well\n            const shouldFocus = router.shouldActionChangeFocus(action);\n\n            if (shouldFocus && key !== undefined) {\n              onRouteFocusParent(key);\n            }\n          }\n\n          return true;\n        }\n      }\n\n      if (onActionParent !== undefined) {\n        // Bubble action to the parent if the current navigator didn't handle it\n        if (onActionParent(action, visitedNavigators)) {\n          return true;\n        }\n      }\n\n      // If the action wasn't handled by current navigator or a parent navigator, let children handle it\n      for (let i = actionListeners.length - 1; i >= 0; i--) {\n        const listener = actionListeners[i];\n\n        if (listener(action, visitedNavigators)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    [\n      actionListeners,\n      beforeRemoveListeners,\n      emitter,\n      getState,\n      key,\n      onActionParent,\n      onDispatchAction,\n      onRouteFocusParent,\n      router,\n      setState,\n    ]\n  );\n\n  useOnPreventRemove({\n    getState,\n    emitter,\n    beforeRemoveListeners,\n  });\n\n  React.useEffect(\n    () => addListenerParent?.('action', onAction),\n    [addListenerParent, onAction]\n  );\n\n  return onAction;\n}\n","import type { NavigationState } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport isArrayEqual from './isArrayEqual';\nimport NavigationBuilderContext, {\n  GetStateListener,\n} from './NavigationBuilderContext';\nimport NavigationRouteContext from './NavigationRouteContext';\n\ntype Options = {\n  getState: () => NavigationState;\n  getStateListeners: Record<string, GetStateListener | undefined>;\n};\n\nexport default function useOnGetState({\n  getState,\n  getStateListeners,\n}: Options) {\n  const { addKeyedListener } = React.useContext(NavigationBuilderContext);\n  const route = React.useContext(NavigationRouteContext);\n  const key = route ? route.key : 'root';\n\n  const getRehydratedState = React.useCallback(() => {\n    const state = getState();\n\n    // Avoid returning new route objects if we don't need to\n    const routes = state.routes.map((route) => {\n      const childState = getStateListeners[route.key]?.();\n\n      if (route.state === childState) {\n        return route;\n      }\n\n      return { ...route, state: childState };\n    });\n\n    if (isArrayEqual(state.routes, routes)) {\n      return state;\n    }\n\n    return { ...state, routes };\n  }, [getState, getStateListeners]);\n\n  React.useEffect(() => {\n    return addKeyedListener?.('getState', key, getRehydratedState);\n  }, [addKeyedListener, getRehydratedState, key]);\n}\n","import type {\n  NavigationAction,\n  NavigationState,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationBuilderContext, {\n  ChildBeforeRemoveListener,\n} from './NavigationBuilderContext';\nimport NavigationRouteContext from './NavigationRouteContext';\nimport type { EventMapCore } from './types';\nimport type { NavigationEventEmitter } from './useEventEmitter';\n\ntype Options = {\n  getState: () => NavigationState;\n  emitter: NavigationEventEmitter<EventMapCore<any>>;\n  beforeRemoveListeners: Record<string, ChildBeforeRemoveListener | undefined>;\n};\n\nconst VISITED_ROUTE_KEYS = Symbol('VISITED_ROUTE_KEYS');\n\nexport const shouldPreventRemove = (\n  emitter: NavigationEventEmitter<EventMapCore<any>>,\n  beforeRemoveListeners: Record<string, ChildBeforeRemoveListener | undefined>,\n  currentRoutes: { key: string }[],\n  nextRoutes: { key?: string | undefined }[],\n  action: NavigationAction\n) => {\n  const nextRouteKeys = nextRoutes.map((route) => route.key);\n\n  // Call these in reverse order so last screens handle the event first\n  const removedRoutes = currentRoutes\n    .filter((route) => !nextRouteKeys.includes(route.key))\n    .reverse();\n\n  const visitedRouteKeys: Set<string> =\n    // @ts-expect-error: add this property to mark that we've already emitted this action\n    action[VISITED_ROUTE_KEYS] ?? new Set<string>();\n\n  const beforeRemoveAction = {\n    ...action,\n    [VISITED_ROUTE_KEYS]: visitedRouteKeys,\n  };\n\n  for (const route of removedRoutes) {\n    if (visitedRouteKeys.has(route.key)) {\n      // Skip if we've already emitted this action for this screen\n      continue;\n    }\n\n    // First, we need to check if any child screens want to prevent it\n    const isPrevented = beforeRemoveListeners[route.key]?.(beforeRemoveAction);\n\n    if (isPrevented) {\n      return true;\n    }\n\n    visitedRouteKeys.add(route.key);\n\n    const event = emitter.emit({\n      type: 'beforeRemove',\n      target: route.key,\n      data: { action: beforeRemoveAction },\n      canPreventDefault: true,\n    });\n\n    if (event.defaultPrevented) {\n      return true;\n    }\n  }\n\n  return false;\n};\n\nexport default function useOnPreventRemove({\n  getState,\n  emitter,\n  beforeRemoveListeners,\n}: Options) {\n  const { addKeyedListener } = React.useContext(NavigationBuilderContext);\n  const route = React.useContext(NavigationRouteContext);\n  const routeKey = route?.key;\n\n  React.useEffect(() => {\n    if (routeKey) {\n      return addKeyedListener?.('beforeRemove', routeKey, (action) => {\n        const state = getState();\n\n        return shouldPreventRemove(\n          emitter,\n          beforeRemoveListeners,\n          state.routes,\n          [],\n          action\n        );\n      });\n    }\n  }, [addKeyedListener, beforeRemoveListeners, emitter, getState, routeKey]);\n}\n","import type {\n  NavigationAction,\n  NavigationState,\n  Router,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationBuilderContext from './NavigationBuilderContext';\n\ntype Options<Action extends NavigationAction> = {\n  router: Router<NavigationState, Action>;\n  getState: () => NavigationState;\n  setState: (state: NavigationState) => void;\n  key?: string;\n};\n\n/**\n * Hook to handle focus actions for a route.\n * Focus action needs to be treated specially, coz when a nested route is focused,\n * the parent navigators also needs to be focused.\n */\nexport default function useOnRouteFocus<Action extends NavigationAction>({\n  router,\n  getState,\n  key: sourceRouteKey,\n  setState,\n}: Options<Action>) {\n  const { onRouteFocus: onRouteFocusParent } = React.useContext(\n    NavigationBuilderContext\n  );\n\n  return React.useCallback(\n    (key: string) => {\n      const state = getState();\n      const result = router.getStateForRouteFocus(state, key);\n\n      if (result !== state) {\n        setState(result);\n      }\n\n      if (onRouteFocusParent !== undefined && sourceRouteKey !== undefined) {\n        onRouteFocusParent(sourceRouteKey);\n      }\n    },\n    [getState, onRouteFocusParent, router, setState, sourceRouteKey]\n  );\n}\n","import type { ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationBuilderContext from './NavigationBuilderContext';\nimport NavigationStateContext from './NavigationStateContext';\nimport type { NavigationProp } from './types';\n\ntype Options = {\n  key?: string;\n  navigation?: NavigationProp<ParamListBase>;\n  options?: object | undefined;\n};\n\nexport default function useOptionsGetters({\n  key,\n  options,\n  navigation,\n}: Options) {\n  const optionsRef = React.useRef<object | undefined>(options);\n  const optionsGettersFromChildRef = React.useRef<\n    Record<string, () => object | undefined | null>\n  >({});\n\n  const { onOptionsChange } = React.useContext(NavigationBuilderContext);\n  const { addOptionsGetter: parentAddOptionsGetter } = React.useContext(\n    NavigationStateContext\n  );\n\n  const optionsChangeListener = React.useCallback(() => {\n    const isFocused = navigation?.isFocused() ?? true;\n    const hasChildren = Object.keys(optionsGettersFromChildRef.current).length;\n\n    if (isFocused && !hasChildren) {\n      onOptionsChange(optionsRef.current ?? {});\n    }\n  }, [navigation, onOptionsChange]);\n\n  React.useEffect(() => {\n    optionsRef.current = options;\n    optionsChangeListener();\n\n    return navigation?.addListener('focus', optionsChangeListener);\n  }, [navigation, options, optionsChangeListener]);\n\n  const getOptionsFromListener = React.useCallback(() => {\n    for (let key in optionsGettersFromChildRef.current) {\n      if (optionsGettersFromChildRef.current.hasOwnProperty(key)) {\n        const result = optionsGettersFromChildRef.current[key]?.();\n\n        // null means unfocused route\n        if (result !== null) {\n          return result;\n        }\n      }\n    }\n\n    return null;\n  }, []);\n\n  const getCurrentOptions = React.useCallback(() => {\n    const isFocused = navigation?.isFocused() ?? true;\n\n    if (!isFocused) {\n      return null;\n    }\n\n    const optionsFromListener = getOptionsFromListener();\n\n    if (optionsFromListener !== null) {\n      return optionsFromListener;\n    }\n\n    return optionsRef.current;\n  }, [navigation, getOptionsFromListener]);\n\n  React.useEffect(() => {\n    return parentAddOptionsGetter?.(key!, getCurrentOptions);\n  }, [getCurrentOptions, parentAddOptionsGetter, key]);\n\n  const addOptionsGetter = React.useCallback(\n    (key: string, getter: () => object | undefined | null) => {\n      optionsGettersFromChildRef.current[key] = getter;\n      optionsChangeListener();\n\n      return () => {\n        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n        delete optionsGettersFromChildRef.current[key];\n        optionsChangeListener();\n      };\n    },\n    [optionsChangeListener]\n  );\n\n  return {\n    addOptionsGetter,\n    getCurrentOptions,\n  };\n}\n","import type { NavigationAction } from '@react-navigation/routers';\nimport { nanoid } from 'nanoid/non-secure';\nimport * as React from 'react';\nimport useLatestCallback from 'use-latest-callback';\n\nimport type { EventListenerCallback, EventMapCore } from './types';\nimport useNavigation from './useNavigation';\nimport usePreventRemoveContext from './usePreventRemoveContext';\nimport useRoute from './useRoute';\n\n/**\n * Hook to prevent screen from being removed. Can be used to prevent users from leaving the screen.\n *\n * @param preventRemove Boolean indicating whether to prevent screen from being removed.\n * @param callback Function which is executed when screen was prevented from being removed.\n */\nexport default function usePreventRemove(\n  preventRemove: boolean,\n  callback: (options: { data: { action: NavigationAction } }) => void\n) {\n  const [id] = React.useState(() => nanoid());\n\n  const navigation = useNavigation();\n  const { key: routeKey } = useRoute();\n\n  const { setPreventRemove } = usePreventRemoveContext();\n\n  React.useEffect(() => {\n    setPreventRemove(id, routeKey, preventRemove);\n    return () => {\n      setPreventRemove(id, routeKey, false);\n    };\n  }, [setPreventRemove, id, routeKey, preventRemove]);\n\n  const beforeRemoveListener = useLatestCallback<\n    EventListenerCallback<EventMapCore<any>, 'beforeRemove'>\n  >((e) => {\n    if (!preventRemove) {\n      return;\n    }\n\n    e.preventDefault();\n\n    callback({ data: e.data });\n  });\n\n  React.useEffect(\n    () => navigation?.addListener('beforeRemove', beforeRemoveListener),\n    [navigation, beforeRemoveListener]\n  );\n}\n","import * as React from 'react';\n\nimport PreventRemoveContext from './PreventRemoveContext';\n\nexport default function usePreventRemoveContext() {\n  const value = React.useContext(PreventRemoveContext);\n\n  if (value == null) {\n    throw new Error(\n      \"Couldn't find the prevent remove context. Is your component inside NavigationContent?\"\n    );\n  }\n\n  return value;\n}\n","import { nanoid } from 'nanoid/non-secure';\nimport * as React from 'react';\n\nimport { SingleNavigatorContext } from './EnsureSingleNavigator';\n\n/**\n * Register a navigator in the parent context (either a navigation container or a screen).\n * This is used to prevent multiple navigators under a single container or screen.\n */\nexport default function useRegisterNavigator() {\n  const [key] = React.useState(() => nanoid());\n  const container = React.useContext(SingleNavigatorContext);\n\n  if (container === undefined) {\n    throw new Error(\n      \"Couldn't register the navigator. Have you wrapped your app with 'NavigationContainer'?\\n\\nThis can also happen if there are multiple copies of '@react-navigation' packages installed.\"\n    );\n  }\n\n  React.useEffect(() => {\n    const { register, unregister } = container;\n\n    register(key);\n\n    return () => unregister(key);\n  }, [container, key]);\n\n  return key;\n}\n","import type { ParamListBase } from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport NavigationRouteContext from './NavigationRouteContext';\nimport type { RouteProp } from './types';\n\n/**\n * Hook to access the route prop of the parent screen anywhere.\n *\n * @returns Route prop of the parent screen.\n */\nexport default function useRoute<T extends RouteProp<ParamListBase>>(): T {\n  const route = React.useContext(NavigationRouteContext);\n\n  if (route === undefined) {\n    throw new Error(\n      \"Couldn't find a route object. Is your component inside a screen in a navigator?\"\n    );\n  }\n\n  return route as T;\n}\n","import type {\n  NavigationState,\n  ParamListBase,\n  Route,\n} from '@react-navigation/routers';\nimport * as React from 'react';\n\nimport type { RouteProp } from './types';\n\ntype RouteCache = Map<Route<string>, RouteProp<ParamListBase>>;\n\n/**\n * Utilites such as `getFocusedRouteNameFromRoute` need to access state.\n * So we need a way to suppress the warning for those use cases.\n * This is fine since they are internal utilities and this is not public API.\n */\nexport const CHILD_STATE = Symbol('CHILD_STATE');\n\n/**\n * Hook to cache route props for each screen in the navigator.\n * This lets add warnings and modifications to the route object but keep references between renders.\n */\nexport default function useRouteCache<State extends NavigationState>(\n  routes: State['routes']\n) {\n  // Cache object which holds route objects for each screen\n  const cache = React.useMemo(() => ({ current: new Map() as RouteCache }), []);\n\n  if (process.env.NODE_ENV === 'production') {\n    // We don't want the overhead of creating extra maps every render in prod\n    return routes;\n  }\n\n  cache.current = routes.reduce((acc, route) => {\n    const previous = cache.current.get(route);\n\n    if (previous) {\n      // If a cached route object already exists, reuse it\n      acc.set(route, previous);\n    } else {\n      const { state, ...proxy } = route;\n\n      Object.defineProperty(proxy, CHILD_STATE, {\n        enumerable: false,\n        value: state,\n      });\n\n      acc.set(route, proxy);\n    }\n\n    return acc;\n  }, new Map() as RouteCache);\n\n  return Array.from(cache.current.values());\n}\n","import * as React from 'react';\n\nconst MISSING_CONTEXT_ERROR = \"Couldn't find a schedule context.\";\n\nexport const ScheduleUpdateContext = React.createContext<{\n  scheduleUpdate: (callback: () => void) => void;\n  flushUpdates: () => void;\n}>({\n  scheduleUpdate() {\n    throw new Error(MISSING_CONTEXT_ERROR);\n  },\n  flushUpdates() {\n    throw new Error(MISSING_CONTEXT_ERROR);\n  },\n});\n\n/**\n * When screen config changes, we want to update the navigator in the same update phase.\n * However, navigation state is in the root component and React won't let us update it from a child.\n * This is a workaround for that, the scheduled update is stored in the ref without actually calling setState.\n * It lets all subsequent updates access the latest state so it stays correct.\n * Then we call setState during after the component updates.\n */\nexport default function useScheduleUpdate(callback: () => void) {\n  const { scheduleUpdate, flushUpdates } = React.useContext(\n    ScheduleUpdateContext\n  );\n\n  scheduleUpdate(callback);\n\n  React.useEffect(flushUpdates);\n}\n","import * as React from 'react';\n\nconst UNINTIALIZED_STATE = {};\n\n/**\n * This is definitely not compatible with concurrent mode, but we don't have a solution for sync state yet.\n */\nexport default function useSyncState<T>(initialState?: (() => T) | T) {\n  const stateRef = React.useRef<T>(UNINTIALIZED_STATE as any);\n  const isSchedulingRef = React.useRef(false);\n  const isMountedRef = React.useRef(true);\n\n  React.useEffect(() => {\n    isMountedRef.current = true;\n\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n\n  if (stateRef.current === UNINTIALIZED_STATE) {\n    stateRef.current =\n      // @ts-expect-error: initialState is a function, but TypeScript doesn't think so\n      typeof initialState === 'function' ? initialState() : initialState;\n  }\n\n  const [trackingState, setTrackingState] = React.useState(stateRef.current);\n\n  const getState = React.useCallback(() => stateRef.current, []);\n\n  const setState = React.useCallback((state: T) => {\n    if (state === stateRef.current || !isMountedRef.current) {\n      return;\n    }\n\n    stateRef.current = state;\n\n    if (!isSchedulingRef.current) {\n      setTrackingState(state);\n    }\n  }, []);\n\n  const scheduleUpdate = React.useCallback((callback: () => void) => {\n    isSchedulingRef.current = true;\n\n    try {\n      callback();\n    } finally {\n      isSchedulingRef.current = false;\n    }\n  }, []);\n\n  const flushUpdates = React.useCallback(() => {\n    if (!isMountedRef.current) {\n      return;\n    }\n\n    // Make sure that the tracking state is up-to-date.\n    // We call it unconditionally, but React should skip the update if state is unchanged.\n    setTrackingState(stateRef.current);\n  }, []);\n\n  // If we're rendering and the tracking state is out of date, update it immediately\n  // This will make sure that our updates are applied as early as possible.\n  if (trackingState !== stateRef.current) {\n    setTrackingState(stateRef.current);\n  }\n\n  const state = stateRef.current;\n\n  React.useDebugValue(state);\n\n  return [state, getState, setState, scheduleUpdate, flushUpdates] as const;\n}\n","const formatToList = (items: string[]) =>\n  items.map((key) => `- ${key}`).join('\\n');\n\nexport default function validatePathConfig(config: any, root = true) {\n  const validKeys = ['initialRouteName', 'screens'];\n\n  if (!root) {\n    validKeys.push('path', 'exact', 'stringify', 'parse');\n  }\n\n  const invalidKeys = Object.keys(config).filter(\n    (key) => !validKeys.includes(key)\n  );\n\n  if (invalidKeys.length) {\n    throw new Error(\n      `Found invalid properties in the configuration:\\n${formatToList(\n        invalidKeys\n      )}\\n\\nDid you forget to specify them under a 'screens' property?\\n\\nYou can only specify the following properties:\\n${formatToList(\n        validKeys\n      )}\\n\\nSee https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.`\n    );\n  }\n\n  if (config.screens) {\n    Object.entries(config.screens).forEach(([_, value]) => {\n      if (typeof value !== 'string') {\n        validatePathConfig(value, false);\n      }\n    });\n  }\n}\n","import type { NavigationAction } from '@react-navigation/core';\nimport * as React from 'react';\nimport { GestureResponderEvent, Platform, Text, TextProps } from 'react-native';\n\nimport useLinkProps from './useLinkProps';\nimport type { To } from './useLinkTo';\n\ntype Props<ParamList extends ReactNavigation.RootParamList> = {\n  to: To<ParamList>;\n  action?: NavigationAction;\n  target?: string;\n  onPress?: (\n    e: React.MouseEvent<HTMLAnchorElement, MouseEvent> | GestureResponderEvent\n  ) => void;\n} & (Omit<TextProps, 'disabled'> & {\n  disabled?: boolean | null;\n  children: React.ReactNode;\n});\n\n/**\n * Component to render link to another screen using a path.\n * Uses an anchor tag on the web.\n *\n * @param props.to Absolute path to screen (e.g. `/feeds/hot`).\n * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.\n * @param props.children Child elements to render the content.\n */\nexport default function Link<ParamList extends ReactNavigation.RootParamList>({\n  to,\n  action,\n  ...rest\n}: Props<ParamList>) {\n  const props = useLinkProps<ParamList>({ to, action });\n\n  const onPress = (\n    e: React.MouseEvent<HTMLAnchorElement, MouseEvent> | GestureResponderEvent\n  ) => {\n    if ('onPress' in rest) {\n      rest.onPress?.(e);\n    }\n\n    props.onPress(e);\n  };\n\n  return React.createElement(Text, {\n    ...props,\n    ...rest,\n    ...Platform.select({\n      web: { onClick: onPress } as any,\n      default: { onPress },\n    }),\n  });\n}\n","import type { ParamListBase } from '@react-navigation/core';\nimport * as React from 'react';\n\nimport type { LinkingOptions } from './types';\n\nconst LinkingContext = React.createContext<{\n  options: LinkingOptions<ParamListBase> | undefined;\n}>({ options: undefined });\n\nLinkingContext.displayName = 'LinkingContext';\n\nexport default LinkingContext;\n","import {\n  BaseNavigationContainer,\n  getActionFromState,\n  getPathFromState,\n  getStateFromPath,\n  NavigationContainerProps,\n  NavigationContainerRef,\n  ParamListBase,\n  validatePathConfig,\n} from '@react-navigation/core';\nimport * as React from 'react';\n\nimport LinkingContext from './LinkingContext';\nimport DefaultTheme from './theming/DefaultTheme';\nimport ThemeProvider from './theming/ThemeProvider';\nimport type { DocumentTitleOptions, LinkingOptions, Theme } from './types';\nimport useBackButton from './useBackButton';\nimport useDocumentTitle from './useDocumentTitle';\nimport useLinking from './useLinking';\nimport useThenable from './useThenable';\n\ndeclare global {\n  var REACT_NAVIGATION_DEVTOOLS: WeakMap<\n    NavigationContainerRef<any>,\n    { readonly linking: LinkingOptions<any> }\n  >;\n}\n\nglobal.REACT_NAVIGATION_DEVTOOLS = new WeakMap();\n\ntype Props<ParamList extends {}> = NavigationContainerProps & {\n  theme?: Theme;\n  linking?: LinkingOptions<ParamList>;\n  fallback?: React.ReactNode;\n  documentTitle?: DocumentTitleOptions;\n  onReady?: () => void;\n};\n\n/**\n * Container component which holds the navigation state designed for React Native apps.\n * This should be rendered at the root wrapping the whole app.\n *\n * @param props.initialState Initial state object for the navigation tree. When deep link handling is enabled, this will override deep links when specified. Make sure that you don't specify an `initialState` when there's a deep link (`Linking.getInitialURL()`).\n * @param props.onReady Callback which is called after the navigation tree mounts.\n * @param props.onStateChange Callback which is called with the latest navigation state when it changes.\n * @param props.theme Theme object for the navigators.\n * @param props.linking Options for deep linking. Deep link handling is enabled when this prop is provided, unless `linking.enabled` is `false`.\n * @param props.fallback Fallback component to render until we have finished getting initial state when linking is enabled. Defaults to `null`.\n * @param props.documentTitle Options to configure the document title on Web. Updating document title is handled by default unless `documentTitle.enabled` is `false`.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which refers to the navigation object containing helper methods.\n */\nfunction NavigationContainerInner(\n  {\n    theme = DefaultTheme,\n    linking,\n    fallback = null,\n    documentTitle,\n    onReady,\n    ...rest\n  }: Props<ParamListBase>,\n  ref?: React.Ref<NavigationContainerRef<ParamListBase> | null>\n) {\n  const isLinkingEnabled = linking ? linking.enabled !== false : false;\n\n  if (linking?.config) {\n    validatePathConfig(linking.config);\n  }\n\n  const refContainer =\n    React.useRef<NavigationContainerRef<ParamListBase>>(null);\n\n  useBackButton(refContainer);\n  useDocumentTitle(refContainer, documentTitle);\n\n  const { getInitialState } = useLinking(refContainer, {\n    independent: rest.independent,\n    enabled: isLinkingEnabled,\n    prefixes: [],\n    ...linking,\n  });\n\n  // Add additional linking related info to the ref\n  // This will be used by the devtools\n  React.useEffect(() => {\n    if (refContainer.current) {\n      REACT_NAVIGATION_DEVTOOLS.set(refContainer.current, {\n        get linking() {\n          return {\n            ...linking,\n            enabled: isLinkingEnabled,\n            prefixes: linking?.prefixes ?? [],\n            getStateFromPath: linking?.getStateFromPath ?? getStateFromPath,\n            getPathFromState: linking?.getPathFromState ?? getPathFromState,\n            getActionFromState:\n              linking?.getActionFromState ?? getActionFromState,\n          };\n        },\n      });\n    }\n  });\n\n  const [isResolved, initialState] = useThenable(getInitialState);\n\n  React.useImperativeHandle(ref, () => refContainer.current);\n\n  const linkingContext = React.useMemo(() => ({ options: linking }), [linking]);\n\n  const isReady = rest.initialState != null || !isLinkingEnabled || isResolved;\n\n  const onReadyRef = React.useRef(onReady);\n\n  React.useEffect(() => {\n    onReadyRef.current = onReady;\n  });\n\n  React.useEffect(() => {\n    if (isReady) {\n      onReadyRef.current?.();\n    }\n  }, [isReady]);\n\n  if (!isReady) {\n    // This is temporary until we have Suspense for data-fetching\n    // Then the fallback will be handled by a parent `Suspense` component\n    return fallback as React.ReactElement;\n  }\n\n  return (\n    <LinkingContext.Provider value={linkingContext}>\n      <ThemeProvider value={theme}>\n        <BaseNavigationContainer\n          {...rest}\n          initialState={\n            rest.initialState == null ? initialState : rest.initialState\n          }\n          ref={refContainer}\n        />\n      </ThemeProvider>\n    </LinkingContext.Provider>\n  );\n}\n\nconst NavigationContainer = React.forwardRef(NavigationContainerInner) as <\n  RootParamList extends {} = ReactNavigation.RootParamList\n>(\n  props: Props<RootParamList> & {\n    ref?: React.Ref<NavigationContainerRef<RootParamList>>;\n  }\n) => React.ReactElement;\n\nexport default NavigationContainer;\n","import { CurrentRenderContext } from '@react-navigation/core';\nimport * as React from 'react';\n\nimport ServerContext, { ServerContextType } from './ServerContext';\nimport type { ServerContainerRef } from './types';\n\ntype Props = ServerContextType & {\n  children: React.ReactNode;\n};\n\n/**\n * Container component for server rendering.\n *\n * @param props.location Location object to base the initial URL for SSR.\n * @param props.children Child elements to render the content.\n * @param props.ref Ref object which contains helper methods.\n */\nexport default React.forwardRef(function ServerContainer(\n  { children, location }: Props,\n  ref: React.Ref<ServerContainerRef>\n) {\n  React.useEffect(() => {\n    console.error(\n      \"'ServerContainer' should only be used on the server with 'react-dom/server' for SSR.\"\n    );\n  }, []);\n\n  const current: { options?: object } = {};\n\n  if (ref) {\n    const value = {\n      getCurrentOptions() {\n        return current.options;\n      },\n    };\n\n    // We write to the `ref` during render instead of `React.useImperativeHandle`\n    // This is because `useImperativeHandle` will update the ref after 'commit',\n    // and there's no 'commit' phase during SSR.\n    // Mutating ref during render is unsafe in concurrent mode, but we don't care about it for SSR.\n    if (typeof ref === 'function') {\n      ref(value);\n    } else {\n      // @ts-expect-error: the TS types are incorrect and say that ref.current is readonly\n      ref.current = value;\n    }\n  }\n\n  return (\n    <ServerContext.Provider value={{ location }}>\n      <CurrentRenderContext.Provider value={current}>\n        {children}\n      </CurrentRenderContext.Provider>\n    </ServerContext.Provider>\n  );\n});\n","import * as React from 'react';\n\nexport type ServerContextType = {\n  location?: {\n    pathname: string;\n    search: string;\n  };\n};\n\nconst ServerContext = React.createContext<ServerContextType | undefined>(\n  undefined\n);\n\nexport default ServerContext;\n","import escapeStringRegexp from 'escape-string-regexp';\n\nexport default function extractPathFromURL(prefixes: string[], url: string) {\n  for (const prefix of prefixes) {\n    const protocol = prefix.match(/^[^:]+:/)?.[0] ?? '';\n    const host = prefix\n      .replace(new RegExp(`^${escapeStringRegexp(protocol)}`), '')\n      .replace(/\\/+/g, '/') // Replace multiple slash (//) with single ones\n      .replace(/^\\//, ''); // Remove extra leading slash\n\n    const prefixRegex = new RegExp(\n      `^${escapeStringRegexp(protocol)}(/)*${host\n        .split('.')\n        .map((it) => (it === '*' ? '[^/]+' : escapeStringRegexp(it)))\n        .join('\\\\.')}`\n    );\n\n    const [originAndPath, searchParams] = url.split('?');\n    const normalizedURL = originAndPath\n      .replace(/\\/+/g, '/')\n      .concat(searchParams ? `?${searchParams}` : '');\n\n    if (prefixRegex.test(normalizedURL)) {\n      return normalizedURL.replace(prefixRegex, '');\n    }\n  }\n\n  return undefined;\n}\n","export { default as Link } from './Link';\nexport { default as LinkingContext } from './LinkingContext';\nexport { default as NavigationContainer } from './NavigationContainer';\nexport { default as ServerContainer } from './ServerContainer';\nexport { default as DarkTheme } from './theming/DarkTheme';\nexport { default as DefaultTheme } from './theming/DefaultTheme';\nexport { default as ThemeProvider } from './theming/ThemeProvider';\nexport { default as useTheme } from './theming/useTheme';\nexport * from './types';\nexport { default as useLinkBuilder } from './useLinkBuilder';\nexport { default as useLinkProps } from './useLinkProps';\nexport { default as useLinkTo } from './useLinkTo';\nexport { default as useScrollToTop } from './useScrollToTop';\nexport * from '@react-navigation/core';\n","import type { Theme } from '../types';\n\nconst DarkTheme: Theme = {\n  dark: true,\n  colors: {\n    primary: 'rgb(10, 132, 255)',\n    background: 'rgb(1, 1, 1)',\n    card: 'rgb(18, 18, 18)',\n    text: 'rgb(229, 229, 231)',\n    border: 'rgb(39, 39, 41)',\n    notification: 'rgb(255, 69, 58)',\n  },\n};\n\nexport default DarkTheme;\n","import type { Theme } from '../types';\n\nconst DefaultTheme: Theme = {\n  dark: false,\n  colors: {\n    primary: 'rgb(0, 122, 255)',\n    background: 'rgb(242, 242, 242)',\n    card: 'rgb(255, 255, 255)',\n    text: 'rgb(28, 28, 30)',\n    border: 'rgb(216, 216, 216)',\n    notification: 'rgb(255, 59, 48)',\n  },\n};\n\nexport default DefaultTheme;\n","import * as React from 'react';\n\nimport type { Theme } from '../types';\nimport DefaultTheme from './DefaultTheme';\n\nconst ThemeContext = React.createContext<Theme>(DefaultTheme);\n\nThemeContext.displayName = 'ThemeContext';\n\nexport default ThemeContext;\n","import * as React from 'react';\n\nimport type { Theme } from '../types';\nimport ThemeContext from './ThemeContext';\n\ntype Props = {\n  value: Theme;\n  children: React.ReactNode;\n};\n\nexport default function ThemeProvider({ value, children }: Props) {\n  return (\n    <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>\n  );\n}\n","import * as React from 'react';\n\nimport ThemeContext from './ThemeContext';\n\nexport default function useTheme() {\n  const theme = React.useContext(ThemeContext);\n\n  return theme;\n}\n","import type {\n  NavigationContainerRef,\n  ParamListBase,\n} from '@react-navigation/core';\nimport * as React from 'react';\nimport { BackHandler } from 'react-native';\n\nexport default function useBackButton(\n  ref: React.RefObject<NavigationContainerRef<ParamListBase>>\n) {\n  React.useEffect(() => {\n    const subscription = BackHandler.addEventListener(\n      'hardwareBackPress',\n      () => {\n        const navigation = ref.current;\n\n        if (navigation == null) {\n          return false;\n        }\n\n        if (navigation.canGoBack()) {\n          navigation.goBack();\n\n          return true;\n        }\n\n        return false;\n      }\n    );\n\n    return () => subscription.remove();\n  }, [ref]);\n}\n","export default function useDocumentTitle() {\n  // Noop for React Native\n}\n","import {\n  getPathFromState,\n  NavigationHelpers,\n  NavigationHelpersContext,\n  NavigationProp,\n  ParamListBase,\n} from '@react-navigation/core';\nimport * as React from 'react';\n\nimport LinkingContext from './LinkingContext';\n\ntype NavigationObject =\n  | NavigationHelpers<ParamListBase>\n  | NavigationProp<ParamListBase>;\n\ntype MinimalState = {\n  index: number;\n  routes: { name: string; params?: object; state?: MinimalState }[];\n};\n\nconst getRootStateForNavigate = (\n  navigation: NavigationObject,\n  state: MinimalState\n): MinimalState => {\n  const parent = navigation.getParent();\n\n  if (parent) {\n    const parentState = parent.getState();\n\n    return getRootStateForNavigate(parent, {\n      index: 0,\n      routes: [\n        {\n          ...parentState.routes[parentState.index],\n          state: state,\n        },\n      ],\n    });\n  }\n\n  return state;\n};\n\n/**\n * Build destination link for a navigate action.\n * Useful for showing anchor tags on the web for buttons that perform navigation.\n */\nexport default function useLinkBuilder() {\n  const navigation = React.useContext(NavigationHelpersContext);\n  const linking = React.useContext(LinkingContext);\n\n  const buildLink = React.useCallback(\n    (name: string, params?: object) => {\n      const { options } = linking;\n\n      if (options?.enabled === false) {\n        return undefined;\n      }\n\n      const state = navigation\n        ? getRootStateForNavigate(navigation, {\n            index: 0,\n            routes: [{ name, params }],\n          })\n        : // If we couldn't find a navigation object in context, we're at root\n          // So we'll construct a basic state object to use\n          {\n            index: 0,\n            routes: [{ name, params }],\n          };\n\n      const path = options?.getPathFromState\n        ? options.getPathFromState(state, options?.config)\n        : getPathFromState(state, options?.config);\n\n      return path;\n    },\n    [linking, navigation]\n  );\n\n  return buildLink;\n}\n","import {\n  getPathFromState,\n  NavigationAction,\n  NavigationContainerRefContext,\n  NavigationHelpersContext,\n  NavigatorScreenParams,\n  ParamListBase,\n} from '@react-navigation/core';\nimport type { NavigationState, PartialState } from '@react-navigation/routers';\nimport * as React from 'react';\nimport { GestureResponderEvent, Platform } from 'react-native';\n\nimport LinkingContext from './LinkingContext';\nimport useLinkTo, { To } from './useLinkTo';\n\ntype Props<ParamList extends ReactNavigation.RootParamList> = {\n  to: To<ParamList>;\n  action?: NavigationAction;\n};\n\nconst getStateFromParams = (\n  params: NavigatorScreenParams<ParamListBase, NavigationState> | undefined\n): PartialState<NavigationState> | NavigationState | undefined => {\n  if (params?.state) {\n    return params.state;\n  }\n\n  if (params?.screen) {\n    return {\n      routes: [\n        {\n          name: params.screen,\n          params: params.params,\n          // @ts-expect-error\n          state: params.screen\n            ? getStateFromParams(\n                params.params as\n                  | NavigatorScreenParams<ParamListBase, NavigationState>\n                  | undefined\n              )\n            : undefined,\n        },\n      ],\n    };\n  }\n\n  return undefined;\n};\n\n/**\n * Hook to get props for an anchor tag so it can work with in page navigation.\n *\n * @param props.to Absolute path to screen (e.g. `/feeds/hot`).\n * @param props.action Optional action to use for in-page navigation. By default, the path is parsed to an action based on linking config.\n */\nexport default function useLinkProps<\n  ParamList extends ReactNavigation.RootParamList\n>({ to, action }: Props<ParamList>) {\n  const root = React.useContext(NavigationContainerRefContext);\n  const navigation = React.useContext(NavigationHelpersContext);\n  const { options } = React.useContext(LinkingContext);\n  const linkTo = useLinkTo<ParamList>();\n\n  const onPress = (\n    e?: React.MouseEvent<HTMLAnchorElement, MouseEvent> | GestureResponderEvent\n  ) => {\n    let shouldHandle = false;\n\n    if (Platform.OS !== 'web' || !e) {\n      shouldHandle = e ? !e.defaultPrevented : true;\n    } else if (\n      !e.defaultPrevented && // onPress prevented default\n      // @ts-expect-error: these properties exist on web, but not in React Native\n      !(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) && // ignore clicks with modifier keys\n      // @ts-expect-error: these properties exist on web, but not in React Native\n      (e.button == null || e.button === 0) && // ignore everything but left clicks\n      // @ts-expect-error: these properties exist on web, but not in React Native\n      [undefined, null, '', 'self'].includes(e.currentTarget?.target) // let browser handle \"target=_blank\" etc.\n    ) {\n      e.preventDefault();\n      shouldHandle = true;\n    }\n\n    if (shouldHandle) {\n      if (action) {\n        if (navigation) {\n          navigation.dispatch(action);\n        } else if (root) {\n          root.dispatch(action);\n        } else {\n          throw new Error(\n            \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n          );\n        }\n      } else {\n        linkTo(to);\n      }\n    }\n  };\n\n  const getPathFromStateHelper = options?.getPathFromState ?? getPathFromState;\n\n  const href =\n    typeof to === 'string'\n      ? to\n      : getPathFromStateHelper(\n          {\n            routes: [\n              {\n                name: to.screen,\n                // @ts-expect-error\n                params: to.params,\n                // @ts-expect-error\n                state: getStateFromParams(to.params),\n              },\n            ],\n          },\n          options?.config\n        );\n\n  return {\n    href,\n    accessibilityRole: 'link' as const,\n    onPress,\n  };\n}\n","import {\n  getActionFromState,\n  getStateFromPath,\n  NavigationContainerRefContext,\n} from '@react-navigation/core';\nimport * as React from 'react';\n\nimport LinkingContext from './LinkingContext';\n\nexport type To<\n  ParamList extends ReactNavigation.RootParamList = ReactNavigation.RootParamList,\n  RouteName extends keyof ParamList = keyof ParamList\n> =\n  | string\n  | (undefined extends ParamList[RouteName]\n      ? {\n          screen: Extract<RouteName, string>;\n          params?: ParamList[RouteName];\n        }\n      : {\n          screen: Extract<RouteName, string>;\n          params: ParamList[RouteName];\n        });\n\nexport default function useLinkTo<\n  ParamList extends ReactNavigation.RootParamList\n>() {\n  const navigation = React.useContext(NavigationContainerRefContext);\n  const linking = React.useContext(LinkingContext);\n\n  const linkTo = React.useCallback(\n    (to: To<ParamList>) => {\n      if (navigation === undefined) {\n        throw new Error(\n          \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n        );\n      }\n\n      if (typeof to !== 'string') {\n        // @ts-expect-error: This is fine\n        navigation.navigate(to.screen, to.params);\n        return;\n      }\n\n      if (!to.startsWith('/')) {\n        throw new Error(`The path must start with '/' (${to}).`);\n      }\n\n      const { options } = linking;\n\n      const state = options?.getStateFromPath\n        ? options.getStateFromPath(to, options.config)\n        : getStateFromPath(to, options?.config);\n\n      if (state) {\n        const action = getActionFromState(state, options?.config);\n\n        if (action !== undefined) {\n          navigation.dispatch(action);\n        } else {\n          navigation.reset(state);\n        }\n      } else {\n        throw new Error('Failed to parse the path to a navigation state.');\n      }\n    },\n    [linking, navigation]\n  );\n\n  return linkTo;\n}\n","import {\n  getActionFromState as getActionFromStateDefault,\n  getStateFromPath as getStateFromPathDefault,\n  NavigationContainerRef,\n  ParamListBase,\n} from '@react-navigation/core';\nimport * as React from 'react';\nimport { Linking, Platform } from 'react-native';\n\nimport extractPathFromURL from './extractPathFromURL';\nimport type { LinkingOptions } from './types';\n\ntype ResultState = ReturnType<typeof getStateFromPathDefault>;\n\ntype Options = LinkingOptions<ParamListBase> & {\n  independent?: boolean;\n};\n\nlet linkingHandlers: Symbol[] = [];\n\nexport default function useLinking(\n  ref: React.RefObject<NavigationContainerRef<ParamListBase>>,\n  {\n    independent,\n    enabled = true,\n    prefixes,\n    filter,\n    config,\n    getInitialURL = () =>\n      Promise.race([\n        Linking.getInitialURL(),\n        new Promise<undefined>((resolve) =>\n          // Timeout in 150ms if `getInitialState` doesn't resolve\n          // Workaround for https://github.com/facebook/react-native/issues/25675\n          setTimeout(resolve, 150)\n        ),\n      ]),\n    subscribe = (listener) => {\n      const callback = ({ url }: { url: string }) => listener(url);\n\n      const subscription = Linking.addEventListener('url', callback) as\n        | { remove(): void }\n        | undefined;\n\n      // Storing this in a local variable stops Jest from complaining about import after teardown\n      // @ts-expect-error: removeEventListener is not present in newer RN versions\n      const removeEventListener = Linking.removeEventListener?.bind(Linking);\n\n      return () => {\n        // https://github.com/facebook/react-native/commit/6d1aca806cee86ad76de771ed3a1cc62982ebcd7\n        if (subscription?.remove) {\n          subscription.remove();\n        } else {\n          removeEventListener?.('url', callback);\n        }\n      };\n    },\n    getStateFromPath = getStateFromPathDefault,\n    getActionFromState = getActionFromStateDefault,\n  }: Options\n) {\n  React.useEffect(() => {\n    if (process.env.NODE_ENV === 'production') {\n      return undefined;\n    }\n\n    if (independent) {\n      return undefined;\n    }\n\n    if (enabled !== false && linkingHandlers.length) {\n      console.error(\n        [\n          'Looks like you have configured linking in multiple places. This is likely an error since deep links should only be handled in one place to avoid conflicts. Make sure that:',\n          \"- You don't have multiple NavigationContainers in the app each with 'linking' enabled\",\n          '- Only a single instance of the root component is rendered',\n          Platform.OS === 'android'\n            ? \"- You have set 'android:launchMode=singleTask' in the '<activity />' section of the 'AndroidManifest.xml' file to avoid launching multiple instances\"\n            : '',\n        ]\n          .join('\\n')\n          .trim()\n      );\n    }\n\n    const handler = Symbol();\n\n    if (enabled !== false) {\n      linkingHandlers.push(handler);\n    }\n\n    return () => {\n      const index = linkingHandlers.indexOf(handler);\n\n      if (index > -1) {\n        linkingHandlers.splice(index, 1);\n      }\n    };\n  }, [enabled, independent]);\n\n  // We store these options in ref to avoid re-creating getInitialState and re-subscribing listeners\n  // This lets user avoid wrapping the items in `React.useCallback` or `React.useMemo`\n  // Not re-creating `getInitialState` is important coz it makes it easier for the user to use in an effect\n  const enabledRef = React.useRef(enabled);\n  const prefixesRef = React.useRef(prefixes);\n  const filterRef = React.useRef(filter);\n  const configRef = React.useRef(config);\n  const getInitialURLRef = React.useRef(getInitialURL);\n  const getStateFromPathRef = React.useRef(getStateFromPath);\n  const getActionFromStateRef = React.useRef(getActionFromState);\n\n  React.useEffect(() => {\n    enabledRef.current = enabled;\n    prefixesRef.current = prefixes;\n    filterRef.current = filter;\n    configRef.current = config;\n    getInitialURLRef.current = getInitialURL;\n    getStateFromPathRef.current = getStateFromPath;\n    getActionFromStateRef.current = getActionFromState;\n  });\n\n  const getStateFromURL = React.useCallback(\n    (url: string | null | undefined) => {\n      if (!url || (filterRef.current && !filterRef.current(url))) {\n        return undefined;\n      }\n\n      const path = extractPathFromURL(prefixesRef.current, url);\n\n      return path !== undefined\n        ? getStateFromPathRef.current(path, configRef.current)\n        : undefined;\n    },\n    []\n  );\n\n  const getInitialState = React.useCallback(() => {\n    let state: ResultState | undefined;\n\n    if (enabledRef.current) {\n      const url = getInitialURLRef.current();\n\n      if (url != null && typeof url !== 'string') {\n        return url.then((url) => {\n          const state = getStateFromURL(url);\n\n          return state;\n        });\n      }\n\n      state = getStateFromURL(url);\n    }\n\n    const thenable = {\n      then(onfulfilled?: (state: ResultState | undefined) => void) {\n        return Promise.resolve(onfulfilled ? onfulfilled(state) : state);\n      },\n      catch() {\n        return thenable;\n      },\n    };\n\n    return thenable as PromiseLike<ResultState | undefined>;\n  }, [getStateFromURL]);\n\n  React.useEffect(() => {\n    const listener = (url: string) => {\n      if (!enabled) {\n        return;\n      }\n\n      const navigation = ref.current;\n      const state = navigation ? getStateFromURL(url) : undefined;\n\n      if (navigation && state) {\n        // Make sure that the routes in the state exist in the root navigator\n        // Otherwise there's an error in the linking configuration\n        const rootState = navigation.getRootState();\n\n        if (state.routes.some((r) => !rootState?.routeNames.includes(r.name))) {\n          console.warn(\n            \"The navigation state parsed from the URL contains routes not present in the root navigator. This usually means that the linking configuration doesn't match the navigation structure. See https://reactnavigation.org/docs/configuring-links for more details on how to specify a linking configuration.\"\n          );\n          return;\n        }\n\n        const action = getActionFromStateRef.current(state, configRef.current);\n\n        if (action !== undefined) {\n          try {\n            navigation.dispatch(action);\n          } catch (e) {\n            // Ignore any errors from deep linking.\n            // This could happen in case of malformed links, navigation object not being initialized etc.\n            console.warn(\n              `An error occurred when trying to handle the link '${url}': ${\n                typeof e === 'object' && e != null && 'message' in e\n                  ? e.message\n                  : e\n              }`\n            );\n          }\n        } else {\n          navigation.resetRoot(state);\n        }\n      }\n    };\n\n    return subscribe(listener);\n  }, [enabled, getStateFromURL, ref, subscribe]);\n\n  return {\n    getInitialState,\n  };\n}\n","import {\n  EventArg,\n  NavigationContext,\n  NavigationProp,\n  ParamListBase,\n  useRoute,\n} from '@react-navigation/core';\nimport * as React from 'react';\nimport type { ScrollView } from 'react-native';\n\ntype ScrollOptions = { x?: number; y?: number; animated?: boolean };\n\ntype ScrollableView =\n  | { scrollToTop(): void }\n  | { scrollTo(options: ScrollOptions): void }\n  | { scrollToOffset(options: { offset?: number; animated?: boolean }): void }\n  | { scrollResponderScrollTo(options: ScrollOptions): void };\n\ntype ScrollableWrapper =\n  | { getScrollResponder(): React.ReactNode | ScrollView }\n  | { getNode(): ScrollableView }\n  | ScrollableView;\n\nfunction getScrollableNode(ref: React.RefObject<ScrollableWrapper>) {\n  if (ref.current == null) {\n    return null;\n  }\n\n  if (\n    'scrollToTop' in ref.current ||\n    'scrollTo' in ref.current ||\n    'scrollToOffset' in ref.current ||\n    'scrollResponderScrollTo' in ref.current\n  ) {\n    // This is already a scrollable node.\n    return ref.current;\n  } else if ('getScrollResponder' in ref.current) {\n    // If the view is a wrapper like FlatList, SectionList etc.\n    // We need to use `getScrollResponder` to get access to the scroll responder\n    return ref.current.getScrollResponder();\n  } else if ('getNode' in ref.current) {\n    // When a `ScrollView` is wraped in `Animated.createAnimatedComponent`\n    // we need to use `getNode` to get the ref to the actual scrollview.\n    // Note that `getNode` is deprecated in newer versions of react-native\n    // this is why we check if we already have a scrollable node above.\n    return ref.current.getNode();\n  } else {\n    return ref.current;\n  }\n}\n\nexport default function useScrollToTop(\n  ref: React.RefObject<ScrollableWrapper>\n) {\n  const navigation = React.useContext(NavigationContext);\n  const route = useRoute();\n\n  if (navigation === undefined) {\n    throw new Error(\n      \"Couldn't find a navigation object. Is your component inside NavigationContainer?\"\n    );\n  }\n\n  React.useEffect(() => {\n    const tabNavigations: NavigationProp<ParamListBase>[] = [];\n    let currentNavigation = navigation;\n    // If the screen is nested inside multiple tab navigators, we should scroll to top for any of them\n    // So we need to find all the parent tab navigators and add the listeners there\n    while (currentNavigation) {\n      if (currentNavigation.getState().type === 'tab') {\n        tabNavigations.push(currentNavigation);\n      }\n\n      currentNavigation = currentNavigation.getParent();\n    }\n\n    if (tabNavigations.length === 0) {\n      return;\n    }\n\n    const unsubscribers = tabNavigations.map((tab) => {\n      return tab.addListener(\n        // We don't wanna import tab types here to avoid extra deps\n        // in addition, there are multiple tab implementations\n        // @ts-expect-error\n        'tabPress',\n        (e: EventArg<'tabPress', true>) => {\n          // We should scroll to top only when the screen is focused\n          const isFocused = navigation.isFocused();\n\n          // In a nested stack navigator, tab press resets the stack to first screen\n          // So we should scroll to top only when we are on first screen\n          const isFirst =\n            tabNavigations.includes(navigation) ||\n            navigation.getState().routes[0].key === route.key;\n\n          // Run the operation in the next frame so we're sure all listeners have been run\n          // This is necessary to know if preventDefault() has been called\n          requestAnimationFrame(() => {\n            const scrollable = getScrollableNode(ref) as ScrollableWrapper;\n\n            if (isFocused && isFirst && scrollable && !e.defaultPrevented) {\n              if ('scrollToTop' in scrollable) {\n                scrollable.scrollToTop();\n              } else if ('scrollTo' in scrollable) {\n                scrollable.scrollTo({ y: 0, animated: true });\n              } else if ('scrollToOffset' in scrollable) {\n                scrollable.scrollToOffset({ offset: 0, animated: true });\n              } else if ('scrollResponderScrollTo' in scrollable) {\n                scrollable.scrollResponderScrollTo({ y: 0, animated: true });\n              }\n            }\n          });\n        }\n      );\n    });\n\n    return () => {\n      unsubscribers.forEach((unsubscribe) => unsubscribe());\n    };\n  }, [navigation, ref, route.key]);\n}\n","import * as React from 'react';\n\nexport default function useThenable<T>(create: () => PromiseLike<T>) {\n  const [promise] = React.useState(create);\n\n  let initialState: [boolean, T | undefined] = [false, undefined];\n\n  // Check if our thenable is synchronous\n  promise.then((result) => {\n    initialState = [true, result];\n  });\n\n  const [state, setState] = React.useState(initialState);\n  const [resolved] = state;\n\n  React.useEffect(() => {\n    let cancelled = false;\n\n    const resolve = async () => {\n      let result;\n\n      try {\n        result = await promise;\n      } finally {\n        if (!cancelled) {\n          setState([true, result]);\n        }\n      }\n    };\n\n    if (!resolved) {\n      resolve();\n    }\n\n    return () => {\n      cancelled = true;\n    };\n  }, [promise, resolved]);\n\n  return state;\n}\n","import { nanoid } from 'nanoid/non-secure';\n\nimport type {\n  CommonNavigationAction,\n  NavigationState,\n  PartialState,\n} from './types';\n\n/**\n * Base router object that can be used when writing custom routers.\n * This provides few helper methods to handle common actions such as `RESET`.\n */\nconst BaseRouter = {\n  getStateForAction<State extends NavigationState>(\n    state: State,\n    action: CommonNavigationAction\n  ): State | PartialState<State> | null {\n    switch (action.type) {\n      case 'SET_PARAMS': {\n        const index = action.source\n          ? state.routes.findIndex((r) => r.key === action.source)\n          : state.index;\n\n        if (index === -1) {\n          return null;\n        }\n\n        return {\n          ...state,\n          routes: state.routes.map((r, i) =>\n            i === index\n              ? { ...r, params: { ...r.params, ...action.payload.params } }\n              : r\n          ),\n        };\n      }\n\n      case 'RESET': {\n        const nextState = action.payload as State | PartialState<State>;\n\n        if (\n          nextState.routes.length === 0 ||\n          nextState.routes.some(\n            (route: { name: string }) => !state.routeNames.includes(route.name)\n          )\n        ) {\n          return null;\n        }\n\n        if (nextState.stale === false) {\n          if (\n            state.routeNames.length !== nextState.routeNames.length ||\n            nextState.routeNames.some(\n              (name) => !state.routeNames.includes(name)\n            )\n          ) {\n            return null;\n          }\n\n          return {\n            ...nextState,\n            routes: nextState.routes.map((route) =>\n              route.key ? route : { ...route, key: `${route.name}-${nanoid()}` }\n            ),\n          };\n        }\n\n        return nextState;\n      }\n\n      default:\n        return null;\n    }\n  },\n\n  shouldActionChangeFocus(action: CommonNavigationAction) {\n    return action.type === 'NAVIGATE';\n  },\n};\n\nexport default BaseRouter;\n","import type { NavigationState, PartialState, Route } from './types';\n\ntype ResetState =\n  | PartialState<NavigationState>\n  | NavigationState\n  | (Omit<NavigationState, 'routes'> & {\n      routes: Omit<Route<string>, 'key'>[];\n    });\n\nexport type Action =\n  | {\n      type: 'GO_BACK';\n      source?: string;\n      target?: string;\n    }\n  | {\n      type: 'NAVIGATE';\n      payload:\n        | {\n            key: string;\n            name?: undefined;\n            params?: object;\n            path?: string;\n            merge?: boolean;\n          }\n        | {\n            name: string;\n            key?: string;\n            params?: object;\n            path?: string;\n            merge?: boolean;\n          };\n      source?: string;\n      target?: string;\n    }\n  | {\n      type: 'RESET';\n      payload: ResetState | undefined;\n      source?: string;\n      target?: string;\n    }\n  | {\n      type: 'SET_PARAMS';\n      payload: { params?: object };\n      source?: string;\n      target?: string;\n    };\n\nexport function goBack(): Action {\n  return { type: 'GO_BACK' };\n}\n\nexport function navigate(\n  options:\n    | { key: string; params?: object; path?: string; merge?: boolean }\n    | {\n        name: string;\n        key?: string;\n        params?: object;\n        path?: string;\n        merge?: boolean;\n      }\n): Action;\n// eslint-disable-next-line no-redeclare\nexport function navigate(name: string, params?: object): Action;\n// eslint-disable-next-line no-redeclare\nexport function navigate(...args: any): Action {\n  if (typeof args[0] === 'string') {\n    return { type: 'NAVIGATE', payload: { name: args[0], params: args[1] } };\n  } else {\n    const payload = args[0] || {};\n\n    if (!payload.hasOwnProperty('key') && !payload.hasOwnProperty('name')) {\n      throw new Error(\n        'You need to specify name or key when calling navigate with an object as the argument. See https://reactnavigation.org/docs/navigation-actions#navigate for usage.'\n      );\n    }\n\n    return { type: 'NAVIGATE', payload };\n  }\n}\n\nexport function reset(state: ResetState | undefined): Action {\n  return { type: 'RESET', payload: state };\n}\n\nexport function setParams(params: object): Action {\n  return { type: 'SET_PARAMS', payload: { params } };\n}\n","import { nanoid } from 'nanoid/non-secure';\n\nimport TabRouter, {\n  TabActionHelpers,\n  TabActions,\n  TabActionType,\n  TabNavigationState,\n  TabRouterOptions,\n} from './TabRouter';\nimport type {\n  CommonNavigationAction,\n  ParamListBase,\n  PartialState,\n  Router,\n} from './types';\nexport type DrawerStatus = 'open' | 'closed';\n\nexport type DrawerActionType =\n  | TabActionType\n  | {\n      type: 'OPEN_DRAWER' | 'CLOSE_DRAWER' | 'TOGGLE_DRAWER';\n      source?: string;\n      target?: string;\n    };\n\nexport type DrawerRouterOptions = TabRouterOptions & {\n  defaultStatus?: DrawerStatus;\n};\n\nexport type DrawerNavigationState<ParamList extends ParamListBase> = Omit<\n  TabNavigationState<ParamList>,\n  'type' | 'history'\n> & {\n  /**\n   * Type of the router, in this case, it's drawer.\n   */\n  type: 'drawer';\n  /**\n   * Default status of the drawer.\n   */\n  default: DrawerStatus;\n  /**\n   * List of previously visited route keys and drawer open status.\n   */\n  history: (\n    | { type: 'route'; key: string }\n    | { type: 'drawer'; status: DrawerStatus }\n  )[];\n};\n\nexport type DrawerActionHelpers<ParamList extends ParamListBase> =\n  TabActionHelpers<ParamList> & {\n    /**\n     * Open the drawer sidebar.\n     */\n    openDrawer(): void;\n\n    /**\n     * Close the drawer sidebar.\n     */\n    closeDrawer(): void;\n\n    /**\n     * Open the drawer sidebar if closed, or close if opened.\n     */\n    toggleDrawer(): void;\n  };\n\nexport const DrawerActions = {\n  ...TabActions,\n  openDrawer(): DrawerActionType {\n    return { type: 'OPEN_DRAWER' };\n  },\n  closeDrawer(): DrawerActionType {\n    return { type: 'CLOSE_DRAWER' };\n  },\n  toggleDrawer(): DrawerActionType {\n    return { type: 'TOGGLE_DRAWER' };\n  },\n};\n\nexport default function DrawerRouter({\n  defaultStatus = 'closed',\n  ...rest\n}: DrawerRouterOptions): Router<\n  DrawerNavigationState<ParamListBase>,\n  DrawerActionType | CommonNavigationAction\n> {\n  const router = TabRouter(rest) as unknown as Router<\n    DrawerNavigationState<ParamListBase>,\n    TabActionType | CommonNavigationAction\n  >;\n\n  const isDrawerInHistory = (\n    state:\n      | DrawerNavigationState<ParamListBase>\n      | PartialState<DrawerNavigationState<ParamListBase>>\n  ) => Boolean(state.history?.some((it) => it.type === 'drawer'));\n\n  const addDrawerToHistory = (\n    state: DrawerNavigationState<ParamListBase>\n  ): DrawerNavigationState<ParamListBase> => {\n    if (isDrawerInHistory(state)) {\n      return state;\n    }\n\n    return {\n      ...state,\n      history: [\n        ...state.history,\n        {\n          type: 'drawer',\n          status: defaultStatus === 'open' ? 'closed' : 'open',\n        },\n      ],\n    };\n  };\n\n  const removeDrawerFromHistory = (\n    state: DrawerNavigationState<ParamListBase>\n  ): DrawerNavigationState<ParamListBase> => {\n    if (!isDrawerInHistory(state)) {\n      return state;\n    }\n\n    return {\n      ...state,\n      history: state.history.filter((it) => it.type !== 'drawer'),\n    };\n  };\n\n  const openDrawer = (\n    state: DrawerNavigationState<ParamListBase>\n  ): DrawerNavigationState<ParamListBase> => {\n    if (defaultStatus === 'open') {\n      return removeDrawerFromHistory(state);\n    }\n\n    return addDrawerToHistory(state);\n  };\n\n  const closeDrawer = (\n    state: DrawerNavigationState<ParamListBase>\n  ): DrawerNavigationState<ParamListBase> => {\n    if (defaultStatus === 'open') {\n      return addDrawerToHistory(state);\n    }\n\n    return removeDrawerFromHistory(state);\n  };\n\n  return {\n    ...router,\n\n    type: 'drawer',\n\n    getInitialState({ routeNames, routeParamList, routeGetIdList }) {\n      const state = router.getInitialState({\n        routeNames,\n        routeParamList,\n        routeGetIdList,\n      });\n\n      return {\n        ...state,\n        default: defaultStatus,\n        stale: false,\n        type: 'drawer',\n        key: `drawer-${nanoid()}`,\n      };\n    },\n\n    getRehydratedState(\n      partialState,\n      { routeNames, routeParamList, routeGetIdList }\n    ) {\n      if (partialState.stale === false) {\n        return partialState;\n      }\n\n      let state = router.getRehydratedState(partialState, {\n        routeNames,\n        routeParamList,\n        routeGetIdList,\n      });\n\n      if (isDrawerInHistory(partialState)) {\n        // Re-sync the drawer entry in history to correct it if it was wrong\n        state = removeDrawerFromHistory(state);\n        state = addDrawerToHistory(state);\n      }\n\n      return {\n        ...state,\n        default: defaultStatus,\n        type: 'drawer',\n        key: `drawer-${nanoid()}`,\n      };\n    },\n\n    getStateForRouteFocus(state, key) {\n      const result = router.getStateForRouteFocus(state, key);\n\n      return closeDrawer(result);\n    },\n\n    getStateForAction(state, action, options) {\n      switch (action.type) {\n        case 'OPEN_DRAWER':\n          return openDrawer(state);\n\n        case 'CLOSE_DRAWER':\n          return closeDrawer(state);\n\n        case 'TOGGLE_DRAWER':\n          if (isDrawerInHistory(state)) {\n            return removeDrawerFromHistory(state);\n          }\n\n          return addDrawerToHistory(state);\n\n        case 'JUMP_TO':\n        case 'NAVIGATE': {\n          const result = router.getStateForAction(state, action, options);\n\n          if (result != null && result.index !== state.index) {\n            return closeDrawer(result as DrawerNavigationState<ParamListBase>);\n          }\n\n          return result;\n        }\n\n        case 'GO_BACK':\n          if (isDrawerInHistory(state)) {\n            return removeDrawerFromHistory(state);\n          }\n\n          return router.getStateForAction(state, action, options);\n\n        default:\n          return router.getStateForAction(state, action, options);\n      }\n    },\n\n    actionCreators: DrawerActions,\n  };\n}\n","import { nanoid } from 'nanoid/non-secure';\n\nimport BaseRouter from './BaseRouter';\nimport type {\n  CommonNavigationAction,\n  DefaultRouterOptions,\n  NavigationState,\n  ParamListBase,\n  Route,\n  Router,\n} from './types';\n\nexport type StackActionType =\n  | {\n      type: 'REPLACE';\n      payload: { name: string; key?: string | undefined; params?: object };\n      source?: string;\n      target?: string;\n    }\n  | {\n      type: 'PUSH';\n      payload: { name: string; params?: object };\n      source?: string;\n      target?: string;\n    }\n  | {\n      type: 'POP';\n      payload: { count: number };\n      source?: string;\n      target?: string;\n    }\n  | {\n      type: 'POP_TO_TOP';\n      source?: string;\n      target?: string;\n    };\n\nexport type StackRouterOptions = DefaultRouterOptions;\n\nexport type StackNavigationState<ParamList extends ParamListBase> =\n  NavigationState<ParamList> & {\n    /**\n     * Type of the router, in this case, it's stack.\n     */\n    type: 'stack';\n  };\n\nexport type StackActionHelpers<ParamList extends ParamListBase> = {\n  /**\n   * Replace the current route with a new one.\n   *\n   * @param name Route name of the new route.\n   * @param [params] Params object for the new route.\n   */\n  replace<RouteName extends keyof ParamList>(\n    ...args: undefined extends ParamList[RouteName]\n      ? [screen: RouteName] | [screen: RouteName, params: ParamList[RouteName]]\n      : [screen: RouteName, params: ParamList[RouteName]]\n  ): void;\n\n  /**\n   * Push a new screen onto the stack.\n   *\n   * @param name Name of the route for the tab.\n   * @param [params] Params object for the route.\n   */\n  push<RouteName extends keyof ParamList>(\n    ...args: undefined extends ParamList[RouteName]\n      ? [screen: RouteName] | [screen: RouteName, params: ParamList[RouteName]]\n      : [screen: RouteName, params: ParamList[RouteName]]\n  ): void;\n\n  /**\n   * Pop a screen from the stack.\n   */\n  pop(count?: number): void;\n\n  /**\n   * Pop to the first route in the stack, dismissing all other screens.\n   */\n  popToTop(): void;\n};\n\nexport const StackActions = {\n  replace(name: string, params?: object): StackActionType {\n    return { type: 'REPLACE', payload: { name, params } };\n  },\n  push(name: string, params?: object): StackActionType {\n    return { type: 'PUSH', payload: { name, params } };\n  },\n  pop(count: number = 1): StackActionType {\n    return { type: 'POP', payload: { count } };\n  },\n  popToTop(): StackActionType {\n    return { type: 'POP_TO_TOP' };\n  },\n};\n\nexport default function StackRouter(options: StackRouterOptions) {\n  const router: Router<\n    StackNavigationState<ParamListBase>,\n    CommonNavigationAction | StackActionType\n  > = {\n    ...BaseRouter,\n\n    type: 'stack',\n\n    getInitialState({ routeNames, routeParamList }) {\n      const initialRouteName =\n        options.initialRouteName !== undefined &&\n        routeNames.includes(options.initialRouteName)\n          ? options.initialRouteName\n          : routeNames[0];\n\n      return {\n        stale: false,\n        type: 'stack',\n        key: `stack-${nanoid()}`,\n        index: 0,\n        routeNames,\n        routes: [\n          {\n            key: `${initialRouteName}-${nanoid()}`,\n            name: initialRouteName,\n            params: routeParamList[initialRouteName],\n          },\n        ],\n      };\n    },\n\n    getRehydratedState(partialState, { routeNames, routeParamList }) {\n      let state = partialState;\n\n      if (state.stale === false) {\n        return state;\n      }\n\n      const routes = state.routes\n        .filter((route) => routeNames.includes(route.name))\n        .map(\n          (route) =>\n            ({\n              ...route,\n              key: route.key || `${route.name}-${nanoid()}`,\n              params:\n                routeParamList[route.name] !== undefined\n                  ? {\n                      ...routeParamList[route.name],\n                      ...route.params,\n                    }\n                  : route.params,\n            } as Route<string>)\n        );\n\n      if (routes.length === 0) {\n        const initialRouteName =\n          options.initialRouteName !== undefined\n            ? options.initialRouteName\n            : routeNames[0];\n\n        routes.push({\n          key: `${initialRouteName}-${nanoid()}`,\n          name: initialRouteName,\n          params: routeParamList[initialRouteName],\n        });\n      }\n\n      return {\n        stale: false,\n        type: 'stack',\n        key: `stack-${nanoid()}`,\n        index: routes.length - 1,\n        routeNames,\n        routes,\n      };\n    },\n\n    getStateForRouteNamesChange(\n      state,\n      { routeNames, routeParamList, routeKeyChanges }\n    ) {\n      const routes = state.routes.filter(\n        (route) =>\n          routeNames.includes(route.name) &&\n          !routeKeyChanges.includes(route.name)\n      );\n\n      if (routes.length === 0) {\n        const initialRouteName =\n          options.initialRouteName !== undefined &&\n          routeNames.includes(options.initialRouteName)\n            ? options.initialRouteName\n            : routeNames[0];\n\n        routes.push({\n          key: `${initialRouteName}-${nanoid()}`,\n          name: initialRouteName,\n          params: routeParamList[initialRouteName],\n        });\n      }\n\n      return {\n        ...state,\n        routeNames,\n        routes,\n        index: Math.min(state.index, routes.length - 1),\n      };\n    },\n\n    getStateForRouteFocus(state, key) {\n      const index = state.routes.findIndex((r) => r.key === key);\n\n      if (index === -1 || index === state.index) {\n        return state;\n      }\n\n      return {\n        ...state,\n        index,\n        routes: state.routes.slice(0, index + 1),\n      };\n    },\n\n    getStateForAction(state, action, options) {\n      const { routeParamList } = options;\n\n      switch (action.type) {\n        case 'REPLACE': {\n          const index =\n            action.target === state.key && action.source\n              ? state.routes.findIndex((r) => r.key === action.source)\n              : state.index;\n\n          if (index === -1) {\n            return null;\n          }\n\n          const { name, key, params } = action.payload;\n\n          if (!state.routeNames.includes(name)) {\n            return null;\n          }\n\n          return {\n            ...state,\n            routes: state.routes.map((route, i) =>\n              i === index\n                ? {\n                    key: key !== undefined ? key : `${name}-${nanoid()}`,\n                    name,\n                    params:\n                      routeParamList[name] !== undefined\n                        ? {\n                            ...routeParamList[name],\n                            ...params,\n                          }\n                        : params,\n                  }\n                : route\n            ),\n          };\n        }\n\n        case 'PUSH':\n          if (state.routeNames.includes(action.payload.name)) {\n            const getId = options.routeGetIdList[action.payload.name];\n            const id = getId?.({ params: action.payload.params });\n\n            const route = id\n              ? state.routes.find(\n                  (route) =>\n                    route.name === action.payload.name &&\n                    id === getId?.({ params: route.params })\n                )\n              : undefined;\n\n            let routes: Route<string>[];\n\n            if (route) {\n              routes = state.routes.filter((r) => r.key !== route.key);\n              routes.push({\n                ...route,\n                params:\n                  routeParamList[action.payload.name] !== undefined\n                    ? {\n                        ...routeParamList[action.payload.name],\n                        ...action.payload.params,\n                      }\n                    : action.payload.params,\n              });\n            } else {\n              routes = [\n                ...state.routes,\n                {\n                  key: `${action.payload.name}-${nanoid()}`,\n                  name: action.payload.name,\n                  params:\n                    routeParamList[action.payload.name] !== undefined\n                      ? {\n                          ...routeParamList[action.payload.name],\n                          ...action.payload.params,\n                        }\n                      : action.payload.params,\n                },\n              ];\n            }\n\n            return {\n              ...state,\n              index: routes.length - 1,\n              routes,\n            };\n          }\n\n          return null;\n\n        case 'POP': {\n          const index =\n            action.target === state.key && action.source\n              ? state.routes.findIndex((r) => r.key === action.source)\n              : state.index;\n\n          if (index > 0) {\n            const count = Math.max(index - action.payload.count + 1, 1);\n            const routes = state.routes\n              .slice(0, count)\n              .concat(state.routes.slice(index + 1));\n\n            return {\n              ...state,\n              index: routes.length - 1,\n              routes,\n            };\n          }\n\n          return null;\n        }\n\n        case 'POP_TO_TOP':\n          return router.getStateForAction(\n            state,\n            {\n              type: 'POP',\n              payload: { count: state.routes.length - 1 },\n            },\n            options\n          );\n\n        case 'NAVIGATE':\n          if (\n            action.payload.name !== undefined &&\n            !state.routeNames.includes(action.payload.name)\n          ) {\n            return null;\n          }\n\n          if (action.payload.key || action.payload.name) {\n            // If the route already exists, navigate to that\n            let index = -1;\n\n            const getId =\n              // `getId` and `key` can't be used together\n              action.payload.key === undefined &&\n              action.payload.name !== undefined\n                ? options.routeGetIdList[action.payload.name]\n                : undefined;\n            const id = getId?.({ params: action.payload.params });\n\n            if (id) {\n              index = state.routes.findIndex(\n                (route) =>\n                  route.name === action.payload.name &&\n                  id === getId?.({ params: route.params })\n              );\n            } else if (\n              (state.routes[state.index].name === action.payload.name &&\n                action.payload.key === undefined) ||\n              state.routes[state.index].key === action.payload.key\n            ) {\n              index = state.index;\n            } else {\n              for (let i = state.routes.length - 1; i >= 0; i--) {\n                if (\n                  (state.routes[i].name === action.payload.name &&\n                    action.payload.key === undefined) ||\n                  state.routes[i].key === action.payload.key\n                ) {\n                  index = i;\n                  break;\n                }\n              }\n            }\n\n            if (\n              index === -1 &&\n              action.payload.key &&\n              action.payload.name === undefined\n            ) {\n              return null;\n            }\n\n            if (index === -1 && action.payload.name !== undefined) {\n              const routes = [\n                ...state.routes,\n                {\n                  key:\n                    action.payload.key ?? `${action.payload.name}-${nanoid()}`,\n                  name: action.payload.name,\n                  path: action.payload.path,\n                  params:\n                    routeParamList[action.payload.name] !== undefined\n                      ? {\n                          ...routeParamList[action.payload.name],\n                          ...action.payload.params,\n                        }\n                      : action.payload.params,\n                },\n              ];\n\n              return {\n                ...state,\n                routes,\n                index: routes.length - 1,\n              };\n            }\n\n            const route = state.routes[index];\n\n            let params;\n\n            if (action.payload.merge) {\n              params =\n                action.payload.params !== undefined ||\n                routeParamList[route.name] !== undefined\n                  ? {\n                      ...routeParamList[route.name],\n                      ...route.params,\n                      ...action.payload.params,\n                    }\n                  : route.params;\n            } else {\n              params =\n                routeParamList[route.name] !== undefined\n                  ? {\n                      ...routeParamList[route.name],\n                      ...action.payload.params,\n                    }\n                  : action.payload.params;\n            }\n\n            return {\n              ...state,\n              index,\n              routes: [\n                ...state.routes.slice(0, index),\n                params !== route.params ||\n                (action.payload.path && action.payload.path !== route.path)\n                  ? {\n                      ...route,\n                      path: action.payload.path ?? route.path,\n                      params,\n                    }\n                  : state.routes[index],\n              ],\n            };\n          }\n\n          return null;\n\n        case 'GO_BACK':\n          if (state.index > 0) {\n            return router.getStateForAction(\n              state,\n              {\n                type: 'POP',\n                payload: { count: 1 },\n                target: action.target,\n                source: action.source,\n              },\n              options\n            );\n          }\n\n          return null;\n\n        default:\n          return BaseRouter.getStateForAction(state, action);\n      }\n    },\n\n    actionCreators: StackActions,\n  };\n\n  return router;\n}\n","import { nanoid } from 'nanoid/non-secure';\n\nimport BaseRouter from './BaseRouter';\nimport type {\n  CommonNavigationAction,\n  DefaultRouterOptions,\n  NavigationState,\n  ParamListBase,\n  PartialState,\n  Route,\n  Router,\n} from './types';\n\nexport type TabActionType = {\n  type: 'JUMP_TO';\n  payload: { name: string; params?: object };\n  source?: string;\n  target?: string;\n};\n\nexport type BackBehavior =\n  | 'initialRoute'\n  | 'firstRoute'\n  | 'history'\n  | 'order'\n  | 'none';\n\nexport type TabRouterOptions = DefaultRouterOptions & {\n  backBehavior?: BackBehavior;\n};\n\nexport type TabNavigationState<ParamList extends ParamListBase> = Omit<\n  NavigationState<ParamList>,\n  'history'\n> & {\n  /**\n   * Type of the router, in this case, it's tab.\n   */\n  type: 'tab';\n  /**\n   * List of previously visited route keys.\n   */\n  history: { type: 'route'; key: string }[];\n};\n\nexport type TabActionHelpers<ParamList extends ParamListBase> = {\n  /**\n   * Jump to an existing tab.\n   *\n   * @param name Name of the route for the tab.\n   * @param [params] Params object for the route.\n   */\n  jumpTo<RouteName extends Extract<keyof ParamList, string>>(\n    ...args: undefined extends ParamList[RouteName]\n      ? [screen: RouteName] | [screen: RouteName, params: ParamList[RouteName]]\n      : [screen: RouteName, params: ParamList[RouteName]]\n  ): void;\n};\n\nconst TYPE_ROUTE = 'route' as const;\n\nexport const TabActions = {\n  jumpTo(name: string, params?: object): TabActionType {\n    return { type: 'JUMP_TO', payload: { name, params } };\n  },\n};\n\nconst getRouteHistory = (\n  routes: Route<string>[],\n  index: number,\n  backBehavior: BackBehavior,\n  initialRouteName: string | undefined\n) => {\n  const history = [{ type: TYPE_ROUTE, key: routes[index].key }];\n  let initialRouteIndex;\n\n  switch (backBehavior) {\n    case 'order':\n      for (let i = index; i > 0; i--) {\n        history.unshift({ type: TYPE_ROUTE, key: routes[i - 1].key });\n      }\n      break;\n    case 'firstRoute':\n      if (index !== 0) {\n        history.unshift({\n          type: TYPE_ROUTE,\n          key: routes[0].key,\n        });\n      }\n      break;\n    case 'initialRoute':\n      initialRouteIndex = routes.findIndex(\n        (route) => route.name === initialRouteName\n      );\n      initialRouteIndex = initialRouteIndex === -1 ? 0 : initialRouteIndex;\n\n      if (index !== initialRouteIndex) {\n        history.unshift({\n          type: TYPE_ROUTE,\n          key: routes[initialRouteIndex].key,\n        });\n      }\n      break;\n    case 'history':\n      // The history will fill up on navigation\n      break;\n  }\n\n  return history;\n};\n\nconst changeIndex = (\n  state: TabNavigationState<ParamListBase>,\n  index: number,\n  backBehavior: BackBehavior,\n  initialRouteName: string | undefined\n) => {\n  let history;\n\n  if (backBehavior === 'history') {\n    const currentKey = state.routes[index].key;\n\n    history = state.history\n      .filter((it) => (it.type === 'route' ? it.key !== currentKey : false))\n      .concat({ type: TYPE_ROUTE, key: currentKey });\n  } else {\n    history = getRouteHistory(\n      state.routes,\n      index,\n      backBehavior,\n      initialRouteName\n    );\n  }\n\n  return {\n    ...state,\n    index,\n    history,\n  };\n};\n\nexport default function TabRouter({\n  initialRouteName,\n  backBehavior = 'firstRoute',\n}: TabRouterOptions) {\n  const router: Router<\n    TabNavigationState<ParamListBase>,\n    TabActionType | CommonNavigationAction\n  > = {\n    ...BaseRouter,\n\n    type: 'tab',\n\n    getInitialState({ routeNames, routeParamList }) {\n      const index =\n        initialRouteName !== undefined && routeNames.includes(initialRouteName)\n          ? routeNames.indexOf(initialRouteName)\n          : 0;\n\n      const routes = routeNames.map((name) => ({\n        name,\n        key: `${name}-${nanoid()}`,\n        params: routeParamList[name],\n      }));\n\n      const history = getRouteHistory(\n        routes,\n        index,\n        backBehavior,\n        initialRouteName\n      );\n\n      return {\n        stale: false,\n        type: 'tab',\n        key: `tab-${nanoid()}`,\n        index,\n        routeNames,\n        history,\n        routes,\n      };\n    },\n\n    getRehydratedState(partialState, { routeNames, routeParamList }) {\n      let state = partialState;\n\n      if (state.stale === false) {\n        return state;\n      }\n\n      const routes = routeNames.map((name) => {\n        const route = (\n          state as PartialState<TabNavigationState<ParamListBase>>\n        ).routes.find((r) => r.name === name);\n\n        return {\n          ...route,\n          name,\n          key:\n            route && route.name === name && route.key\n              ? route.key\n              : `${name}-${nanoid()}`,\n          params:\n            routeParamList[name] !== undefined\n              ? {\n                  ...routeParamList[name],\n                  ...(route ? route.params : undefined),\n                }\n              : route\n              ? route.params\n              : undefined,\n        } as Route<string>;\n      });\n\n      const index = Math.min(\n        Math.max(routeNames.indexOf(state.routes[state?.index ?? 0]?.name), 0),\n        routes.length - 1\n      );\n\n      const history =\n        state.history?.filter((it) => routes.find((r) => r.key === it.key)) ??\n        [];\n\n      return changeIndex(\n        {\n          stale: false,\n          type: 'tab',\n          key: `tab-${nanoid()}`,\n          index,\n          routeNames,\n          history,\n          routes,\n        },\n        index,\n        backBehavior,\n        initialRouteName\n      );\n    },\n\n    getStateForRouteNamesChange(\n      state,\n      { routeNames, routeParamList, routeKeyChanges }\n    ) {\n      const routes = routeNames.map(\n        (name) =>\n          state.routes.find(\n            (r) => r.name === name && !routeKeyChanges.includes(r.name)\n          ) || {\n            name,\n            key: `${name}-${nanoid()}`,\n            params: routeParamList[name],\n          }\n      );\n\n      const index = Math.max(\n        0,\n        routeNames.indexOf(state.routes[state.index].name)\n      );\n\n      let history = state.history.filter(\n        // Type will always be 'route' for tabs, but could be different in a router extending this (e.g. drawer)\n        (it) => it.type !== 'route' || routes.find((r) => r.key === it.key)\n      );\n\n      if (!history.length) {\n        history = getRouteHistory(\n          routes,\n          index,\n          backBehavior,\n          initialRouteName\n        );\n      }\n\n      return {\n        ...state,\n        history,\n        routeNames,\n        routes,\n        index,\n      };\n    },\n\n    getStateForRouteFocus(state, key) {\n      const index = state.routes.findIndex((r) => r.key === key);\n\n      if (index === -1 || index === state.index) {\n        return state;\n      }\n\n      return changeIndex(state, index, backBehavior, initialRouteName);\n    },\n\n    getStateForAction(state, action, { routeParamList, routeGetIdList }) {\n      switch (action.type) {\n        case 'JUMP_TO':\n        case 'NAVIGATE': {\n          let index = -1;\n\n          if (action.type === 'NAVIGATE' && action.payload.key) {\n            index = state.routes.findIndex(\n              (route) => route.key === action.payload.key\n            );\n          } else {\n            index = state.routes.findIndex(\n              (route) => route.name === action.payload.name\n            );\n          }\n\n          if (index === -1) {\n            return null;\n          }\n\n          return changeIndex(\n            {\n              ...state,\n              routes: state.routes.map((route, i) => {\n                if (i !== index) {\n                  return route;\n                }\n\n                const getId = routeGetIdList[route.name];\n\n                const currentId = getId?.({ params: route.params });\n                const nextId = getId?.({ params: action.payload.params });\n\n                const key =\n                  currentId === nextId\n                    ? route.key\n                    : `${route.name}-${nanoid()}`;\n\n                let params;\n\n                if (\n                  action.type === 'NAVIGATE' &&\n                  action.payload.merge &&\n                  currentId === nextId\n                ) {\n                  params =\n                    action.payload.params !== undefined ||\n                    routeParamList[route.name] !== undefined\n                      ? {\n                          ...routeParamList[route.name],\n                          ...route.params,\n                          ...action.payload.params,\n                        }\n                      : route.params;\n                } else {\n                  params =\n                    routeParamList[route.name] !== undefined\n                      ? {\n                          ...routeParamList[route.name],\n                          ...action.payload.params,\n                        }\n                      : action.payload.params;\n                }\n\n                const path =\n                  action.type === 'NAVIGATE' && action.payload.path != null\n                    ? action.payload.path\n                    : route.path;\n\n                return params !== route.params || path !== route.path\n                  ? { ...route, key, path, params }\n                  : route;\n              }),\n            },\n            index,\n            backBehavior,\n            initialRouteName\n          );\n        }\n\n        case 'GO_BACK': {\n          if (state.history.length === 1) {\n            return null;\n          }\n\n          const previousKey = state.history[state.history.length - 2].key;\n          const index = state.routes.findIndex(\n            (route) => route.key === previousKey\n          );\n\n          if (index === -1) {\n            return null;\n          }\n\n          return {\n            ...state,\n            history: state.history.slice(0, -1),\n            index,\n          };\n        }\n\n        default:\n          return BaseRouter.getStateForAction(state, action);\n      }\n    },\n\n    shouldActionChangeFocus(action) {\n      return action.type === 'NAVIGATE';\n    },\n\n    actionCreators: TabActions,\n  };\n\n  return router;\n}\n","import * as CommonActions from './CommonActions';\n\nexport { CommonActions };\n\nexport { default as BaseRouter } from './BaseRouter';\nexport type {\n  DrawerActionHelpers,\n  DrawerActionType,\n  DrawerNavigationState,\n  DrawerRouterOptions,\n  DrawerStatus,\n} from './DrawerRouter';\nexport { DrawerActions, default as DrawerRouter } from './DrawerRouter';\nexport type {\n  StackActionHelpers,\n  StackActionType,\n  StackNavigationState,\n  StackRouterOptions,\n} from './StackRouter';\nexport { StackActions, default as StackRouter } from './StackRouter';\nexport type {\n  TabActionHelpers,\n  TabActionType,\n  TabNavigationState,\n  TabRouterOptions,\n} from './TabRouter';\nexport { TabActions, default as TabRouter } from './TabRouter';\nexport * from './types';\n"],"names":["_type_of","require","_to_primitive","input","hint","prim","Symbol","undefined","res","TypeError","String","Number","exports","_to_property_key","arg","key","token","singleMatcher","RegExp","multiMatcher","decodeComponents","components","split","decodeURIComponent","err","left","right","Array","decode","tokens","i","customDecodeURIComponent","replaceMap","match","result","entries","Object","module","encodedURI","string","obj","predicate","ret","keys","isArr","val","customAlphabet","nanoid","urlAlphabet","alphabet","defaultSize","size","id","Math","strictUriEncode","decodeComponent","splitOnFirst","filterObject","isNullOrUndefined","value","encodeFragmentIdentifier","encoderForArrayFormat","options","index","encode","keyValueSep","parserForArrayFormat","accumulator","isArray","isEncodedArray","newValue","item","arrayValue","validateArrayFormatSeparator","encodeURIComponent","keysSorter","a","b","removeHash","hashStart","getHash","url","hash","extract","queryStart","parseValue","parse","query","formatter","param","_splitOnFirst","key1","value1","k","Boolean","object","shouldFilter","objectCopy","x","url_","queryFromUrl","parsedQueryFromUrl","queryString","filter","_exports_parseUrl","fragmentIdentifier","exclusionFilter","process","hasSymbol","REACT_ELEMENT_TYPE","REACT_PORTAL_TYPE","REACT_FRAGMENT_TYPE","REACT_STRICT_MODE_TYPE","REACT_PROFILER_TYPE","REACT_PROVIDER_TYPE","REACT_CONTEXT_TYPE","REACT_ASYNC_MODE_TYPE","REACT_CONCURRENT_MODE_TYPE","REACT_FORWARD_REF_TYPE","REACT_SUSPENSE_TYPE","REACT_SUSPENSE_LIST_TYPE","REACT_MEMO_TYPE","REACT_LAZY_TYPE","REACT_BLOCK_TYPE","REACT_FUNDAMENTAL_TYPE","REACT_RESPONDER_TYPE","REACT_SCOPE_TYPE","isValidElementType","type","typeOf","$$typeof","$$typeofType","AsyncMode","ConcurrentMode","ContextConsumer","ContextProvider","Element","ForwardRef","Fragment","Lazy","Memo","Portal","Profiler","StrictMode","Suspense","hasWarnedAboutDeprecatedIsAsyncMode","isAsyncMode","console","isConcurrentMode","isContextConsumer","isContextProvider","isElement","isForwardRef","isFragment","isLazy","isMemo","isPortal","isProfiler","isStrictMode","isSuspense","separator","separatorIndex","str","React","useIsomorphicLayoutEffect_1","useLatestCallback","callback","ref","latestCallback","args","_i","arguments","react_1","_default","serializableWarnings","duplicateNameWarnings","getPartialState","state","routeNames","partialState","route","BaseNavigationContainer","_react","ref1","initialState","onStateChange","onUnhandledAction","independent","children","parent","_NavigationStateContext","Error","_useSyncState1","getState","setState","scheduleUpdate","flushUpdates","isFirstMountRef","navigatorKeyRef","getKey","setKey","_useChildListeners1","listeners","addListener","_useKeyedChildListeners1","keyedListeners","addKeyedListener","dispatch","action","_createNavigationContainerRef","navigation","canGoBack","_listeners_focus_","handled","resetRoot","_keyedListeners_getState","target","_routers","getRootState","getCurrentRoute","_findFocusedRoute","emitter","_useEventEmitter","_useOptionsGetters1","addOptionsGetter","getCurrentOptions","acc","name","_CommonActions","stateRef","onDispatchAction","noop","stackRef","lastEmittedOptionsRef","onOptionsChange","builderContext","scheduleContext","isInitialRef","getIsInitial","context","onStateChangeRef","hydratedState","serializableResult","_checkSerializable","location","reason","path","pointer","params","curr","prev","JSON","message","duplicateRouteNamesResult","_checkDuplicateRouteNames","message1","locations","defaultOnUnhandledAction","payload","element","_NavigationContainerRefContext","_useScheduleUpdate","_NavigationBuilderContext","_UnhandledActionContext","_EnsureSingleNavigator","_NavigationRouteContext","_NavigationContext","CurrentRenderContext","SingleNavigatorContext","EnsureSingleNavigator","MULTIPLE_NAVIGATOR_ERROR","currentKey","Group","_","NavigationBuilderContext","NavigationContainerRefContext","NavigationContext","NavigationHelpersContext","NavigationRouteContext","MISSING_CONTEXT_ERROR","PreventRemoveContext","PreventRemoveProvider","transformPreventedRoutes","preventedRoutesMap","preventedRoutesToTransform","preventedRoutes","routeKey","preventRemove","_acc_routeKey","_React_useState","_nonsecure","parentId","_React_useState1","Map","setPreventedRoutesMap","_NavigationHelpersContext","preventRemoveContextValue","_PreventRemoveContext","setParentPrevented","setPreventRemove","_uselatestcallback","prevPrevented","_prevPrevented_get","_prevPrevented_get1","nextPrevented","isPrevented","SceneView","screen","routeState","clearOptions","_useOptionsGetters","getCurrentState","currentRoute","r","setCurrentState","child","ScreenComponent","_StaticContainer","Screen","StaticContainer","props","prevProps","nextProps","prevPropKeys","nextPropKeys","UnhandledActionContext","checkDuplicateRouteNames","duplicates","getRouteNames","_route_state_routeNames","currentLocation","routeName","checkSerializable","checkSerializableWithoutCircularReference","o","seen","childResult","Set","childResult1","NOT_INITIALIZED_ERROR","createNavigationContainerRef","methods","removeListener","event","cb","current","callbacks","_args","_args1","event1","callback1","_current","createNavigatorFactory","Navigator","_Group","_Screen","findFocusedRoute","fromEntries","v","getActionFromState","_normalizedConfig_screens","normalizedConfig","createNormalizedConfigItem","routes","config","_config_screens","routes1","route1","createNormalizedConfigs","getFocusedRouteNameFromRoute","_useRouteCache","getPathFromState","_instance","getActiveRoute","pattern","currentOptions","nestedRouteNames","_currentOptions_route_name","stringify","currentParams","_fromEntries","allParams","focusedRoute","focusedParams","p","getParamName","hasNext","nextRoute","nestedConfig","configs","_querystring","_validatePathConfig","joinPaths","paths","createConfigItem","parentPattern","pattern1","screens","c","getStateFromPath","initialRoutes","remaining","segment","createNestedStateObject","aParts","bParts","aWildCard","bWildCard","intersects","it","_configs_find","_matchAgainstConfigs","remainingPath","matchAgainstConfigs","_config_pattern","matchResult","decodedParamSegment","matchedParams","_routeConfig_pattern_replace","routeConfig","normalizedPath","numInitialSegments","_escapestringregexp","_matchedParams_p","offset","_routeConfig_parse","initials","parentScreens","_configs","regex","findParseConfigForRoute","flatConfig","findInitialRoute","sameParents","createStateObject","initialRoute","isEmpty","nestedState","nestedStateIndex","parseQueryParams","parseConfig","_BaseNavigationContainer","_CurrentRenderContext","_PreventRemoveProvider","_usePreventRemove","_createNavigatorFactory","_getActionFromState","_getFocusedRouteNameFromRoute","_getPathFromState","_getStateFromPath","_useFocusEffect","_useIsFocused","_useNavigation","_useNavigationBuilder","_useNavigationContainerRef","_useNavigationState","_usePreventRemoveContext","_useRoute","isArrayEqual","isRecordEqual","aKeys","bKeys","PrivateValueStore","useChildListeners","_React_useRef","listener","removed","useComponent","NavigationContent","render","renderRef","_$render","useCurrentRender","descriptors","useDescriptors","screenOptions","defaultScreenOptions","onAction","onRouteFocus","router","setOptions","_React_useContext","navigations","_useNavigationCache","optionsList","customOptions","mergedOptions","_route_key","rest","_SceneView","useEventEmitter","listen","listenRef","create","emit","data","canPreventDefault","_items_target","items","t","self","defaultPrevented","useFocusEffect","effect","isFocused","cleanup","destroy","unsubscribeFocus","unsubscribeBlur","useFocusEvents","lastFocusedKeyRef","currentFocusedKey","lastFocusedKey","useFocusedListenersChildrenAdapter","focusedListeners","_listener","useIsFocused","_useState","setIsFocused","valueToReturn","useKeyedChildListeners","useNavigation","root","useNavigationBuilder","_types","isValidKey","getRouteConfigsFromChildren","groupKey","groupOptions","_child_type","_child_props","_acc","_config_props","_$children","component","getComponent","_reactis","createRouter","navigatorKey","_useRegisterNavigator","screenListeners","routeConfigs","routeKeyList","routeParamList","initialParams","routeGetIdList","isStateValid","isStateInitialized","currentState","stateCleanedUp","cleanUpState","_React_useMemo","_route_params","initialRouteParamList","_route_params1","_route_params2","initialParamsFromParams","initializedState","isFirstStateInitialization","previousRouteKeyListRef","previousRouteKeyList","nextState","_isArrayEqual","_isRecordEqual","previousNestedParamsRef","previousParams","updatedState","shouldUpdate","setTimeout","initializedStateRef","e","_routeNames","map","_useFocusEvents","childListeners","_useOnAction","_useOnRouteFocus","_useNavigationHelpers","_useFocusedListenersChildrenAdapter","_useOnGetState","_useDescriptors","_useCurrentRender","_useComponent","useNavigationCache","cache","actions","previous","thunk","withStack","isStackSet","helpers","_actions","useNavigationContainerRef","useNavigationHelpers","navigatorId","parentNavigationHelpers","op","navigationHelpers","useNavigationState","selector","setResult","selectorRef","unsubscribe","useOnAction","actionListeners","beforeRemoveListeners","routerConfigOptions","onActionParent","onRouteFocusParent","addListenerParent","routerConfigOptionsRef","visitedNavigators","_useOnPreventRemove","shouldFocus","useOnGetState","getStateListeners","getRehydratedState","childState","useOnPreventRemove","shouldPreventRemove","VISITED_ROUTE_KEYS","currentRoutes","nextRoutes","nextRouteKeys","removedRoutes","visitedRouteKeys","beforeRemoveAction","useOnRouteFocus","sourceRouteKey","useOptionsGetters","optionsRef","optionsGettersFromChildRef","parentAddOptionsGetter","optionsChangeListener","hasChildren","getOptionsFromListener","_optionsGettersFromChildRef_current","optionsFromListener","getter","usePreventRemove","_useRoute1","beforeRemoveListener","usePreventRemoveContext","useRegisterNavigator","container","register","unregister","useRoute","CHILD_STATE","useRouteCache","proxy","ScheduleUpdateContext","useScheduleUpdate","useSyncState","UNINTIALIZED_STATE","isSchedulingRef","isMountedRef","trackingState","setTrackingState","validatePathConfig","formatToList","validKeys","invalidKeys","Link","_param","to","_useLinkProps","onPress","_reactnative","LinkingContext","global","WeakMap","NavigationContainerInner","theme","_DefaultTheme","linking","fallback","documentTitle","onReady","isLinkingEnabled","_core","refContainer","_useBackButton","_useDocumentTitle","getInitialState","_useLinking","REACT_NAVIGATION_DEVTOOLS","_useThenable1","isResolved","linkingContext","isReady","onReadyRef","_LinkingContext","_ThemeProvider","NavigationContainer","ServerContainer","_ServerContext","ServerContext","extractPathFromURL","prefixes","prefix","_prefix_match","protocol","host","prefixRegex","_url_split","originAndPath","searchParams","normalizedURL","_DarkTheme","_Link","_NavigationContainer","_ServerContainer","_useLinkBuilder","_useLinkTo","_useScrollToTop","_useTheme","DarkTheme","DefaultTheme","ThemeContext","ThemeProvider","_ThemeContext","useTheme","useBackButton","subscription","useDocumentTitle","useLinkBuilder","getRootStateForNavigate","parentState","buildLink","useLinkProps","getStateFromParams","linkTo","_e_currentTarget","shouldHandle","getPathFromStateHelper","href","useLinkTo","useLinking","linkingHandlers","enabled","getInitialURL","Promise","resolve","subscribe","_Linking_removeEventListener","removeEventListener","handler","enabledRef","prefixesRef","filterRef","configRef","getInitialURLRef","getStateFromPathRef","getActionFromStateRef","getStateFromURL","_extractPathFromURL","thenable","onfulfilled","rootState","useScrollToTop","getScrollableNode","tabNavigations","currentNavigation","unsubscribers","tab","isFirst","requestAnimationFrame","scrollable","useThenable","promise","_state","resolved","cancelled","BaseRouter","goBack","navigate","reset","setParams","DrawerActions","DrawerRouter","_TabRouter","defaultStatus","isDrawerInHistory","_state_history","addDrawerToHistory","removeDrawerFromHistory","openDrawer","closeDrawer","StackActions","StackRouter","count","_BaseRouter","initialRouteName","routeKeyChanges","_action_payload","getId","index1","index2","getId1","id1","routes2","params1","TabActions","TabRouter","TYPE_ROUTE","getRouteHistory","backBehavior","history","initialRouteIndex","changeIndex","_state_routes_","currentId","nextId","previousKey","_DrawerRouter","_StackRouter"],"mappings":"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"}