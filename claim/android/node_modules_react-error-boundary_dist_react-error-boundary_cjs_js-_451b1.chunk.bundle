(self["webpackChunkclaim"] = self["webpackChunkclaim"] || []).push([["node_modules_react-error-boundary_dist_react-error-boundary_cjs_js-_451b1"], {
"./node_modules/react-error-boundary/dist/react-error-boundary.cjs.js": 
/*!****************************************************************************!*\
  !*** ./node_modules/react-error-boundary/dist/react-error-boundary.cjs.js ***!
  \****************************************************************************/
(function (__unused_webpack_module, exports, __webpack_require__) {
'use client';
'use strict';
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _call_super = __webpack_require__(/*! @swc/helpers/_/_call_super */ "./node_modules/@swc/helpers/cjs/_call_super.cjs");
var _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ "./node_modules/@swc/helpers/cjs/_class_call_check.cjs");
var _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ "./node_modules/@swc/helpers/cjs/_create_class.cjs");
var _inherits = __webpack_require__(/*! @swc/helpers/_/_inherits */ "./node_modules/@swc/helpers/cjs/_inherits.cjs");
var _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ "./node_modules/@swc/helpers/cjs/_object_spread.cjs");
var _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ "./node_modules/@swc/helpers/cjs/_object_spread_props.cjs");
var _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ "./node_modules/@swc/helpers/cjs/_sliced_to_array.cjs");
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var react = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
var ErrorBoundaryContext = react.createContext(null);
var initialState = {
    didCatch: false,
    error: null
};
var ErrorBoundary = /*#__PURE__*/ function(_react_Component) {
    "use strict";
    _inherits._(ErrorBoundary, _react_Component);
    function ErrorBoundary(props) {
        _class_call_check._(this, ErrorBoundary);
        var _this;
        _this = _call_super._(this, ErrorBoundary, [
            props
        ]);
        _this.resetErrorBoundary = _this.resetErrorBoundary.bind(_this);
        _this.state = initialState;
        return _this;
    }
    _create_class._(ErrorBoundary, [
        {
            key: "resetErrorBoundary",
            value: function resetErrorBoundary() {
                var error = this.state.error;
                if (error !== null) {
                    var _this$props$onReset, _this$props;
                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                        args[_key] = arguments[_key];
                    }
                    (_this$props$onReset = (_this$props = this.props).onReset) === null || _this$props$onReset === void 0 ? void 0 : _this$props$onReset.call(_this$props, {
                        args,
                        reason: "imperative-api"
                    });
                    this.setState(initialState);
                }
            }
        },
        {
            key: "componentDidCatch",
            value: function componentDidCatch(error, info) {
                var _this$props$onError, _this$props2;
                (_this$props$onError = (_this$props2 = this.props).onError) === null || _this$props$onError === void 0 ? void 0 : _this$props$onError.call(_this$props2, error, info);
            }
        },
        {
            key: "componentDidUpdate",
            value: function componentDidUpdate(prevProps, prevState) {
                var didCatch = this.state.didCatch;
                var resetKeys = this.props.resetKeys;
                // There's an edge case where if the thing that triggered the error happens to *also* be in the resetKeys array,
                // we'd end up resetting the error boundary immediately.
                // This would likely trigger a second error to be thrown.
                // So we make sure that we don't check the resetKeys on the first call of cDU after the error is set.
                if (didCatch && prevState.error !== null && hasArrayChanged(prevProps.resetKeys, resetKeys)) {
                    var _this$props$onReset2, _this$props3;
                    (_this$props$onReset2 = (_this$props3 = this.props).onReset) === null || _this$props$onReset2 === void 0 ? void 0 : _this$props$onReset2.call(_this$props3, {
                        next: resetKeys,
                        prev: prevProps.resetKeys,
                        reason: "keys"
                    });
                    this.setState(initialState);
                }
            }
        },
        {
            key: "render",
            value: function render() {
                var _this_props = this.props, children = _this_props.children, fallbackRender = _this_props.fallbackRender, FallbackComponent = _this_props.FallbackComponent, fallback = _this_props.fallback;
                var _this_state = this.state, didCatch = _this_state.didCatch, error = _this_state.error;
                var childToRender = children;
                if (didCatch) {
                    var props = {
                        error,
                        resetErrorBoundary: this.resetErrorBoundary
                    };
                    if (typeof fallbackRender === "function") {
                        childToRender = fallbackRender(props);
                    } else if (FallbackComponent) {
                        childToRender = react.createElement(FallbackComponent, props);
                    } else if (fallback !== undefined) {
                        childToRender = fallback;
                    } else {
                        throw error;
                    }
                }
                return react.createElement(ErrorBoundaryContext.Provider, {
                    value: {
                        didCatch,
                        error,
                        resetErrorBoundary: this.resetErrorBoundary
                    }
                }, childToRender);
            }
        }
    ], [
        {
            key: "getDerivedStateFromError",
            value: function getDerivedStateFromError(error) {
                return {
                    didCatch: true,
                    error
                };
            }
        }
    ]);
    return ErrorBoundary;
}(react.Component);
function hasArrayChanged() {
    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return a.length !== b.length || a.some((item, index)=>!Object.is(item, b[index]));
}
function assertErrorBoundaryContext(value) {
    if (value == null || typeof value.didCatch !== "boolean" || typeof value.resetErrorBoundary !== "function") {
        throw new Error("ErrorBoundaryContext not found");
    }
}
function useErrorBoundary() {
    var context = react.useContext(ErrorBoundaryContext);
    assertErrorBoundaryContext(context);
    var _react_useState = _sliced_to_array._(react.useState({
        error: null,
        hasError: false
    }), 2), state = _react_useState[0], setState = _react_useState[1];
    var memoized = react.useMemo(()=>({
            resetBoundary: ()=>{
                context.resetErrorBoundary();
                setState({
                    error: null,
                    hasError: false
                });
            },
            showBoundary: (error)=>setState({
                    error,
                    hasError: true
                })
        }), [
        context.resetErrorBoundary
    ]);
    if (state.hasError) {
        throw state.error;
    }
    return memoized;
}
function withErrorBoundary(component, errorBoundaryProps) {
    var Wrapped = react.forwardRef((props, ref)=>react.createElement(ErrorBoundary, errorBoundaryProps, react.createElement(component, _object_spread_props._(_object_spread._({}, props), {
            ref
        }))));
    // Format for display in DevTools
    var name = component.displayName || component.name || "Unknown";
    Wrapped.displayName = "withErrorBoundary(".concat(name, ")");
    return Wrapped;
}
exports.ErrorBoundary = ErrorBoundary;
exports.ErrorBoundaryContext = ErrorBoundaryContext;
exports.useErrorBoundary = useErrorBoundary;
exports.withErrorBoundary = withErrorBoundary;


}),

}]);//# sourceMappingURL=node_modules_react-error-boundary_dist_react-error-boundary_cjs_js-_451b1.chunk.bundle.map?platform=android