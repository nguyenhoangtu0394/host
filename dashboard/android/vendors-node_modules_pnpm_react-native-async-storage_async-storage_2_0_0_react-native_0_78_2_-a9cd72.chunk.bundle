(self["webpackChunksas_dashboard"] = self["webpackChunksas_dashboard"] || []).push([["vendors-node_modules_pnpm_react-native-async-storage_async-storage_2_0_0_react-native_0_78_2_-a9cd72"], {
70870: (function (__unused_webpack_module, exports, __webpack_require__) {
/**
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _interop_require_default = __webpack_require__(97433);
var _sliced_to_array = __webpack_require__(17738);
var _helpers = __webpack_require__(34996);
var _RCTAsyncStorage = /*#__PURE__*/ _interop_require_default._(__webpack_require__(79945));
if (!_RCTAsyncStorage.default) {
    throw new Error(`[@RNC/AsyncStorage]: NativeModule: AsyncStorage is null.

To fix this issue try these steps:

  • Uninstall, rebuild and restart the app.

  • Run the packager with \`--reset-cache\` flag.

  • If you are using CocoaPods on iOS, run \`pod install\` in the \`ios\` directory, then rebuild and re-run the app.

  • Make sure your project's \`package.json\` depends on \`@react-native-async-storage/async-storage\`, even if you only depend on it indirectly through other dependencies. CLI only autolinks native modules found in your \`package.json\`.

  • If this happens while testing with Jest, check out how to integrate AsyncStorage here: https://react-native-async-storage.github.io/async-storage/docs/advanced/jest

If none of these fix the issue, please open an issue on the GitHub repository: https://github.com/react-native-async-storage/async-storage/issues
`);
}
/**
 * `AsyncStorage` is a simple, unencrypted, asynchronous, persistent, key-value
 * storage system that is global to the app. It should be used instead of
 * LocalStorage.
 *
 * See https://react-native-async-storage.github.io/async-storage/docs/api
 */ var AsyncStorage = (()=>{
    var _getRequests = [];
    var _getKeys = [];
    var _immediate = null;
    return {
        /**
     * Fetches an item for a `key` and invokes a callback upon completion.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#getitem
     */ getItem: (key, callback)=>{
            return new Promise((resolve, reject)=>{
                (0, _helpers.checkValidInput)(key);
                _RCTAsyncStorage.default.multiGet([
                    key
                ], (errors, result)=>{
                    var _result_;
                    // Unpack result to get value from [[key,value]]
                    var value = (result === null || result === void 0 ? void 0 : (_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[1]) ? result[0][1] : null;
                    var errs = (0, _helpers.convertErrors)(errors);
                    callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0], value);
                    if (errs) {
                        reject(errs[0]);
                    } else {
                        resolve(value);
                    }
                });
            });
        },
        /**
     * Sets the value for a `key` and invokes a callback upon completion.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#setitem
     */ setItem: (key, value, callback)=>{
            return new Promise((resolve, reject)=>{
                (0, _helpers.checkValidInput)(key, value);
                _RCTAsyncStorage.default.multiSet([
                    [
                        key,
                        value
                    ]
                ], (errors)=>{
                    var errs = (0, _helpers.convertErrors)(errors);
                    callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0]);
                    if (errs) {
                        reject(errs[0]);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Removes an item for a `key` and invokes a callback upon completion.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#removeitem
     */ removeItem: (key, callback)=>{
            return new Promise((resolve, reject)=>{
                (0, _helpers.checkValidInput)(key);
                _RCTAsyncStorage.default.multiRemove([
                    key
                ], (errors)=>{
                    var errs = (0, _helpers.convertErrors)(errors);
                    callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0]);
                    if (errs) {
                        reject(errs[0]);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Merges an existing `key` value with an input value, assuming both values
     * are stringified JSON.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#mergeitem
     */ mergeItem: (key, value, callback)=>{
            return new Promise((resolve, reject)=>{
                (0, _helpers.checkValidInput)(key, value);
                _RCTAsyncStorage.default.multiMerge([
                    [
                        key,
                        value
                    ]
                ], (errors)=>{
                    var errs = (0, _helpers.convertErrors)(errors);
                    callback === null || callback === void 0 ? void 0 : callback(errs === null || errs === void 0 ? void 0 : errs[0]);
                    if (errs) {
                        reject(errs[0]);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Erases *all* `AsyncStorage` for all clients, libraries, etc. You probably
     * don't want to call this; use `removeItem` or `multiRemove` to clear only
     * your app's keys.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#clear
     */ clear: (callback)=>{
            return new Promise((resolve, reject)=>{
                _RCTAsyncStorage.default.clear((error)=>{
                    var err = (0, _helpers.convertError)(error);
                    callback === null || callback === void 0 ? void 0 : callback(err);
                    if (err) {
                        reject(err);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Gets *all* keys known to your app; for all callers, libraries, etc.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#getallkeys
     */ getAllKeys: (callback)=>{
            return new Promise((resolve, reject)=>{
                _RCTAsyncStorage.default.getAllKeys((error, keys)=>{
                    var err = (0, _helpers.convertError)(error);
                    callback === null || callback === void 0 ? void 0 : callback(err, keys);
                    if (keys) {
                        resolve(keys);
                    } else {
                        reject(err);
                    }
                });
            });
        },
        /**
     * The following batched functions are useful for executing a lot of
     * operations at once, allowing for native optimizations and provide the
     * convenience of a single callback after all operations are complete.
     *
     * These functions return arrays of errors, potentially one for every key.
     * For key-specific errors, the Error object will have a key property to
     * indicate which key caused the error.
     */ /**
     * Flushes any pending requests using a single batch call to get the data.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#flushgetrequests
     * */ flushGetRequests: ()=>{
            var getRequests = _getRequests;
            var getKeys = _getKeys;
            _getRequests = [];
            _getKeys = [];
            _RCTAsyncStorage.default.multiGet(getKeys, (errors, result)=>{
                // Even though the runtime complexity of this is theoretically worse vs if we used a map,
                // it's much, much faster in practice for the data sets we deal with (we avoid
                // allocating result pair arrays). This was heavily benchmarked.
                //
                // Is there a way to avoid using the map but fix the bug in this breaking test?
                // https://github.com/facebook/react-native/commit/8dd8ad76579d7feef34c014d387bf02065692264
                var map = {};
                result === null || result === void 0 ? void 0 : result.forEach((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                    map[key] = value;
                    return value;
                });
                var reqLength = getRequests.length;
                /**
           * As mentioned few lines above, this method could be called with the array of potential error,
           * in case of anything goes wrong. The problem is, if any of the batched calls fails
           * the rest of them would fail too, but the error would be consumed by just one. The rest
           * would simply return `undefined` as their result, rendering false negatives.
           *
           * In order to avoid this situation, in case of any call failing,
           * the rest of them will be rejected as well (with the same error).
           */ var errorList = (0, _helpers.convertErrors)(errors);
                var error = (errorList === null || errorList === void 0 ? void 0 : errorList.length) ? errorList[0] : null;
                for(var i = 0; i < reqLength; i++){
                    var _request_callback, _request_resolve;
                    var request = getRequests[i];
                    if (error) {
                        var _request_callback1, _request_reject;
                        (_request_callback1 = request.callback) === null || _request_callback1 === void 0 ? void 0 : _request_callback1.call(request, errorList);
                        (_request_reject = request.reject) === null || _request_reject === void 0 ? void 0 : _request_reject.call(request, error);
                        continue;
                    }
                    var requestResult = request.keys.map((key)=>[
                            key,
                            map[key]
                        ]);
                    (_request_callback = request.callback) === null || _request_callback === void 0 ? void 0 : _request_callback.call(request, null, requestResult);
                    (_request_resolve = request.resolve) === null || _request_resolve === void 0 ? void 0 : _request_resolve.call(request, requestResult);
                }
            });
        },
        /**
     * This allows you to batch the fetching of items given an array of `key`
     * inputs. Your callback will be invoked with an array of corresponding
     * key-value pairs found.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiget
     */ multiGet: (keys, callback)=>{
            if (!_immediate) {
                _immediate = setImmediate(()=>{
                    _immediate = null;
                    AsyncStorage.flushGetRequests();
                });
            }
            var getRequest = {
                keys: keys,
                callback: callback,
                // do we need this?
                keyIndex: _getKeys.length
            };
            var promiseResult = new Promise((resolve, reject)=>{
                getRequest.resolve = resolve;
                getRequest.reject = reject;
            });
            _getRequests.push(getRequest);
            // avoid fetching duplicates
            keys.forEach((key)=>{
                if (_getKeys.indexOf(key) === -1) {
                    _getKeys.push(key);
                }
            });
            return promiseResult;
        },
        /**
     * Use this as a batch operation for storing multiple key-value pairs. When
     * the operation completes you'll get a single callback with any errors.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiset
     */ multiSet: (keyValuePairs, callback)=>{
            (0, _helpers.checkValidArgs)(keyValuePairs, callback);
            return new Promise((resolve, reject)=>{
                keyValuePairs.forEach((ref)=>{
                    var _ref = _sliced_to_array._(ref, 2), key = _ref[0], value = _ref[1];
                    (0, _helpers.checkValidInput)(key, value);
                });
                _RCTAsyncStorage.default.multiSet(keyValuePairs, (errors)=>{
                    var error = (0, _helpers.convertErrors)(errors);
                    callback === null || callback === void 0 ? void 0 : callback(error);
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Call this to batch the deletion of all keys in the `keys` array.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#multiremove
     */ multiRemove: (keys, callback)=>{
            return new Promise((resolve, reject)=>{
                keys.forEach((key)=>(0, _helpers.checkValidInput)(key));
                _RCTAsyncStorage.default.multiRemove(keys, (errors)=>{
                    var error = (0, _helpers.convertErrors)(errors);
                    callback === null || callback === void 0 ? void 0 : callback(error);
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                });
            });
        },
        /**
     * Batch operation to merge in existing and new values for a given set of
     * keys. This assumes that the values are stringified JSON.
     *
     * See https://react-native-async-storage.github.io/async-storage/docs/api#multimerge
     */ multiMerge: (keyValuePairs, callback)=>{
            return new Promise((resolve, reject)=>{
                _RCTAsyncStorage.default.multiMerge(keyValuePairs, (errors)=>{
                    var error = (0, _helpers.convertErrors)(errors);
                    callback === null || callback === void 0 ? void 0 : callback(error);
                    if (error) {
                        reject(error);
                    } else {
                        resolve();
                    }
                });
            });
        }
    };
})();
var _default = AsyncStorage;


}),
79945: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _default;
    }
}));
var _reactnative = __webpack_require__(38160);
var _shouldFallbackToLegacyNativeModule = __webpack_require__(2047);
// TurboModuleRegistry falls back to NativeModules so we don't have to try go
// assign NativeModules' counterparts if TurboModuleRegistry would resolve
// with undefined.
var RCTAsyncStorage = _reactnative.TurboModuleRegistry ? _reactnative.TurboModuleRegistry.get("PlatformLocalStorage") || // Support for external modules, like react-native-windows
_reactnative.TurboModuleRegistry.get("RNC_AsyncSQLiteDBStorage") || _reactnative.TurboModuleRegistry.get("RNCAsyncStorage") : _reactnative.NativeModules["PlatformLocalStorage"] || // Support for external modules, like react-native-windows
_reactnative.NativeModules["RNC_AsyncSQLiteDBStorage"] || _reactnative.NativeModules["RNCAsyncStorage"];
if (!RCTAsyncStorage && (0, _shouldFallbackToLegacyNativeModule.shouldFallbackToLegacyNativeModule)()) {
    if (_reactnative.TurboModuleRegistry) {
        RCTAsyncStorage = _reactnative.TurboModuleRegistry.get("AsyncSQLiteDBStorage") || _reactnative.TurboModuleRegistry.get("AsyncLocalStorage");
    } else {
        RCTAsyncStorage = _reactnative.NativeModules["AsyncSQLiteDBStorage"] || _reactnative.NativeModules["AsyncLocalStorage"];
    }
}
var _default = RCTAsyncStorage;


}),
34996: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    checkValidArgs: function() {
        return checkValidArgs;
    },
    checkValidInput: function() {
        return checkValidInput;
    },
    convertError: function() {
        return convertError;
    },
    convertErrors: function() {
        return convertErrors;
    }
});
var _sliced_to_array = __webpack_require__(17738);
function checkValidArgs(keyValuePairs, callback) {
    if (!Array.isArray(keyValuePairs) || keyValuePairs.length === 0 || !Array.isArray(keyValuePairs[0])) {
        throw new Error("[AsyncStorage] Expected array of key-value pairs as first argument to multiSet");
    }
    if (callback && typeof callback !== "function") {
        if (Array.isArray(callback)) {
            throw new Error("[AsyncStorage] Expected function as second argument to multiSet. Did you forget to wrap key-value pairs in an array for the first argument?");
        }
        throw new Error("[AsyncStorage] Expected function as second argument to multiSet");
    }
}
function checkValidInput(...input) {
    var _input = _sliced_to_array._(input, 2), key = _input[0], value = _input[1];
    if (typeof key !== "string") {
        // eslint-disable-next-line no-console
        console.warn(`[AsyncStorage] Using ${typeof key} type for key is not supported. This can lead to unexpected behavior/errors. Use string instead.\nKey passed: ${key}\n`);
    }
    if (input.length > 1 && typeof value !== "string") {
        if (value == null) {
            throw new Error(`[AsyncStorage] Passing null/undefined as value is not supported. If you want to remove value, Use .removeItem method instead.\nPassed value: ${value}\nPassed key: ${key}\n`);
        } else {
            // eslint-disable-next-line no-console
            console.warn(`[AsyncStorage] The value for key "${key}" is not a string. This can lead to unexpected behavior/errors. Consider stringifying it.\nPassed value: ${value}\nPassed key: ${key}\n`);
        }
    }
}
function convertError(error) {
    if (!error) {
        return null;
    }
    var out = new Error(error.message);
    out["key"] = error.key;
    return out;
}
function convertErrors(errs) {
    var errors = ensureArray(errs);
    return errors ? errors.map((e)=>convertError(e)) : null;
}
function ensureArray(e) {
    if (Array.isArray(e)) {
        return e.length === 0 ? null : e;
    } else if (e) {
        return [
            e
        ];
    } else {
        return null;
    }
}


}),
46396: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "useAsyncStorage", ({
    enumerable: true,
    get: function() {
        return useAsyncStorage;
    }
}));
var _interop_require_default = __webpack_require__(97433);
var _to_consumable_array = __webpack_require__(58678);
var _AsyncStorage = /*#__PURE__*/ _interop_require_default._(__webpack_require__(70870));
function useAsyncStorage(key) {
    var _AsyncStorage1, _AsyncStorage2, _AsyncStorage3, _AsyncStorage4;
    return {
        getItem: (...args)=>(_AsyncStorage1 = _AsyncStorage.default).getItem.apply(_AsyncStorage1, [
                key
            ].concat(_to_consumable_array._(args))),
        setItem: (...args)=>(_AsyncStorage2 = _AsyncStorage.default).setItem.apply(_AsyncStorage2, [
                key
            ].concat(_to_consumable_array._(args))),
        mergeItem: (...args)=>(_AsyncStorage3 = _AsyncStorage.default).mergeItem.apply(_AsyncStorage3, [
                key
            ].concat(_to_consumable_array._(args))),
        removeItem: (...args)=>(_AsyncStorage4 = _AsyncStorage.default).removeItem.apply(_AsyncStorage4, [
                key
            ].concat(_to_consumable_array._(args)))
    };
}


}),
53451: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    default: function() {
        return _default;
    },
    useAsyncStorage: function() {
        return _hooks.useAsyncStorage;
    }
});
var _interop_require_default = __webpack_require__(97433);
var _AsyncStorage = /*#__PURE__*/ _interop_require_default._(__webpack_require__(70870));
var _hooks = __webpack_require__(46396);
var _default = _AsyncStorage.default;


}),
2047: (function (__unused_webpack_module, exports, __webpack_require__) {
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "shouldFallbackToLegacyNativeModule", ({
    enumerable: true,
    get: function() {
        return shouldFallbackToLegacyNativeModule;
    }
}));
var _reactnative = __webpack_require__(38160);
function shouldFallbackToLegacyNativeModule() {
    var _NativeModules_NativeUnimoduleProxy_modulesConstants, _NativeModules_NativeUnimoduleProxy;
    var expoConstants = (_NativeModules_NativeUnimoduleProxy = _reactnative.NativeModules["NativeUnimoduleProxy"]) === null || _NativeModules_NativeUnimoduleProxy === void 0 ? void 0 : (_NativeModules_NativeUnimoduleProxy_modulesConstants = _NativeModules_NativeUnimoduleProxy.modulesConstants) === null || _NativeModules_NativeUnimoduleProxy_modulesConstants === void 0 ? void 0 : _NativeModules_NativeUnimoduleProxy_modulesConstants.ExponentConstants;
    if (expoConstants) {
        /**
     * In SDK <= 39, appOwnership is defined in managed apps but executionEnvironment is not.
     * In bare React Native apps using expo-constants, appOwnership is never defined, so
     * isLegacySdkVersion will be false in that context.
     */ var isLegacySdkVersion = expoConstants.appOwnership && !expoConstants.executionEnvironment;
        /**
     * Expo managed apps don't include the @react-native-async-storage/async-storage
     * native modules yet, but the API interface is the same, so we can use the version
     * exported from React Native still.
     *
     * If in future releases (eg: @react-native-async-storage/async-storage >= 2.0.0) this
     * will likely not be valid anymore, and the package will need to be included in the Expo SDK
     * to continue to work.
     */ if (isLegacySdkVersion || [
            "storeClient",
            "standalone"
        ].includes(expoConstants.executionEnvironment)) {
            return true;
        }
    }
    return false;
}


}),

}]);//# sourceMappingURL=vendors-node_modules_pnpm_react-native-async-storage_async-storage_2_0_0_react-native_0_78_2_-a9cd72.chunk.bundle.map?platform=android